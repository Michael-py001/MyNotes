# 1.Flutter的基础知识

## 设置首页路径

如何设置进入首页，默认首页的路径是`/`，应用启动时会自动寻找`/`路径进入该页面.

```dart
static const String homePath = '/';
```

## Dart 中的关键字和语法

1. 变量声明关键字：

   - var：用于声明变量，类型由编译器自动推断

   - final：声明一个只能赋值一次的变量，运行时确定值

   - const：声明一个编译时常量，值必须在编译时确定

   - late：延迟初始化变量，声明时不需要立即赋值

   - dynamic：动态类型，可以赋任何类型的值

   - Object：所有对象的基类

2. 类型声明：

   - int：整数类型

   - double：浮点数类型

   - String：字符串类型

   - bool：布尔类型

   - List：列表类型

   - Map：映射类型

   - Set：集合类型

3. 函数相关关键字：

   - void：表示函数不返回值

   - async：声明异步函数

   - await：等待异步操作完成

   - sync：同步函数

   - yield：生成器函数中产生值

4. 类相关关键字：

   - class：定义类

   - extends：继承

   - implements：实现接口

   - mixin：混入

   - abstract：抽象类

   - static：静态成员

   - this：当前实例

   - super：父类引用

5. 访问修饰符：

   - public：默认访问级别

   - _（下划线）：私有成员

6. 控制流关键字：

   - if/else：条件语句

   - for：循环

   - while：循环

   - do/while：循环

   - switch/case：多分支选择

   - break：跳出循环

   - continue：继续下一次循环

   - return：返回值

7. 异常处理：

   - try/catch/finally：异常处理

   - throw：抛出异常

   - rethrow：重新抛出异常

8. 其他重要关键字：

   - import：导入库

   - export：导出库

   - part：部分库

   - typedef：类型别名

   - is：类型检查

   - as：类型转换

   - null：空值

   - assert：断言

9. 空安全相关：

   - ?：可空类型

   - !：非空断言

   - ??：空值合并

   - ??=：空值赋值

​	10. 泛型：

		- `<T>`：泛型类型参数
		- extends：泛型约束

这些是 Dart 语言中主要的语法和关键字。Dart 是一种强类型语言，支持面向对象编程，并且具有现代化的语言特性，如空安全、异步编程等。

### late （延迟初始化）

late 是 Dart 中的一个关键字，用于延迟初始化变量。让我详细解释 Dart 中的变量修饰符。

```dart
class MyWidget extends StatefulWidget {
  @override
  State<MyWidget> createState() => _MyWidgetState();
}

class _MyWidgetState extends State<MyWidget> {
  // 延迟初始化，但确保使用前会被初始化
  late String name;
  late final int age;
  late Future<List<String>> _dataFuture;

  @override
  void initState() {
    super.initState();
    name = "张三";         // 初始化
    age = 25;            // 只能初始化一次（因为有 final）
    _dataFuture = _fetchData();  // 初始化异步数据
  }
}
```

### final（一次性赋值）

```dart
class Person {
  // 只能赋值一次，运行时确定值
  final String name;
  final int age;
  
  // 构造函数中初始化
  Person(this.name, this.age);
}

void example() {
  final time = DateTime.now();  // 运行时确定值
  final List<int> numbers = [1, 2, 3];
  // numbers = [4, 5, 6];  // 错误：不能重新赋值
  numbers.add(4);  // 可以修改列表内容
}
```

### const（编译时常量）

```dart
class Config {
  // 编译时就确定的常量
  static const String appName = "My App";
  static const int version = 1;
}

void example() {
  const pi = 3.14159;
  const List<int> numbers = [1, 2, 3];
  // numbers.add(4);  // 错误：不能修改常量列表
}
```

### static（静态成员）

```dart
class Helper {
  // 静态变量，属于类而不是实例
  static int counter = 0;
  static const String type = "helper";
  
  // 静态方法
  static void increment() {
    counter++;
  }
}
```

### 实际应用示例

```dart
class UserProfile extends StatefulWidget {
  @override
  State<UserProfile> createState() => _UserProfileState();
}

class _UserProfileState extends State<UserProfile> {
  // 1. late 变量
  late TextEditingController _controller;
  late Future<Map<String, dynamic>> _userFuture;
  
  // 2. final 变量
  final String title = "个人资料";
  
  // 3. const 常量
  static const int maxNameLength = 20;
  
  // 4. 普通变量
  String? _errorMessage;
  bool _isLoading = false;

  @override
  void initState() {
    super.initState();
    // 初始化 late 变量
    _controller = TextEditingController();
    _userFuture = _fetchUserData();
  }

  Future<Map<String, dynamic>> _fetchUserData() async {
    setState(() => _isLoading = true);
    try {
      final response = await http.get(Uri.parse('api/user'));
      return json.decode(response.body);
    } catch (e) {
      _errorMessage = e.toString();
      return {};
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text(title)),
      body: _buildBody(),
    );
  }

  Widget _buildBody() {
    return FutureBuilder<Map<String, dynamic>>(
      future: _userFuture,
      builder: (context, snapshot) {
        if (_isLoading) {
          return Center(child: CircularProgressIndicator());
        }

        if (_errorMessage != null) {
          return Center(child: Text(_errorMessage!));
        }

        if (!snapshot.hasData) {
          return Center(child: Text('无数据'));
        }

        final userData = snapshot.data!;
        return Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            children: [
              TextField(
                controller: _controller,
                maxLength: maxNameLength,
                decoration: InputDecoration(
                  labelText: '用户名',
                ),
              ),
            ],
          ),
        );
      },
    );
  }
}
```

### 变量修饰符的特点比较

```dart
class Example {
  // 1. late：延迟初始化
  late String lateString;        // 可以稍后初始化
  late final int lateFinalInt;   // 可以稍后初始化一次
  
  // 2. final：运行时常量
  final String finalString;      // 必须在构造时初始化
  final List<int> finalList;     // 引用不可变，内容可变
  
  // 3. const：编译时常量
  static const int constInt = 42;    // 必须在编译时知道值
  static const List<int> constList = [1, 2, 3];  // 完全不可变
  
  // 4. static：静态成员
  static String staticString = "static";  // 属于类
  static final int staticFinal = 100;     // 静态final
  
  Example(this.finalString, this.finalList) {
    lateString = "初始化";
    lateFinalInt = 42;
  }
}
```

使用建议：

1. late 用于：

   - 确定会在使用前初始化的变量

   - 延迟初始化以提高性能

   - 处理循环依赖

2. final 用于：

   - 运行时只需赋值一次的变量

   - 不会改变的配置或设置

   - 构造函数参数

3. const 用于：

   - 编译时就能确定的常量

   - 不变的配置值

   - 静态常量

4. static 用于：

   - 类级别的变量和方法

   - 工具类的成员

   - 共享的常量

注意事项：

1. late 变量使用前必须初始化
2. final 变量只能赋值一次
3. const 值必须在编译时确定
4. static 成员属于类而不是实例

### 关键字 `factory`

```dart
class ApiFactory {
  late HttpClient httpClient;
  late ApiRegister apiRegister;

  static final ApiFactory _instance = ApiFactory._internal();
  factory ApiFactory() => _instance;

  ApiFactory._internal();
}
```

- 声明这是一个工厂构造函数，而不是普通构造函数

- 工厂构造函数可以返回已存在的实例，而不必创建新对象

#### ApiFactory()：

- 构造函数的名称，与类名相同

- 这是类的主构造函数，但由于前面有factory关键字，使其成为工厂构造函数

#### => `_instance：`

- 箭头函数语法，表示直接返回`_instance`

- `_instance`是先前定义的静态变量：`static final ApiFactory _instance = ApiFactory._internal();`

#### 工作原理

这个工厂构造函数的作用是每次调用ApiFactory()时都返回同一个实例（_instance），而不是创建新对象。

```dart
// 单例模式的完整实现
class ApiFactory {
  // 1. 私有静态实例，使用私有构造函数创建
  static final ApiFactory _instance = ApiFactory._internal();
  
  // 2. 工厂构造函数，返回单例实例
  factory ApiFactory() => _instance;
  
  // 3. 私有命名构造函数，用于创建实例
  ApiFactory._internal();
  
  // 类的其他方法...
}
```

使用示例：

```dart
// 获取ApiFactory实例
final factory1 = ApiFactory();
final factory2 = ApiFactory();

// factory1和factory2是同一个对象实例
print(identical(factory1, factory2)); // 输出: true
```

#### 工厂构造函数vs普通构造函数

- `普通构造函数`：每次调用都会创建一个新对象

- `工厂构造函数`：可以返回现有对象，或基于条件创建不同类型的对象

工厂构造函数是Dart中实现设计模式(如单例、工厂方法)的强大工具，允许你控制对象的创建过程，而不仅仅是初始化新实例。

## 主题获取

### 案例一

```dart
final theme = Theme.of(context);
```

这是一个典型的 Flutter 主题获取语句，让我分解它的各个部分：

1. `final`：

   - 这是一个变量声明关键字

   - 表示 `theme` 变量只能被赋值一次

   - 一旦赋值后就不能再改变

2. `theme`：

   - 这是变量名


   - 用于存储获取到的主题数据


3. `Theme.of(context)`：

   - Theme 是 Flutter 提供的一个类，用于管理应用程序的主题


   - `.of(context)` 是一个静态方法，用于从 widget 树中获取最近的 Theme 数据


   - `context` 是 BuildContext 对象，它包含了 widget 在树中的位置信息


4. 工作原理：

   - 当调用 `Theme.of(context)` 时，Flutter 会沿着 widget 树向上查找最近的 Theme 数据


   - 这个数据通常是在 `MaterialApp` 或 `Theme widget` 中定义的


   - 返回的是一个 `ThemeData` 对象，包含了所有主题相关的属性（如颜色、字体、形状等）


5. 使用场景：

   - 通常在 widget 的 build 方法中使用


   - 用于获取当前主题的颜色、文本样式等


   - 确保 widget 能够响应主题变化

6. 示例用法：

   ```dart
   final theme = Theme.of(context);
   // 使用主题颜色
   Color primaryColor = theme.primaryColor;
   // 使用主题文本样式
   TextStyle textStyle = theme.textTheme.bodyLarge;
   ```

这个语句是 Flutter 中获取主题信息的标准方式，它确保了 widget 能够正确地使用应用程序的主题设置，并且能够响应主题的变化。

### 案例二

```dart
final style = theme.textTheme.displayMedium!
        .copyWith(color: theme.colorScheme.onPrimary);
```

这是一个文本样式设置的语句。

1. `theme.textTheme.displayMedium!`：

   - `textTheme` 是 `ThemeData` 中的一个属性，包含了预定义的文本样式集合

   - `displayMedium` 是文本样式的一种，用于中等大小的显示文本

   - `!` 是非空断言操作符，表示我们确定这个值不会为 null

2. `.copyWith()`：

   - 这是一个方法，用于创建现有样式的副本并修改特定属性

   - 它不会修改原始样式，而是返回一个新的样式对象

3. `color: theme.colorScheme.onPrimary`：

   - `colorScheme` 是主题中的颜色方案

   - `onPrimary` 是在主色上显示文本时应该使用的颜色

   - 这确保了文本在背景色上有良好的对比度

4. 整体效果：

   - 获取了主题中预定义的 displayMedium 文本样式

   - 创建了一个新的样式，保持了原有样式的所有属性

   - 只修改了颜色属性，使其使用主题中定义的 onPrimary 颜色


## Flutter内置布局类

### EdgeInsets （内边距）

`EdgeInsets` 是 Flutter 框架内置的一个类，它属于 `dart:ui` 和 Flutter 的 Material Design 实现。

#### 基础构造用法:

```dart
// 四个方向都相同的内边距
EdgeInsets.all(8.0)  // 上下左右都是 8.0

// 分别指定四个方向的内边距
EdgeInsets.fromLTRB(left, top, right, bottom)  
// 例如：EdgeInsets.fromLTRB(10.0, 20.0, 10.0, 20.0)

// 使用命名参数指定特定方向的内边距
EdgeInsets.only(
    left: 10.0,
    top: 20.0,
    right: 10.0,
    bottom: 20.0,
)

// 设置水平和垂直方向的内边距
EdgeInsets.symmetric(
    vertical: 8.0,   // 上下内边距
    horizontal: 16.0 // 左右内边距
)
```

#### 常见使用场景

```dart
// 在容器中使用
Container(
    padding: EdgeInsets.all(16.0),
    child: Text('Hello'),
)

// 在 Padding widget 中使用
Padding(
    padding: EdgeInsets.symmetric(
        horizontal: 16.0,
        vertical: 8.0
    ),
    child: Text('Hello'),
)

// 在列表项中使用
ListTile(
    contentPadding: EdgeInsets.only(left: 16.0),
    title: Text('List Item'),
)

// 在按钮中使用
ElevatedButton(
    padding: EdgeInsets.symmetric(
        horizontal: 20.0,
        vertical: 10.0
    ),
    child: Text('Button'),
    onPressed: () {},
)
```

#### 实际应用示例

```dart
// 卡片布局
Card(
    margin: EdgeInsets.all(16.0),  // 外边距
    child: Padding(
        padding: EdgeInsets.all(16.0),  // 内边距
        child: Column(
            children: [
                Text('标题'),
                SizedBox(height: 8.0),
                Text('内容'),
            ],
        ),
    ),
)

// 表单布局
Form(
    child: Column(
        children: [
            Padding(
                padding: EdgeInsets.symmetric(
                    vertical: 8.0,
                    horizontal: 16.0
                ),
                child: TextField(),
            ),
            Padding(
                padding: EdgeInsets.only(
                    left: 16.0,
                    right: 16.0,
                    bottom: 8.0
                ),
                child: TextField(),
            ),
        ],
    ),
)

// 列表项布局
ListView(
    children: [
        Container(
            padding: EdgeInsets.symmetric(
                vertical: 12.0,
                horizontal: 16.0
            ),
            child: Text('列表项 1'),
        ),
        Container(
            padding: EdgeInsets.symmetric(
                vertical: 12.0,
                horizontal: 16.0
            ),
            child: Text('列表项 2'),
        ),
    ],
)
```

注意事项：

- EdgeInsets 的值通常使用逻辑像素（logical pixels）

- 可以使用 const 来优化性能

- 可以通过 MediaQuery 来获取屏幕信息，实现响应式内边距

### Margin（外边距）

通常通过 margin 属性使用 EdgeInsets 来设置

```dart
Container(
    margin: EdgeInsets.all(8.0),
    child: Text('Hello'),
)
```

### Alignment（对齐方式）

```dart
// 用于控制子组件在父组件中的对齐方式
Alignment.center
Alignment.topLeft
Alignment.bottomRight
Alignment(0.0, 0.0)  // 自定义对齐位置
```

### BorderRadius（边框圆角）

```dart
// 设置圆角
BorderRadius.circular(8.0)  // 所有角相同
BorderRadius.only(
    topLeft: Radius.circular(8.0),
    bottomRight: Radius.circular(8.0)
)
```

### BoxConstraints（盒子约束）

```dart
// 控制组件大小的约束条件
BoxConstraints(
    minWidth: 100,
    maxWidth: 200,
    minHeight: 50,
    maxHeight: 150
)
```

### Size（尺寸）

```dart
// 明确的宽高
Size(100, 200)
Size.square(100)  // 正方形
```

### Offset（偏移）

```dart
// 用于位置偏移
Offset(10.0, 20.0)  // x和y方向的偏移
```

### Radius（圆角半径）

```dart
// 定义圆角
Radius.circular(8.0)
Radius.elliptical(4.0, 8.0)  // 椭圆形圆角
```

### Thickness（厚度）

```dart
// 通常用于分隔线等
Divider(thickness: 2.0)
```

### Spacing（间距）

```dart
// 在Row、Column中使用
Row(
    mainAxisSpacing: 8.0,
    crossAxisSpacing: 8.0,
)
```

### 实际应用示例：

```dart
Container(
    // 外边距
    margin: EdgeInsets.all(8.0),
    // 内边距
    padding: EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
    // 对齐方式
    alignment: Alignment.center,
    // 装饰
    decoration: BoxDecoration(
        // 圆角
        borderRadius: BorderRadius.circular(8.0),
        // 颜色
        color: Colors.blue,
        // 阴影
        boxShadow: [
            BoxShadow(
                offset: Offset(0, 2),
                blurRadius: 4.0,
                color: Colors.black26,
            )
        ],
    ),
    // 约束
    constraints: BoxConstraints(
        maxWidth: 300,
        minHeight: 50,
    ),
    child: Text('Hello World'),
)
```

## Flutter内置组件

### Scaffold （基础页面脚手架）

Scaffold 是 Flutter 中一个非常重要的布局组件，它实现了基本的 Material Design 布局结构。

```dart
class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: HomePage(),
    );
  }
}

class HomePage extends StatefulWidget {
  @override
  _HomePageState createState() => _HomePageState();
}

class _HomePageState extends State<HomePage> {
  int _selectedIndex = 0;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      // 1. 应用栏
      appBar: AppBar(
        title: Text('我的应用'),
        actions: [
          IconButton(
            icon: Icon(Icons.search),
            onPressed: () {},
          ),
          IconButton(
            icon: Icon(Icons.settings),
            onPressed: () {},
          ),
        ],
      ),

      // 2. 抽屉菜单
      drawer: Drawer(
        child: ListView(
          children: [
            UserAccountsDrawerHeader(
              accountName: Text('用户名'),
              accountEmail: Text('email@example.com'),
              currentAccountPicture: CircleAvatar(
                child: Text('U'),
              ),
            ),
            ListTile(
              leading: Icon(Icons.home),
              title: Text('首页'),
              onTap: () {},
            ),
            ListTile(
              leading: Icon(Icons.settings),
              title: Text('设置'),
              onTap: () {},
            ),
          ],
        ),
      ),

      // 3. 主体内容
      body: IndexedStack(
        index: _selectedIndex,
        children: [
          // 首页
          Container(
            child: Column(
              children: [
                // 卡片列表
                Expanded(
                  child: ListView.builder(
                    itemCount: 10,
                    itemBuilder: (context, index) {
                      return Card(
                        margin: EdgeInsets.all(8),
                        child: ListTile(
                          leading: Icon(Icons.article),
                          title: Text('标题 $index'),
                          subtitle: Text('描述内容'),
                          trailing: Icon(Icons.arrow_forward_ios),
                        ),
                      );
                    },
                  ),
                ),
              ],
            ),
          ),
          // 分类页
          GridView.builder(
            padding: EdgeInsets.all(8),
            gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
              crossAxisCount: 2,
              mainAxisSpacing: 8,
              crossAxisSpacing: 8,
            ),
            itemCount: 8,
            itemBuilder: (context, index) {
              return Container(
                decoration: BoxDecoration(
                  color: Colors.blue[100],
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Center(
                  child: Text('分类 $index'),
                ),
              );
            },
          ),
          // 我的页面
          Center(
            child: Text('我的'),
          ),
        ],
      ),

      // 4. 底部导航栏
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: _selectedIndex,
        onTap: (index) {
          setState(() {
            _selectedIndex = index;
          });
        },
        items: [
          BottomNavigationBarItem(
            icon: Icon(Icons.home),
            label: '首页',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.category),
            label: '分类',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.person),
            label: '我的',
          ),
        ],
      ),

      // 5. 悬浮按钮
      floatingActionButton: FloatingActionButton(
        onPressed: () {},
        child: Icon(Icons.add),
      ),
    );
  }
}
```



### Padding

1. `Padding widget`：
   - 这是一个基础布局 widget

   - 用于在其子 widget 周围添加内边距（padding）

   - 常用于调整 widget 之间的间距

2. `padding: const EdgeInsets.all(20.0)`：

   - `EdgeInsets.all()` 创建四个方向相同的内边距

   - `20.0` 表示内边距的大小（单位是逻辑像素）

   - `const` 表示这是一个编译时常量，可以提高性能

   - 这里的效果是在所有方向（上、下、左、右）添加 20 像素的内边距

3. `child: Text()`：

   - child 是 Padding 的子 widget

   - Text 是用来显示文本的 widget

4. `pair.asCamelCase`：

   - `pair` 是一个 WordPair 对象（从代码上下文可知）

   - `asCamelCase` 是将词对转换为驼峰命名格式

   - 例如：如果 pair 是 "hello world"，asCamelCase 会转换为 "helloWorld"

5. `style: style`：

   - 使用之前定义的 `style` 变量来设置文本样式

   - 这个 style 包含了从主题中获取的文本样式和颜色设置


```dart
class BigCard extends StatelessWidget {
  const BigCard({
    super.key,
    required this.pair,
  });

  final WordPair pair;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final style = theme.textTheme.displayMedium!
        .copyWith(color: theme.colorScheme.onPrimary);
    return Card(
      color: theme.colorScheme.primary,
      child: Padding(
        padding: const EdgeInsets.all(20.0),
        child: Text(pair.asCamelCase, style: style),
      ),
    );
  }
}
```

### SizedBox（固定尺寸盒子）

```dart
// 固定宽高
SizedBox(
    width: 100,
    height: 50,
    child: Text('Hello'),
)

// 常用作间隔
SizedBox(height: 16.0)  // 垂直间隔
SizedBox(width: 16.0)   // 水平间隔

// 占满可用空间
SizedBox.expand(
    child: Text('Expanded Text'),
)

// 方形盒子
SizedBox.square(
    dimension: 50,
    child: Container(color: Colors.blue),
)
```

### TextField（文本输入框）

```dart
// 基本用法
TextField(
    decoration: InputDecoration(
        labelText: '用户名',
        hintText: '请输入用户名',
        prefixIcon: Icon(Icons.person),
    ),
    controller: TextEditingController(),
    onChanged: (value) {
        print('输入的内容：$value');
    },
)

// 密码输入框
TextField(
    obscureText: true,  // 隐藏输入内容
    decoration: InputDecoration(
        labelText: '密码',
        suffixIcon: Icon(Icons.visibility),
    ),
)

// 多行输入
TextField(
    maxLines: 3,
    decoration: InputDecoration(
        border: OutlineInputBorder(),
    ),
)
```

#### 其他常用属性

```dart
TextField(
    // 键盘类型
    keyboardType: TextInputType.number,
    
    // 文本对齐方式
    textAlign: TextAlign.center,
    
    // 最大行数
    maxLines: 3,
    
    // 是否自动获取焦点
    autofocus: true,
    
    // 是否只读
    readOnly: true,
    
    // 输入格式限制
    inputFormatters: [
        FilteringTextInputFormatter.digitsOnly,  // 只允许输入数字
    ],
    
    // 文本样式
    style: TextStyle(
        fontSize: 16.0,
        color: Colors.black,
    ),
)
```



#### decoration 属性

- 类型是 `InputDecoration`

- 用于设置输入框的外观装饰

- 是输入框的视觉设计部分

```dart
TextField(
    decoration: InputDecoration(
        // 1. 文本相关
        labelText: '用户名',    // 标签文本，会在输入时浮动到上方
        hintText: '请输入用户名', // 提示文本，输入时会消失
        
        // 2. 图标相关
        prefixIcon: Icon(Icons.person),  // 前置图标
        suffixIcon: Icon(Icons.clear),   // 后置图标
        
        // 3. 边框相关
        border: OutlineInputBorder(),     // 外边框样式
        enabledBorder: OutlineInputBorder(  // 未选中时的边框
            borderSide: BorderSide(color: Colors.grey),
        ),
        focusedBorder: OutlineInputBorder(  // 选中时的边框
            borderSide: BorderSide(color: Colors.blue),
        ),
        
        // 4. 颜色和填充
        fillColor: Colors.grey[200],  // 填充颜色
        filled: true,                 // 是否填充
    ),
)
```

#### controller 属性

- 类型是 TextEditingController

- 用于控制和监听输入框的内容

- 是输入框的控制器，负责管理文本内容

```dart
// 1. 创建控制器
final TextEditingController _controller = TextEditingController();

// 2. 在 TextField 中使用
TextField(
    controller: _controller,
)

// 3. 控制器的常用操作
void someFunction() {
    // 获取文本
    print(_controller.text);
    
    // 设置文本
    _controller.text = '新文本';
    
    // 清空文本
    _controller.clear();
    
    // 选择文本
    _controller.selection = TextSelection(
        baseOffset: 0,
        extentOffset: _controller.text.length,
    );
    
    // 监听文本变化
    _controller.addListener(() {
        print('文本变化了：${_controller.text}');
    });
}
```

#### 实际使用示例

```dart
class MyWidget extends StatefulWidget {
  @override
  _MyWidgetState createState() => _MyWidgetState();
}

class _MyWidgetState extends State<MyWidget> {
  // 1. 声明控制器
  final TextEditingController _controller = TextEditingController();
  bool _isError = false;

  @override
  void initState() {
    super.initState();
    // 2. 设置初始值
    _controller.text = '默认值';
    
    // 3. 添加监听
    _controller.addListener(() {
      // 当文本变化时会调用这里
      setState(() {
        _isError = _controller.text.isEmpty;
      });
    });
  }

  @override
  Widget build(BuildContext context) {
    return TextField(
      // 4. 使用控制器
      controller: _controller,
      
      // 5. 设置装饰
      decoration: InputDecoration(
        labelText: '用户名',
        hintText: '请输入用户名',
        
        // 根据状态显示错误提示
        errorText: _isError ? '用户名不能为空' : null,
        
        // 添加清除按钮
        suffixIcon: IconButton(
          icon: Icon(Icons.clear),
          onPressed: () {
            _controller.clear();  // 使用控制器清空文本
          },
        ),
        
        // 设置边框
        border: OutlineInputBorder(),
        
        // 设置填充色
        fillColor: Colors.grey[200],
        filled: true,
      ),
      
      // 6. 文本变化回调
      onChanged: (value) {
        print('文本变化：$value');
      },
    );
  }

  @override
  void dispose() {
    // 7. 释放控制器
    _controller.dispose();
    super.dispose();
  }
}
```

#### 两者结合使用的优势

```dart
class MyWidget extends StatefulWidget {
  @override
  _MyWidgetState createState() => _MyWidgetState();
}

class _MyWidgetState extends State<MyWidget> {
  final TextEditingController _usernameController = TextEditingController();
  final TextEditingController _passwordController = TextEditingController();
  bool _isPasswordVisible = false;

  @override
  void initState() {
    super.initState();
    // 设置初始值
    _usernameController.text = '默认用户名';
    
    // 添加监听器
    _usernameController.addListener(() {
      print('用户名变化：${_usernameController.text}');
    });
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        // 用户名输入框
        TextField(
          controller: _usernameController,
          decoration: InputDecoration(
            labelText: '用户名',
            hintText: '请输入用户名',
            prefixIcon: Icon(Icons.person),
            border: OutlineInputBorder(),
            // 清除按钮
            suffixIcon: IconButton(
              icon: Icon(Icons.clear),
              onPressed: () => _usernameController.clear(),
            ),
          ),
        ),
        
        SizedBox(height: 16.0),
        
        // 密码输入框
        TextField(
          controller: _passwordController,
          obscureText: !_isPasswordVisible,
          decoration: InputDecoration(
            labelText: '密码',
            hintText: '请输入密码',
            prefixIcon: Icon(Icons.lock),
            border: OutlineInputBorder(),
            // 切换密码可见性
            suffixIcon: IconButton(
              icon: Icon(
                _isPasswordVisible ? Icons.visibility : Icons.visibility_off
              ),
              onPressed: () {
                setState(() {
                  _isPasswordVisible = !_isPasswordVisible;
                });
              },
            ),
          ),
        ),
        
        SizedBox(height: 16.0),
        
        // 提交按钮
        ElevatedButton(
          onPressed: () {
            print('用户名：${_usernameController.text}');
            print('密码：${_passwordController.text}');
          },
          child: Text('提交'),
        ),
      ],
    );
  }

  @override
  void dispose() {
    _usernameController.dispose();
    _passwordController.dispose();
    super.dispose();
  }
}
```

通过这样的组合使用：

- decoration 负责外观

- controller 负责逻辑控制

- 两者配合可以实现复杂的输入框功能

- 可以创建更好的用户体验

### TextFormField（带验证的输入框）

```dart
TextFormField(
    validator: (value) {
        if (value == null || value.isEmpty) {
            return '请输入内容';
        }
        return null;
    },
    decoration: InputDecoration(
        labelText: '邮箱',
    ),
)
```

### Container（容器）

```dart
Container(
    width: 200,
    height: 100,
    padding: EdgeInsets.all(8.0),
    margin: EdgeInsets.symmetric(vertical: 10.0),
    decoration: BoxDecoration(
        color: Colors.blue,
        borderRadius: BorderRadius.circular(8.0),
    ),
    child: Text('Hello'),
)
```

### Card（卡片）

```dart
Card(
    elevation: 4.0,
    child: Padding(
        padding: EdgeInsets.all(16.0),
        child: Text('Card Content'),
    ),
)
```

### 布局组件

#### Row（水平布局）

```dart
Row(
    mainAxisAlignment: MainAxisAlignment.spaceBetween,
    children: [
        Text('Left'),
        Text('Right'),
    ],
)
```

#### Column（垂直布局）

```dart
Column(
    crossAxisAlignment: CrossAxisAlignment.start,
    children: [
        Text('Top'),
        Text('Bottom'),
    ],
)
```

#### Stack（层叠布局）

```dart
Stack(
    children: [
        Image.network('background.jpg'),
        Positioned(
            bottom: 16.0,
            right: 16.0,
            child: Text('Overlay Text'),
        ),
    ],
)
```

### 常用功能组件

#### Image（图片）

```dart
// 网络图片
Image.network('https://example.com/image.jpg')

// 本地资源图片
Image.asset('assets/images/logo.png')

// 圆形图片
CircleAvatar(
    backgroundImage: NetworkImage('url'),
)
```

#### Button系列

```dart
// 普通按钮
ElevatedButton(
    onPressed: () {},
    child: Text('点击'),
)

// 文本按钮
TextButton(
    onPressed: () {},
    child: Text('点击'),
)

// 轮廓按钮
OutlinedButton(
    onPressed: () {},
    child: Text('点击'),
)
```

### Icon（图标）

```dart
Icon(Icons.star)
IconButton(
    icon: Icon(Icons.favorite),
    onPressed: () {},
)
```

### 列表组件

#### ListView（列表）

```dart
ListView.builder(
  itemCount: 10,
  itemBuilder: (context, index) {
    return ListTile(
      leading: Icon(Icons.star),
      title: Text('项目 $index'),
      subtitle: Text('描述'),
      trailing: Icon(Icons.arrow_forward),
      onTap: () {},
    );
  },
)
```

#### GridView（网格）

GridView 是 Flutter 中用于创建网格布局的组件，它可以在二维空间中排列多个子项。下面详细介绍其用法和 API

##### GridView 常用属性

```dart
GridView(
  gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
    crossAxisCount: 2,
  ),
  scrollDirection: Axis.vertical,  // 滚动方向
  reverse: false,  // 是否反向
  controller: ScrollController(),  // 滚动控制器
  primary: true,  // 是否使用 PrimaryScrollController
  physics: BouncingScrollPhysics(),  // 滚动物理效果
  shrinkWrap: false,  // 是否根据子项大小调整自身大小
  padding: EdgeInsets.all(10.0),  // 内边距
  addAutomaticKeepAlives: true,  // 是否自动保持状态
  addRepaintBoundaries: true,  // 是否添加重绘边界
  addSemanticIndexes: true,  // 是否添加语义索引
  cacheExtent: 0.0,  // 缓存区域
  children: [/* ... */],  // 子项列表
)
```



##### GridView 基本构造函数

```dart
GridView(
  gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
    crossAxisCount: 2,  // 每行显示的项数
    mainAxisSpacing: 10.0,  // 主轴间距
    crossAxisSpacing: 10.0,  // 交叉轴间距
    childAspectRatio: 1.0,  // 子项宽高比
  ),
  children: [
    Container(color: Colors.red),
    Container(color: Colors.green),
    Container(color: Colors.blue),
    Container(color: Colors.yellow),
  ],
)
```

##### GridView 常用工厂构造函数

###### GridView.count

```dart
GridView.count(
  crossAxisCount: 3,  // 每行显示的项数
  mainAxisSpacing: 10.0,  // 主轴间距
  crossAxisSpacing: 10.0,  // 交叉轴间距
  padding: EdgeInsets.all(10.0),  // 内边距
  children: [
    Container(color: Colors.red),
    Container(color: Colors.green),
    Container(color: Colors.blue),
  ],
)
```

```dart
GridView.count(
    crossAxisCount: 2,
    children: List.generate(4, (index) {
        return Card(
            child: Center(child: Text('Item $index')),
        );
    }),
)
```

###### GridView.extent

```dart
GridView.extent(
  maxCrossAxisExtent: 200.0,  // 子项最大宽度
  mainAxisSpacing: 10.0,
  crossAxisSpacing: 10.0,
  padding: EdgeInsets.all(10.0),
  children: [
    Container(color: Colors.red),
    Container(color: Colors.green),
    Container(color: Colors.blue),
  ],
)
```

###### GridView.builder

```dart
GridView.builder(
  gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
    crossAxisCount: 2,
    mainAxisSpacing: 10.0,
    crossAxisSpacing: 10.0,
  ),
  itemCount: 100,  // 总项数
  itemBuilder: (context, index) {
    // 构建每一项
    return Container(
      color: Colors.primaries[index % Colors.primaries.length],
      child: Center(
        child: Text('Item $index'),
      ),
    );
  },
)
```

###### GridView.custom

```dart
GridView.custom(
  gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
    crossAxisCount: 2,
  ),
  childrenDelegate: SliverChildListDelegate(
    [
      Container(color: Colors.red),
      Container(color: Colors.green),
      Container(color: Colors.blue),
    ],
  ),
)
```

#### SliverGridDelegate 详解

SliverGridDelegate 是控制 GridView 布局的委托类，有两个主要的实现：

#####  SliverGridDelegateWithFixedCrossAxisCount

这个委托用于创建横轴固定数量的网格布局。

```dart
SliverGridDelegateWithFixedCrossAxisCount(
  crossAxisCount: 3,  // 交叉轴上的子项数量（必需参数）
  mainAxisSpacing: 10.0,  // 主轴方向的间距
  crossAxisSpacing: 10.0,  // 交叉轴方向的间距
  childAspectRatio: 1.0,  // 子项的宽高比（宽度/高度）
)
```

参数解释：

- crossAxisCount：交叉轴上的子项数量，例如在垂直滚动的网格中，这是每行的列数

- mainAxisSpacing：主轴方向的间距（像素）

- crossAxisSpacing：交叉轴方向的间距（像素）

- childAspectRatio：子项的宽高比（宽度/高度）

##### SliverGridDelegateWithMaxCrossAxisExtent

这个委托用于创建横轴子项最大宽度固定的网格布局。

```dart
SliverGridDelegateWithMaxCrossAxisExtent(
  maxCrossAxisExtent: 200.0,  // 交叉轴上子项的最大尺寸（必需参数）
  mainAxisSpacing: 10.0,  // 主轴方向的间距
  crossAxisSpacing: 10.0,  // 交叉轴方向的间距
  childAspectRatio: 1.0,  // 子项的宽高比
)
```

参数解释：

- maxCrossAxisExtent：交叉轴上子项的最大尺寸，系统会根据此值和交叉轴总宽度自动计算出每行能放置的子项数量

- mainAxisSpacing：主轴方向的间距（像素）

- crossAxisSpacing：交叉轴方向的间距（像素）

- childAspectRatio：子项的宽高比（宽度/高度）

**SliverGridDelegateWithMaxCrossAxisExtent 工作原理:**

当使用 `SliverGridDelegateWithMaxCrossAxisExtent` 时，Flutter 会：

1. 根据 `maxCrossAxisExtent` 和交叉轴总宽度计算能放置的子项数量

1. 平均分配可用空间

1. 确保每个子项的实际宽度不超过 `maxCrossAxisExtent`

1. 应用 `childAspectRatio` 计算子项的高度

例如：如果交叉轴宽度是 500，而 `maxCrossAxisExtent` 是 200，那么 Flutter 会放置 3 个子项（500 / 200 = 2.5，向上取整为 3），每个子项宽度为 500/3 ≈ 166.7。



### 其他实用组件

#### Expanded（填充剩余空间）

```dart
Row(
    children: [
        Text('固定宽度'),
        Expanded(
            child: Text('填充剩余空间'),
        ),
    ],
)
```

### Divider（分隔线）

```dart
Column(
    children: [
        Text('Item 1'),
        Divider(),
        Text('Item 2'),
    ],
)
```

## Flutter内置装饰类

```dart
// 输入框装饰
InputDecoration

// 盒子装饰
BoxDecoration(
    color: Colors.blue,
    borderRadius: BorderRadius.circular(8.0),
    border: Border.all(color: Colors.black),
    boxShadow: [
        BoxShadow(
            color: Colors.grey,
            blurRadius: 4.0,
        ),
    ],
)

// 文本装饰
TextDecoration

// 图片装饰
DecorationImage
```

### InputDecoration（输入框装饰）

```dart
TextField(
    decoration: InputDecoration(
        // 标签文本（位于输入框上方或内部）
        labelText: '用户名',
        labelStyle: TextStyle(color: Colors.blue),
        
        // 提示文本（输入框为空时显示）
        hintText: '请输入用户名',
        hintStyle: TextStyle(color: Colors.grey),
        
        // 辅助文本（位于输入框下方）
        helperText: '请输入6-12位字符',
        
        // 错误文本
        errorText: '用户名不能为空',
        
        // 前缀图标
        prefixIcon: Icon(Icons.person),
        // 前缀文本
        prefix: Text('用户:'),
        
        // 后缀图标
        suffixIcon: Icon(Icons.visibility),
        // 后缀文本
        suffix: Text('.com'),
        
        // 边框样式
        border: OutlineInputBorder(),  // 外边框
        // border: UnderlineInputBorder(),  // 下划线边框
        
        // 启用状态的边框
        enabledBorder: OutlineInputBorder(
            borderSide: BorderSide(color: Colors.blue),
        ),
        
        // 获取焦点时的边框
        focusedBorder: OutlineInputBorder(
            borderSide: BorderSide(color: Colors.green),
        ),
        
        // 填充颜色
        fillColor: Colors.grey[200],
        filled: true,
        
        // 内容内边距
        contentPadding: EdgeInsets.symmetric(
            horizontal: 16.0,
            vertical: 8.0
        ),
    ),
)
```



## Flutter内置控制类

```dart
// 文本编辑控制器
TextEditingController

// 滚动控制器
ScrollController

// 页面控制器
PageController

// 动画控制器
AnimationController

// 表单控制器
FormController

// Tab控制器
TabController
```

### TextEditingController（文本编辑控制器）

```dart
// 创建控制器
final TextEditingController _controller = TextEditingController();

// 在 TextField 中使用
TextField(
    controller: _controller,
    
    // 初始值
    controller: TextEditingController(text: '初始值'),
)

// 控制器的常用操作
_controller.text = '设置文本';  // 设置文本
print(_controller.text);      // 获取文本
_controller.clear();          // 清空文本

// 监听文本变化
_controller.addListener(() {
    print('当前文本：${_controller.text}');
});

// 设置光标位置
_controller.selection = TextSelection.fromPosition(
    TextPosition(offset: _controller.text.length)
);

// 在 dispose 中释放
@override
void dispose() {
    _controller.dispose();
    super.dispose();
}
```

## Flutter生命周期

Flutter 的生命周期主要分为应用生命周期和页面（Widget）生命周期。

### 应用生命周期 (AppLifecycleState)

```dart
class MyApp extends StatefulWidget {
  @override
  _MyAppState createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> with WidgetsBindingObserver {
  @override
  void initState() {
    super.initState();
    // 注册观察者
    WidgetsBinding.instance.addObserver(this);
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    super.didChangeAppLifecycleState(state);
    
    switch (state) {
      case AppLifecycleState.resumed:
        // 应用程序可见且可响应用户操作
        print('应用进入前台');
        break;
        
      case AppLifecycleState.inactive:
        // 应用程序在前台但不响应用户操作
        // 比如来电话、切换应用等
        print('应用不活跃');
        break;
        
      case AppLifecycleState.paused:
        // 应用程序不可见（后台）
        print('应用进入后台');
        break;
        
      case AppLifecycleState.detached:
        // 应用程序被挂起（iOS上的挂起状态）
        print('应用被挂起');
        break;
    }
  }

  @override
  void dispose() {
    // 移除观察者
    WidgetsBinding.instance.removeObserver(this);
    super.dispose();
  }
}
```

### 页面生命周期（Widget Lifecycle）

```dart
class LifecycleWidget extends StatefulWidget {
  const LifecycleWidget({Key? key}) : super(key: key);

  @override
  State<LifecycleWidget> createState() {
    print('1. createState被调用');
    return _LifecycleWidgetState();
  }
}

class _LifecycleWidgetState extends State<LifecycleWidget> {
  @override
  void initState() {
    super.initState();
    print('2. initState被调用');
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    print('3. didChangeDependencies被调用');
  }

  @override
  Widget build(BuildContext context) {
    print('4. build被调用');
    return Container();
  }
}
```



```dart
class MyPage extends StatefulWidget {
  @override
  _MyPageState createState() => _MyPageState();
}

class _MyPageState extends State<MyPage> {
  @override
  void initState() {
    super.initState();
    print('1. initState：Widget初始化');
    // 在Widget第一次插入树中调用
    // 常用于：初始化数据、订阅流
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    print('2. didChangeDependencies：依赖项改变');
    // 在initState之后调用
    // 当InheritedWidget改变时会被调用
  }

  @override
  Widget build(BuildContext context) {
    print('3. build：构建Widget');
    // 构建Widget时调用
    // 每次setState后都会调用
    return Container();
  }

  @override
  void didUpdateWidget(MyPage oldWidget) {
    super.didUpdateWidget(oldWidget);
    print('4. didUpdateWidget：Widget更新');
    // 当Widget配置更新时调用
  }

  @override
  void deactivate() {
    super.deactivate();
    print('5. deactivate：Widget停用');
    // 当Widget从树中被移除时调用
  }

  @override
  void dispose() {
    print('6. dispose：Widget销毁');
    // 当Widget从树中永久移除时调用
    super.dispose();
  }
}
```

### 生命周期执行顺序

应用生命周期：

```
resumed (前台可见) 
  ↓↑
inactive (不活跃) 
  ↓↑
paused (后台) 
  ↓↑
detached (挂起)
```

页面生命周期：

```
createState
   ↓
initState Widget初始化
   ↓
didChangeDependencies 依赖项改变
   ↓
build 构建Widget
   ↓
didUpdateWidget (如果Widget更新)
   ↓
deactivate (如果Widget停用)
   ↓
dispose (如果Widget销毁)
```

### 实际应用示例

```dart
class VideoPlayerPage extends StatefulWidget {
  @override
  _VideoPlayerPageState createState() => _VideoPlayerPageState();
}

class _VideoPlayerPageState extends State<VideoPlayerPage> 
    with WidgetsBindingObserver {
  late VideoPlayerController _controller;

  @override
  void initState() {
    super.initState();
    // 1. 初始化视频控制器
    _controller = VideoPlayerController.network('视频URL');
    // 2. 注册应用生命周期观察者
    WidgetsBinding.instance.addObserver(this);
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    // 处理应用程序生命周期变化
    switch (state) {
      case AppLifecycleState.resumed:
        // 恢复播放
        _controller.play();
        break;
      case AppLifecycleState.paused:
        // 暂停播放
        _controller.pause();
        break;
      default:
        break;
    }
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    // 处理依赖变化，如主题、语言等
  }

  @override
  void dispose() {
    // 1. 释放视频控制器
    _controller.dispose();
    // 2. 移除观察者
    WidgetsBinding.instance.removeObserver(this);
    super.dispose();
  }
}
```

### 生命周期方法的使用场景

```dart
// 初始化阶段（initState）：
- 初始化数据
- 订阅事件流
- 初始化控制器
- 注册监听器

// 依赖变化（didChangeDependencies）：
- 处理主题变化
- 处理语言变化
- 处理数据依赖更新

// 构建阶段（build）：
- 构建UI界面
- 响应数据变化
- 更新视图

// 更新阶段（didUpdateWidget）：
- 处理配置更新
- 重新初始化数据
- 更新状态

// 销毁阶段（dispose）：
- 释放资源
- 取消订阅
- 关闭控制器
- 移除监听器
```

### 最佳实践

#### 资源管理

```dart
// 正确的资源管理
@override
void initState() {
  super.initState();
  _controller = VideoPlayerController.network('url');
  _subscription = stream.listen((_) {});
}

@override
void dispose() {
  _controller.dispose();
  _subscription.cancel();
  super.dispose();
}
```

#### 状态管理

```dart
@override
void didChangeAppLifecycleState(AppLifecycleState state) {
  if (state == AppLifecycleState.paused) {
    // 保存状态
    _saveState();
  } else if (state == AppLifecycleState.resumed) {
    // 恢复状态
    _restoreState();
  }
}
```

### createState()

createState() 是 StatefulWidget 的一个必须实现的方法，它是创建 Widget 状态的起点。

#### 基本用法

```dart
class MyWidget extends StatefulWidget {
  // 构造函数
  const MyWidget({Key? key}) : super(key: key);

  // 创建状态
  @override
  State<MyWidget> createState() => _MyWidgetState();
}

// Widget的状态类
class _MyWidgetState extends State<MyWidget> {
  @override
  Widget build(BuildContext context) {
    return Container();
  }
}
```

#### 带参数的例子

```dart
class CounterWidget extends StatefulWidget {
  final int initialCount; // Widget的参数

  const CounterWidget({
    Key? key, 
    required this.initialCount
  }) : super(key: key);

  @override
  State<CounterWidget> createState() => _CounterWidgetState();
}

class _CounterWidgetState extends State<CounterWidget> {
  late int _count; // 状态变量

  @override
  void initState() {
    super.initState();
    // 通过widget属性访问StatefulWidget的参数
    _count = widget.initialCount;
  }

  @override
  Widget build(BuildContext context) {
    return Text('Count: $_count');
  }
}
```

#### 复杂示例

```dart
// 带有配置的Widget
class ChatRoom extends StatefulWidget {
  final String roomId;
  final String userName;
  final bool isPrivate;

  const ChatRoom({
    Key? key,
    required this.roomId,
    required this.userName,
    this.isPrivate = false,
  }) : super(key: key);

  @override
  State<ChatRoom> createState() => _ChatRoomState();
}

class _ChatRoomState extends State<ChatRoom> {
  List<String> _messages = [];
  late StreamSubscription _subscription;

  @override
  void initState() {
    super.initState();
    // 使用widget.属性访问参数
    _subscription = ChatService.listenToRoom(
      roomId: widget.roomId,
      isPrivate: widget.isPrivate,
    ).listen(_handleNewMessage);
  }

  void _handleNewMessage(String message) {
    setState(() {
      _messages.add(message);
    });
  }

  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      itemCount: _messages.length,
      itemBuilder: (context, index) {
        return ListTile(
          title: Text(_messages[index]),
          subtitle: Text(widget.userName),
        );
      },
    );
  }

  @override
  void dispose() {
    _subscription.cancel();
    super.dispose();
  }
}
```

重要说明：

1. `createState()` 是创建 StatefulWidget 状态的入口点

2. 它在 Widget 第一次被插入到 Widget 树中时调用

3. 它必须返回一个 State 类的实例

4. 通常返回一个私有的 State 类（以下划线开头）

5. 它是连接 Widget 和 State 的桥梁

使用建议：

1. 保持 createState 方法简单

2. 不要在 createState 中进行复杂的初始化

3. 复杂的初始化工作应该放在 initState 中

4. 使用私有的 State 类来封装内部实现

#### 用法区别

代码一：

```dart
class MyPage extends StatefulWidget {
  @override
  _MyPageState createState() => _MyPageState();
}
```

代码二：

```dart
class MyWidget extends StatefulWidget {
  // 构造函数
  const MyWidget({Key? key}) : super(key: key);

  // 创建状态
  @override
  State<MyWidget> createState() => _MyWidgetState();
}
```

这两种写法本质上是相同的，只是语法形式不同。

1. **箭头语法（=>）写法**

```dart
class MyWidget extends StatefulWidget {
  const MyWidget({Key? key}) : super(key: key);

  @override
  State<MyWidget> createState() => _MyWidgetState();  // 箭头语法
}
```

2. **常规写法**

   ```dart
   class MyPage extends StatefulWidget {
     @override
     _MyPageState createState() {  // 常规语法
       return _MyPageState();
     }
   }
   ```

   这两种写法是完全等价的，区别在于：

   - **语法形式**：

     - 箭头语法 => 是一种简写形式

     - 适用于单行返回值的函数

     - 更简洁，代码更少

	- **泛型写法**
	
	  ```dart
	  // 箭头语法
	  State<MyWidget> createState() => _MyWidgetState();
	  
	  // 常规写法
	  _MyPageState createState() {
	    return _MyPageState();
	  }
	  ```
	
	- **完整对比**
	
	  ```dart
	  // 方式1：箭头语法 + 明确的泛型
	  class MyWidget extends StatefulWidget {
	    @override
	    State<MyWidget> createState() => _MyWidgetState();
	  }
	  
	  // 方式2：箭头语法 + 推断的泛型
	  class MyWidget extends StatefulWidget {
	    @override
	    _MyWidgetState createState() => _MyWidgetState();
	  }
	  
	  // 方式3：常规语法 + 明确的泛型
	  class MyWidget extends StatefulWidget {
	    @override
	    State<MyWidget> createState() {
	      return _MyWidgetState();
	    }
	  }
	  
	  // 方式4：常规语法 + 推断的泛型
	  class MyWidget extends StatefulWidget {
	    @override
	    _MyWidgetState createState() {
	      return _MyWidgetState();
	    }
	  }
	  ```
	
	  这些写法都是正确的，选择哪种主要看：
	
	  1. 个人或团队的代码风格偏好
	
	  2. 是否需要明确的泛型声明
	
	  3. 是否追求代码简洁性
	
	  推荐使用箭头语法（第一种写法），因为：
	
	  - 更简洁
	
	  - 更现代
	
	  - 更符合 Flutter 的代码风格指南
	
	  - 明确的泛型声明使代码更清晰

## 自定义组件的属性传参

代码案例：

```dart
class CounterWidget extends StatefulWidget {
  final int initialCount; // Widget的参数

  const CounterWidget({
    Key? key, 
    required this.initialCount
  }) : super(key: key);

  @override
  State<CounterWidget> createState() => _CounterWidgetState();
}

class _CounterWidgetState extends State<CounterWidget> {
  late int _count; // 状态变量

  @override
  void initState() {
    super.initState();
    // 通过widget属性访问StatefulWidget的参数
    _count = widget.initialCount;
  }

  @override
  Widget build(BuildContext context) {
    return Text('Count: $_count');
  }
}
```

### 构造函数的参数说明

```dart
const CounterWidget({
    Key? key,            // 可选参数，可以为空
    required this.initialCount  // 必需参数，不能为空
}) : super(key: key);    // 调用父类构造函数
```

### 参数解释

- `Key? key`：

  - `Key` 是 Flutter 中用于标识 Widget 的唯一标识符

  - ? 表示这是一个可空参数

  - 通常用于 Widget 的重建和更新机制

  - 是可选参数，不必须传入

- `required this.initialCount`：

  - `required` 表示这是一个必须传入的参数

  - this.initialCount 会直接初始化类中的 initialCount 属性

  - 在使用 Widget 时必须提供这个值

### 使用示例

```DART
// 创建 Widget 实例
CounterWidget(
  key: UniqueKey(),          // 可选的 key
  initialCount: 10,          // 必须的初始计数值
)
```

### 完整的使用场景

```DART
class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        body: CounterWidget(
          key: UniqueKey(),     // 可选
          initialCount: 42,      // 必需
        ),
      ),
    );
  }
}

class CounterWidget extends StatefulWidget {
  final int initialCount;

  const CounterWidget({
    Key? key,
    required this.initialCount
  }) : super(key: key);

  @override
  State<CounterWidget> createState() => _CounterWidgetState();
}

class _CounterWidgetState extends State<CounterWidget> {
  late int _count;

  @override
  void initState() {
    super.initState();
    // 在这里使用传入的 initialCount
    _count = widget.initialCount;  // 通过 widget 访问
  }

  void _incrementCounter() {
    setState(() {
      _count++;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text('Count: $_count'),
        ElevatedButton(
          onPressed: _incrementCounter,
          child: Text('Increment'),
        ),
      ],
    );
  }
}
```

### 为什么需要这些参数

- **Key 的作用：**

```dart
// 使用 Key 的例子
ListView(
  children: [
    CounterWidget(
      key: ValueKey('counter1'),  // 帮助 Flutter 识别 Widget
      initialCount: 0,
    ),
    CounterWidget(
      key: ValueKey('counter2'),  // 不同的 Key 标识不同的 Widget
      initialCount: 10,
    ),
  ],
)
```

- **initialCount 的作用：**

```dart
// 在状态类中使用初始值
class _CounterWidgetState extends State<CounterWidget> {
  late int _count;

  @override
  void initState() {
    super.initState();
    _count = widget.initialCount;  // 使用传入的初始值
  }
}
```

### 参数传递的流程

```dart
// 1. 创建 Widget 时传入参数
CounterWidget(
  initialCount: 42,
)

// 2. Widget 类存储参数
class CounterWidget extends StatefulWidget {
  final int initialCount;  // 存储传入的值

  const CounterWidget({required this.initialCount});
}

// 3. State 类通过 widget 属性访问参数
class _CounterWidgetState extends State<CounterWidget> {
  late int _count;

  @override
  void initState() {
    super.initState();
    _count = widget.initialCount;  // 使用参数
  }
}
```

## Flutter请求网络接口在哪个阶段

在 Flutter 中，通常在 initState 生命周期方法中进行网络请求。这相当于 Vue 中的 mounted。让我详细解释：

### 基本用法

```dart
class MyWidget extends StatefulWidget {
  @override
  State<MyWidget> createState() => _MyWidgetState();
}

class _MyWidgetState extends State<MyWidget> {
  List<dynamic> _data = [];

  @override
  void initState() {
    super.initState();
    // 在这里请求数据
    _fetchData();
  }

  Future<void> _fetchData() async {
    try {
      final response = await http.get(Uri.parse('https://api.example.com/data'));
      if (response.statusCode == 200) {
        setState(() {
          _data = json.decode(response.body);
        });
      }
    } catch (e) {
      print('Error: $e');
    }
  }

  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      itemCount: _data.length,
      itemBuilder: (context, index) {
        return ListTile(
          title: Text(_data[index]['title']),
        );
      },
    );
  }
}
```

### 带加载状态的示例

```dart
class _MyWidgetState extends State<MyWidget> {
  bool _isLoading = true;
  List<dynamic> _data = [];
  String? _error;

  @override
  void initState() {
    super.initState();
    _fetchData();
  }

  Future<void> _fetchData() async {
    try {
      final response = await http.get(Uri.parse('https://api.example.com/data'));
      
      if (mounted) {  // 确保 Widget 还在树中
        setState(() {
          _isLoading = false;
          if (response.statusCode == 200) {
            _data = json.decode(response.body);
          } else {
            _error = '请求失败: ${response.statusCode}';
          }
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _isLoading = false;
          _error = e.toString();
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoading) {
      return Center(child: CircularProgressIndicator());
    }

    if (_error != null) {
      return Center(child: Text(_error!));
    }

    return ListView.builder(
      itemCount: _data.length,
      itemBuilder: (context, index) => ListTile(
        title: Text(_data[index]['title']),
      ),
    );
  }
}
```

### 使用 FutureBuilder 的方式

```dart
class _MyWidgetState extends State<MyWidget> {
  late Future<List<dynamic>> _dataFuture;

  @override
  void initState() {
    super.initState();
    _dataFuture = _fetchData();
  }

  Future<List<dynamic>> _fetchData() async {
    final response = await http.get(Uri.parse('https://api.example.com/data'));
    if (response.statusCode == 200) {
      return json.decode(response.body);
    }
    throw Exception('加载失败');
  }

  @override
  Widget build(BuildContext context) {
    return FutureBuilder<List<dynamic>>(
      future: _dataFuture,
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return Center(child: CircularProgressIndicator());
        }
        
        if (snapshot.hasError) {
          return Center(child: Text('错误: ${snapshot.error}'));
        }

        if (!snapshot.hasData) {
          return Center(child: Text('无数据'));
        }

        return ListView.builder(
          itemCount: snapshot.data!.length,
          itemBuilder: (context, index) {
            return ListTile(
              title: Text(snapshot.data![index]['title']),
            );
          },
        );
      },
    );
  }
}
```

### 下拉刷新示例

```dart
class _MyWidgetState extends State<MyWidget> {
  List<dynamic> _data = [];
  final RefreshController _refreshController = RefreshController();

  @override
  void initState() {
    super.initState();
    _fetchData();
  }

  Future<void> _fetchData() async {
    try {
      final response = await http.get(Uri.parse('https://api.example.com/data'));
      
      if (mounted) {
        setState(() {
          if (response.statusCode == 200) {
            _data = json.decode(response.body);
          }
        });
      }
    } finally {
      _refreshController.refreshCompleted();
    }
  }

  @override
  Widget build(BuildContext context) {
    return RefreshIndicator(
      onRefresh: _fetchData,
      child: ListView.builder(
        itemCount: _data.length,
        itemBuilder: (context, index) {
          return ListTile(
            title: Text(_data[index]['title']),
          );
        },
      ),
    );
  }

  @override
  void dispose() {
    _refreshController.dispose();
    super.dispose();
  }
}
```

### 最佳实践

```dart
class _MyWidgetState extends State<MyWidget> {
  late final ApiService _apiService;
  bool _isLoading = true;
  List<dynamic> _data = [];
  String? _error;

  @override
  void initState() {
    super.initState();
    _apiService = ApiService();
    _loadInitialData();
  }

  Future<void> _loadInitialData() async {
    try {
      final data = await _apiService.fetchData();
      if (mounted) {
        setState(() {
          _data = data;
          _isLoading = false;
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _error = e.toString();
          _isLoading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: _buildBody(),
    );
  }

  Widget _buildBody() {
    if (_isLoading) {
      return const Center(child: CircularProgressIndicator());
    }

    if (_error != null) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(_error!),
            ElevatedButton(
              onPressed: _loadInitialData,
              child: const Text('重试'),
            ),
          ],
        ),
      );
    }

    return RefreshIndicator(
      onRefresh: _loadInitialData,
      child: ListView.builder(
        itemCount: _data.length,
        itemBuilder: (context, index) {
          return ListTile(
            title: Text(_data[index]['title']),
          );
        },
      ),
    );
  }

  @override
  void dispose() {
    _apiService.dispose();
    super.dispose();
  }
}
```

重要说明：

1. 在 initState 中发起网络请求

2. 使用 mounted 检查确保 Widget 还在树中

3. 使用 setState 更新 UI

4. 处理加载状态和错误情况

5. 实现下拉刷新功能

6. 在 dispose 中清理资源

使用建议：

1. 网络请求放在 initState 中

​	2. 使用 FutureBuilder 处理异步数据

3. 实现错误处理和重试机制

4. 添加加载状态指示

5. 考虑添加刷新功能

6. 注意内存泄漏问题

## Flutter中的数据类型

### 基本数据类型

```dart
// 数字类型
int number = 42;            // 整数
double price = 42.42;       // 浮点数
num value = 42;            // 可以是整数或浮点数

// 字符串
String name = "张三";       // 字符串类型

// 布尔值
bool isActive = true;      // 布尔类型

// 动态类型
dynamic anything = "hello"; // 可以是任何类型
var something = 42;        // 类型推断
Object someObject = 42;    // 所有类型的基类
```

### 集合类型

```dart
// 列表 List
List<String> names = ["张三", "李四"];
List<int> numbers = [1, 2, 3];

// 集合 Set（不重复的集合）
Set<int> uniqueNumbers = {1, 2, 3};

// 映射 Map（键值对）
Map<String, dynamic> person = {
  "name": "张三",
  "age": 25,
  "isStudent": true
};
```

### 空安全类型（Null Safety）

```dart
// 可空类型（可以为 null）
String? nullableName;     // 可以为 null
int? nullableAge;        // 可以为 null

// 非空类型（不能为 null）
String nonNullName = "张三";  // 不能为 null
late String lastName;    // 延迟初始化，但不能为 null
```

### 特殊类型

```dart
// Future（异步操作）
Future<String> getData() async {
  return "数据";
}

// Stream（数据流）
Stream<int> countStream() async* {
  for (int i = 0; i < 10; i++) {
    yield i;
  }
}

// void（无返回值）
void doSomething() {
  print("执行操作");
}
```

### 自定义类型

```dart
// 类
class Person {
  String name;
  int age;
  
  Person({
    required this.name,
    required this.age,
  });
}

// 枚举
enum Status {
  active,
  inactive,
  pending
}

// 混入（Mixin）
mixin Logger {
  void log(String message) {
    print(message);
  }
}
```

### 类型使用示例

```dart
class UserProfile extends StatefulWidget {
  @override
  State<UserProfile> createState() => _UserProfileState();
}

class _UserProfileState extends State<UserProfile> {
  // 基本类型
  String _name = "张三";
  int _age = 25;
  double _height = 175.5;
  bool _isStudent = true;
  
  // 集合类型
  List<String> _hobbies = ["读书", "运动"];
  Set<String> _skills = {"Flutter", "Dart"};
  Map<String, dynamic> _additional = {
    "city": "北京",
    "phone": 12345678901
  };
  
  // 可空类型
  String? _nickname;
  DateTime? _birthDate;
  
  // Future
  late Future<List<String>> _dataFuture;
  
  @override
  void initState() {
    super.initState();
    _dataFuture = _fetchData();
  }
  
  Future<List<String>> _fetchData() async {
    // 异步获取数据
    return ["数据1", "数据2"];
  }
  
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text(_name),
        Text(_age.toString()),
        if (_nickname != null)
          Text(_nickname!),
        ..._hobbies.map((hobby) => Text(hobby)),
        FutureBuilder<List<String>>(
          future: _dataFuture,
          builder: (context, snapshot) {
            if (snapshot.hasData) {
              return Column(
                children: snapshot.data!
                    .map((item) => Text(item))
                    .toList(),
              );
            }
            return CircularProgressIndicator();
          },
        ),
      ],
    );
  }
}
```

### 类型转换

```dart
// 字符串转换
String numberStr = "42";
int parsedInt = int.parse(numberStr);    // 字符串转整数
double parsedDouble = double.parse("42.42"); // 字符串转浮点数

// 数字转换
int number = 42;
String numberString = number.toString();  // 数字转字符串
double doubleNumber = number.toDouble();  // 整数转浮点数

// 类型判断
var value = 42;
if (value is int) {
  print("是整数");
}
```

### 泛型类型

```dart
// 泛型类
class Container<T> {
  T value;
  
  Container(this.value);
}

// 泛型方法
T getFirst<T>(List<T> list) {
  return list[0];
}

// 使用泛型
Container<int> numberContainer = Container(42);
Container<String> stringContainer = Container("Hello");
```

重要说明：

1. Dart 是强类型语言
2. 支持类型推断
3. 有完整的空安全支持
4. 支持泛型编程
5. 所有类型都是对象
6. 支持异步编程类型

使用建议：

1. 尽量使用明确的类型声明
2. 合理使用空安全特性
3. 避免过度使用 dynamic
4. 适当使用类型推断（var）
5. 使用泛型增加代码复用性

## FutureBuilder

> FutureBuilder 是 Flutter 中用于处理异步数据的 Widget，主要用于展示异步操作（如网络请求、数据库操作等）的结果。

### 基本用法

```dart
FutureBuilder<String>(
  future: fetchData(),  // 异步操作
  builder: (BuildContext context, AsyncSnapshot<String> snapshot) {
    if (snapshot.connectionState == ConnectionState.waiting) {
      return CircularProgressIndicator();  // 加载中
    }
    
    if (snapshot.hasError) {
      return Text('错误: ${snapshot.error}');  // 发生错误
    }
    
    return Text('数据: ${snapshot.data}');  // 显示数据
  },
)
```

### 完整示例

```dart
class UserProfilePage extends StatefulWidget {
  @override
  State<UserProfilePage> createState() => _UserProfilePageState();
}

class _UserProfilePageState extends State<UserProfilePage> {
  late Future<Map<String, dynamic>> _userFuture;

  @override
  void initState() {
    super.initState();
    _userFuture = _fetchUserData();
  }

  Future<Map<String, dynamic>> _fetchUserData() async {
    final response = await http.get(Uri.parse('https://api.example.com/user'));
    return json.decode(response.body);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('用户信息')),
      body: FutureBuilder<Map<String, dynamic>>(
        future: _userFuture,
        builder: (context, snapshot) {
          // 1. 处理加载状态
          if (snapshot.connectionState == ConnectionState.waiting) {
            return Center(child: CircularProgressIndicator());
          }
          
          // 2. 处理错误状态
          if (snapshot.hasError) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Text('加载失败: ${snapshot.error}'),
                  ElevatedButton(
                    onPressed: () {
                      setState(() {
                        _userFuture = _fetchUserData();  // 重试
                      });
                    },
                    child: Text('重试'),
                  ),
                ],
              ),
            );
          }
          
          // 3. 处理数据
          final userData = snapshot.data!;
          return ListView(
            padding: EdgeInsets.all(16),
            children: [
              ListTile(
                title: Text('用户名'),
                subtitle: Text(userData['username']),
              ),
              ListTile(
                title: Text('邮箱'),
                subtitle: Text(userData['email']),
              ),
            ],
          );
        },
      ),
    );
  }
}
```

### 常见使用场景

#### 网络请求

```dart
FutureBuilder<List<Product>>(
  future: fetchProducts(),
  builder: (context, snapshot) {
    if (snapshot.connectionState == ConnectionState.waiting) {
      return Center(child: CircularProgressIndicator());
    }
    
    if (snapshot.hasError) {
      return Center(child: Text('加载失败'));
    }
    
    return ListView.builder(
      itemCount: snapshot.data!.length,
      itemBuilder: (context, index) {
        final product = snapshot.data![index];
        return ListTile(
          title: Text(product.name),
          subtitle: Text('¥${product.price}'),
        );
      },
    );
  },
)
```

#### 图片加载

```dart
FutureBuilder<void>(
  future: precacheImage(NetworkImage(imageUrl), context),
  builder: (context, snapshot) {
    if (snapshot.connectionState == ConnectionState.waiting) {
      return Placeholder();  // 占位图
    }
    
    return Image.network(imageUrl);
  },
)
```

#### 数据库操作

```dart
FutureBuilder<List<Note>>(
  future: DatabaseHelper.instance.getNotes(),
  builder: (context, snapshot) {
    if (!snapshot.hasData) {
      return Center(child: CircularProgressIndicator());
    }
    
    return ListView.builder(
      itemCount: snapshot.data!.length,
      itemBuilder: (context, index) {
        return NoteCard(note: snapshot.data![index]);
      },
    );
  },
)
```

### 高级用法

#### 组合多个Future

```dart
FutureBuilder<List<dynamic>>(
  future: Future.wait([
    fetchUserProfile(),
    fetchUserPosts(),
    fetchUserSettings(),
  ]),
  builder: (context, snapshot) {
    if (snapshot.connectionState == ConnectionState.waiting) {
      return LoadingIndicator();
    }
    
    if (snapshot.hasData) {
      final profile = snapshot.data![0];
      final posts = snapshot.data![1];
      final settings = snapshot.data![2];
      
      return UserProfileView(
        profile: profile,
        posts: posts,
        settings: settings,
      );
    }
    
    return ErrorView(error: snapshot.error);
  },
)
```

### 最佳实践

```dart
class DataPage extends StatefulWidget {
  @override
  _DataPageState createState() => _DataPageState();
}

class _DataPageState extends State<DataPage> {
  late Future<List<Item>> _dataFuture;
  
  @override
  void initState() {
    super.initState();
    _dataFuture = _loadData();
  }
  
  Future<List<Item>> _loadData() async {
    try {
      final response = await http.get(Uri.parse('api/items'));
      final List<dynamic> jsonData = json.decode(response.body);
      return jsonData.map((json) => Item.fromJson(json)).toList();
    } catch (e) {
      throw '加载失败: $e';
    }
  }

  Widget _buildError(String message) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Text(message),
          ElevatedButton(
            onPressed: () {
              setState(() {
                _dataFuture = _loadData();
              });
            },
            child: Text('重试'),
          ),
        ],
      ),
    );
  }

  Widget _buildLoading() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          CircularProgressIndicator(),
          SizedBox(height: 16),
          Text('加载中...'),
        ],
      ),
    );
  }

  Widget _buildContent(List<Item> items) {
    if (items.isEmpty) {
      return Center(child: Text('暂无数据'));
    }

    return RefreshIndicator(
      onRefresh: () async {
        setState(() {
          _dataFuture = _loadData();
        });
      },
      child: ListView.builder(
        itemCount: items.length,
        itemBuilder: (context, index) {
          final item = items[index];
          return ListTile(
            title: Text(item.title),
            subtitle: Text(item.description),
          );
        },
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('数据列表')),
      body: FutureBuilder<List<Item>>(
        future: _dataFuture,
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return _buildLoading();
          }

          if (snapshot.hasError) {
            return _buildError(snapshot.error.toString());
          }

          return _buildContent(snapshot.data!);
        },
      ),
    );
  }
}
```

使用建议：

1. 在 initState 中初始化 Future
2. 处理所有可能的状态（加载、错误、空数据）
3. 提供重试机制
4. 添加加载指示器
5. 考虑添加下拉刷新功能
6. 错误处理要友好
7. 避免在 build 方法中创建新的 Future

## 状态管理方案

### Provider/ChangeNotifierProvider

```dart
// 1. 创建数据模型
class CounterModel extends ChangeNotifier {
  int _count = 0;
  int get count => _count;

  void increment() {
    _count++;
    notifyListeners();  // 通知监听者更新
  }
}

// 2. 提供数据
void main() {
  runApp(
    ChangeNotifierProvider(
      create: (context) => CounterModel(),
      child: MyApp(),
    ),
  );
}

// 3. 使用数据
class CounterWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // 方式1：只读取数据
    final count = context.watch<CounterModel>().count;
    
    // 方式2：读取数据和方法
    final counter = Provider.of<CounterModel>(context);
    
    return Column(
      children: [
        Text('Count: $count'),
        ElevatedButton(
          onPressed: () => counter.increment(),
          child: Text('增加'),
        ),
      ],
    );
  }
}
```

完整案例:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

// 1. 创建数据模型
class CounterModel extends ChangeNotifier {
  int _count = 0;
  int get count => _count;

  void increment() {
    _count++;
    notifyListeners();  // 通知监听者更新
  }
}

// 2. 创建应用入口
void main() {
  runApp(
    ChangeNotifierProvider(
      create: (context) => CounterModel(),
      child: MyApp(),
    ),
  );
}

// 3. 创建 MyApp
class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Provider Demo',
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: HomePage(),  // 主页
    );
  }
}

// 4. 创建主页
class HomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Provider Demo'),
      ),
      body: Center(
        child: CounterWidget(),  // 使用 CounterWidget
      ),
    );
  }
}

// 5. 创建计数器组件
class CounterWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        // 使用 Consumer 监听数据变化
        Consumer<CounterModel>(
          builder: (context, counter, child) {
            return Text(
              '当前计数: ${counter.count}',
              style: TextStyle(fontSize: 24),
            );
          },
        ),
        
        SizedBox(height: 20),
        
        // 使用 context.read 获取方法
        ElevatedButton(
          onPressed: () {
            context.read<CounterModel>().increment();
          },
          child: Text('增加'),
        ),
        
        // 另一种方式：使用 Provider.of
        ElevatedButton(
          onPressed: () {
            Provider.of<CounterModel>(context, listen: false).increment();
          },
          child: Text('增加（另一种方式）'),
        ),
      ],
    );
  }
}
```

这个完整示例包含：

1. 数据模型 (CounterModel)：

   - 继承自 `ChangeNotifier`

   - 包含状态和修改状态的方法

2. 入口点 (main)：

   - 使用 `ChangeNotifierProvider` 提供数据模型

   - 包装整个应用

3. 应用根组件 (`MyApp`)：

   - 配置应用的基本设置

   - 设置主题和首页

4. 主页 (`HomePage`)：

   - 使用 `Scaffold` 创建基本页面结构

   - 包含 `CounterWidget`

5. 计数器组件 (`CounterWidget`)：

   - 显示和修改计数器的值

   - 展示不同的状态访问方式

你还可以添加更多功能:

```DART
// 6. 添加设置页面
class SettingsPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('设置'),
      ),
      body: Center(
        // 使用 Selector 只监听特定属性
        child: Selector<CounterModel, int>(
          selector: (_, counter) => counter.count,
          builder: (context, count, child) {
            return Text('在设置页面中的计数: $count');
          },
        ),
      ),
    );
  }
}

// 7. 扩展 HomePage，添加导航
class HomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Provider Demo'),
        actions: [
          IconButton(
            icon: Icon(Icons.settings),
            onPressed: () {
              Navigator.push(
                context,
                MaterialPageRoute(builder: (_) => SettingsPage()),
              );
            },
          ),
        ],
      ),
      body: Center(
        child: CounterWidget(),
      ),
    );
  }
}

// 8. 扩展 CounterModel，添加更多功能
class CounterModel extends ChangeNotifier {
  int _count = 0;
  bool _isEven = true;

  int get count => _count;
  bool get isEven => _isEven;

  void increment() {
    _count++;
    _isEven = _count % 2 == 0;
    notifyListeners();
  }

  void reset() {
    _count = 0;
    _isEven = true;
    notifyListeners();
  }
}

// 9. 扩展 CounterWidget，显示更多信息
class CounterWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Consumer<CounterModel>(
          builder: (context, counter, child) {
            return Column(
              children: [
                Text(
                  '当前计数: ${counter.count}',
                  style: TextStyle(fontSize: 24),
                ),
                Text(
                  '是否为偶数: ${counter.isEven}',
                  style: TextStyle(fontSize: 16),
                ),
              ],
            );
          },
        ),
        
        SizedBox(height: 20),
        
        Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            ElevatedButton(
              onPressed: () {
                context.read<CounterModel>().increment();
              },
              child: Text('增加'),
            ),
            SizedBox(width: 10),
            ElevatedButton(
              onPressed: () {
                context.read<CounterModel>().reset();
              },
              child: Text('重置'),
            ),
          ],
        ),
      ],
    );
  }
}
```

这样就是一个完整的、可运行的示例了。主要包含：

1. 完整的应用结构
2. 状态管理的实现
3. 页面导航
4. 不同的状态访问方式
5. 多个组件之间的状态共享

使用时需要：

1. 在 pubspec.yaml 中添加 provider 依赖
2. 导入必要的包
3. 确保组件树结构正确
4. 正确使用状态管理的不同方法

### MultiProvider（多个提供者）

```dart
void main() {
  runApp(
    MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (_) => UserModel()),
        ChangeNotifierProvider(create: (_) => CartModel()),
        ChangeNotifierProvider(create: (_) => SettingsModel()),
      ],
      child: MyApp(),
    ),
  );
}
```

### Consumer（消费者组件）

Consumer 的 builder 参数接收三个参数：(BuildContext context, T value, Widget? child)。

#### 基本参数结构

```dart
Consumer<CounterModel>(
  builder: (
    BuildContext context,    // 构建上下文
    CounterModel counter,    // 监听的数据模型
    Widget? child,          // 可选的子组件
  ) {
    return Text('Count: ${counter.count}');
  },
)
```

```dart
Consumer<CounterModel>(
  // builder 是 Consumer 的一个必需参数
  builder: (context, value, child) {
    // 这三个参数是由 Consumer 组件自动传入的
    return Text('Count: ${value.count}');
  },
  // child 参数是可选的，如果提供了会被传入 builder 的第三个参数
  child: const Text('Static Content'),
)
 
```

#### 参数的来源

```dart
// 1. context: 由 Flutter 框架自动传入
// 2. value: 由 Provider 管理的数据模型实例
// 3. child: 来自 Consumer 的 child 参数

class MyWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return ChangeNotifierProvider(
      // 创建数据模型实例
      create: (_) => CounterModel(),
      child: Scaffold(
        body: Consumer<CounterModel>(
          // builder 中的参数自动获取：
          // - context 由 Flutter 框架提供
          // - value 由 Provider 提供（就是上面 create 创建的 CounterModel 实例）
          // - child 来自下面的 child 参数
          builder: (context, value, child) {
            return Column(
              children: [
                Text('Count: ${value.count}'),
                if (child != null) child,
              ],
            );
          },
          // 这个 child 会被传入到 builder 的第三个参数
          child: const Text('Static Content'),
        ),
      ),
    );
  }
}
```

总结：

1. context 是由 Flutter 框架自动提供的构建上下文
2. value 是由 Provider 自动注入的数据模型实例
3. child 是从 Consumer 组件的 child 参数传入的

这三个参数的传入是自动的，你不需要手动传入，只需要：

1. 正确设置 Provider
2. 在需要的地方使用 Consumer
3. 如果需要静态内容，提供 child 参数

#### 完整示例展示参数传递过程

```dart
// 1. 首先创建数据模型
class CounterModel extends ChangeNotifier {
  int _count = 0;
  int get count => _count;

  void increment() {
    _count++;
    notifyListeners();
  }
}

// 2. 在应用中提供数据模型
void main() {
  runApp(
    ChangeNotifierProvider(
      create: (_) => CounterModel(),  // 创建数据模型实例
      child: MyApp(),
    ),
  );
}

// 3. 在组件中使用 Consumer
class MyWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {  // 这个 context 来自 Flutter 框架
    return Consumer<CounterModel>(
      builder: (
        context,     // Flutter 框架自动传入的 BuildContext
        counter,     // Provider 自动传入的 CounterModel 实例
        child,       // Consumer 的 child 参数传入
      ) {
        // 在这里可以使用这三个参数
        return Column(
          children: [
            // 使用 context 访问主题
            Text(
              'Count: ${counter.count}',
              style: Theme.of(context).textTheme.headline6,
            ),
            
            // 使用传入的静态子组件
            if (child != null) child,
            
            // 使用 counter（value）调用方法
            ElevatedButton(
              onPressed: counter.increment,
              child: Text('Increment'),
            ),
          ],
        );
      },
      // 这个 child 会被传入到 builder 的第三个参数
      child: const Text('This is static content'),
    );
  }
}
```

#### 带有子组件优化的用法

```dart
Consumer<CounterModel>(
  builder: (context, counter, child) {
    return Column(
      children: [
        Text('Count: ${counter.count}'),
        child!,  // 优化：不需要重建的子组件
      ],
    );
  },
  child: SomeExpensiveWidget(),  // 这个widget不会重建
)
```

#### 完整示例

```dart
class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return ChangeNotifierProvider(
      create: (_) => CounterModel(),
      child: MaterialApp(
        home: HomePage(),
      ),
    );
  }
}

class HomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Consumer<CounterModel>(
          builder: (context, counter, child) {
            return Text('计数: ${counter.count}');
          },
        ),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            // 基本使用
            Consumer<CounterModel>(
              builder: (context, counter, child) {
                return Text(
                  '当前计数: ${counter.count}',
                  style: TextStyle(fontSize: 24),
                );
              },
            ),

            // 带有静态子组件
            Consumer<CounterModel>(
              builder: (context, counter, child) {
                return Column(
                  children: [
                    Text('计数: ${counter.count}'),
                    child!,  // 使用静态子组件
                  ],
                );
              },
              child: const Text('这个文本不会重建'),  // 静态内容
            ),

            // 按钮
            ElevatedButton(
              onPressed: () {
                // 使用 Provider.of 来调用方法
                Provider.of<CounterModel>(context, listen: false).increment();
              },
              child: Text('增加'),
            ),
          ],
        ),
      ),
    );
  }
}
```

#### 多个类型的 Consumer

```dart
// Consumer2：监听两个数据模型
Consumer2<UserModel, ThemeModel>(
  builder: (
    BuildContext context,
    UserModel user,         // 第一个数据模型
    ThemeModel theme,       // 第二个数据模型
    Widget? child,
  ) {
    return Text(
      '用户: ${user.name}, 主题: ${theme.isDark ? "暗色" : "亮色"}',
    );
  },
)

// Consumer3：监听三个数据模型
Consumer3<UserModel, ThemeModel, CounterModel>(
  builder: (
    BuildContext context,
    UserModel user,         // 第一个数据模型
    ThemeModel theme,       // 第二个数据模型
    CounterModel counter,   // 第三个数据模型
    Widget? child,
  ) {
    return Text(
      '用户: ${user.name}, 主题: ${theme.isDark ? "暗色" : "亮色"}, 计数: ${counter.count}',
    );
  },
)
```

##### 实际应用示例

```dart
class HomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        // 使用 Consumer 监听用户数据
        title: Consumer<UserModel>(
          builder: (context, user, _) {
            return Text('Welcome, ${user.name}');
          },
        ),
        
        // 使用 Consumer 监听主题
        actions: [
          Consumer<ThemeModel>(
            builder: (context, theme, _) {
              return IconButton(
                icon: Icon(theme.isDark ? Icons.light_mode : Icons.dark_mode),
                onPressed: theme.toggleTheme,
              );
            },
          ),
        ],
      ),
      body: Column(
        children: [
          // 使用 Consumer 带静态子组件
          Consumer<CounterModel>(
            builder: (context, counter, child) {
              return Card(
                child: Padding(
                  padding: EdgeInsets.all(16.0),
                  child: Column(
                    children: [
                      Text('Count: ${counter.count}'),
                      SizedBox(height: 8),
                      child!, // 使用静态子组件
                    ],
                  ),
                ),
              );
            },
            // 定义不需要重建的复杂组件
            child: const ExpensiveWidget(),
          ),

          // 使用 Consumer2 监听多个状态
          Consumer2<UserModel, CounterModel>(
            builder: (context, user, counter, _) {
              return ListTile(
                title: Text('${user.name}的计数'),
                subtitle: Text('${counter.count}'),
                trailing: IconButton(
                  icon: Icon(Icons.add),
                  onPressed: counter.increment,
                ),
              );
            },
          ),

          // 使用 Consumer3 监听三个状态
          Consumer3<UserModel, ThemeModel, CounterModel>(
            builder: (context, user, theme, counter, child) {
              return Container(
                padding: EdgeInsets.all(16),
                color: theme.isDark ? Colors.grey[800] : Colors.grey[200],
                child: Column(
                  children: [
                    Text(
                      '用户: ${user.name}',
                      style: TextStyle(
                        color: theme.isDark ? Colors.white : Colors.black,
                      ),
                    ),
                    Text(
                      '计数: ${counter.count}',
                      style: TextStyle(
                        color: theme.isDark ? Colors.white : Colors.black,
                      ),
                    ),
                    if (child != null) child,
                  ],
                ),
              );
            },
            child: const Text('静态内容'),
          ),
        ],
      ),
    );
  }
}

// 昂贵的静态组件
class ExpensiveWidget extends StatelessWidget {
  const ExpensiveWidget({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: EdgeInsets.all(8),
      decoration: BoxDecoration(
        border: Border.all(color: Colors.grey),
        borderRadius: BorderRadius.circular(8),
      ),
      child: Text('这是一个复杂的静态组件'),
    );
  }
}
```

使用建议：

1. context 参数：

   - 用于访问主题、导航等

   - 可以获取其他 Provider 的数据

2. value 参数：

   - 直接使用数据模型的属性和方法

   - 当数据变化时会触发重建

3. child 参数：

   - 用于优化性能

   - 放置不需要重建的静态内容

   - 可以是 null，使用时需要判断

4. 性能优化：

   - 合理使用 child 参数

   - 避免在 builder 中创建大量widget

   - 考虑使用 Selector 替代 Consumer


#### 多个 Provider 的使用

```dart
// 用户模型
class UserModel extends ChangeNotifier {
  String _name = 'Guest';
  String get name => _name;

  void updateName(String newName) {
    _name = newName;
    notifyListeners();
  }
}

// 主题模型
class ThemeModel extends ChangeNotifier {
  bool _isDark = false;
  bool get isDark => _isDark;

  void toggleTheme() {
    _isDark = !_isDark;
    notifyListeners();
  }
}

// 在应用中使用多个 Provider
class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (_) => UserModel()),
        ChangeNotifierProvider(create: (_) => ThemeModel()),
        ChangeNotifierProvider(create: (_) => CounterModel()),
      ],
      child: MaterialApp(
        home: HomePage(),
      ),
    );
  }
}

// 在页面中使用多个 Consumer
class HomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Consumer<UserModel>(
          builder: (context, user, _) {
            return Text('Welcome, ${user.name}');
          },
        ),
        actions: [
          // 主题切换按钮
          Consumer<ThemeModel>(
            builder: (context, theme, _) {
              return IconButton(
                icon: Icon(
                  theme.isDark ? Icons.light_mode : Icons.dark_mode,
                ),
                onPressed: theme.toggleTheme,
              );
            },
          ),
        ],
      ),
      body: Column(
        children: [
          // 组合多个 Consumer
          Consumer2<UserModel, CounterModel>(
            builder: (context, user, counter, child) {
              return Column(
                children: [
                  Text('User: ${user.name}'),
                  Text('Count: ${counter.count}'),
                  child!,
                ],
              );
            },
            child: const Text('静态内容'),
          ),

          // 嵌套使用 Consumer
          Consumer<UserModel>(
            builder: (context, user, _) {
              return Consumer<CounterModel>(
                builder: (context, counter, _) {
                  return Text(
                    '${user.name}的计数: ${counter.count}',
                  );
                },
              );
            },
          ),
        ],
      ),
    );
  }
}
```

##### 多个数据模型传入Providers

```dart
// 1. 创建多个数据模型
class UserModel extends ChangeNotifier {
  String _name = 'Guest';
  String get name => _name;
  
  void updateName(String newName) {
    _name = newName;
    notifyListeners();
  }
}

class ThemeModel extends ChangeNotifier {
  bool _isDark = false;
  bool get isDark => _isDark;
  
  void toggleTheme() {
    _isDark = !_isDark;
    notifyListeners();
  }
}

// 2. 在应用根部提供多个 Provider
void main() {
  runApp(
    MultiProvider(  // 使用 MultiProvider 提供多个数据模型
      providers: [
        ChangeNotifierProvider(create: (_) => UserModel()),
        ChangeNotifierProvider(create: (_) => ThemeModel()),
        ChangeNotifierProvider(create: (_) => CounterModel()),
      ],
      child: MyApp(),
    ),
  );
}

// 3. 在不同位置使用 Consumer
class HomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        // 使用 Consumer 监听用户数据
        title: Consumer<UserModel>(
          builder: (context, user, _) {
            return Text('Welcome, ${user.name}');
          },
        ),
        
        // 使用 Consumer 监听主题
        actions: [
          Consumer<ThemeModel>(
            builder: (context, theme, _) {
              return IconButton(
                icon: Icon(theme.isDark ? Icons.light_mode : Icons.dark_mode),
                onPressed: theme.toggleTheme,
              );
            },
          ),
        ],
      ),
      
      // 使用多个 Consumer
      body: Column(
        children: [
          Consumer<CounterModel>(
            builder: (context, counter, _) {
              return Text('Count: ${counter.count}');
            },
          ),
          
          Consumer2<UserModel, ThemeModel>(
            builder: (context, user, theme, _) {
              return Text(
                '${user.name}\'s theme: ${theme.isDark ? "Dark" : "Light"}',
              );
            },
          ),
        ],
      ),
    );
  }
}
```



#### Consumer 的优化使用

```dart
class ProfilePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Column(
        children: [
          // 1. 使用 Selector 代替 Consumer 来优化性能
          Selector<UserModel, String>(
            selector: (_, user) => user.name,  // 只监听 name 属性
            builder: (context, name, child) {
              return Text('Name: $name');
            },
          ),

          // 2. 使用 Consumer 的 child 参数优化性能
          Consumer<CounterModel>(
            builder: (context, counter, child) {
              return Column(
                children: [
                  Text('Count: ${counter.count}'),
                  child!,  // 静态内容不会重建
                ],
              );
            },
            child: const ExpensiveWidget(),  // 复杂的静态组件
          ),

          // 3. 精确定位 Consumer
          Card(
            child: Column(
              children: [
                const Text('固定标题'),  // 不需要重建
                Consumer<CounterModel>(
                  builder: (context, counter, _) {
                    return Text('${counter.count}');  // 只有这部分会重建
                  },
                ),
                const Text('固定底部'),  // 不需要重建
              ],
            ),
          ),
        ],
      ),
    );
  }
}
```

使用建议：

1. 合理使用 child 参数优化性能
2. 尽可能将 Consumer 放在 widget 树的叶子节点
3. 考虑使用 Selector 来优化性能
4. 避免不必要的重建
5. 正确处理多个 Provider 的依赖关系

#### Consumer 必须和 ChangeNotifierProvider 配合使用

> Consumer 必须和 ChangeNotifierProvider 配合使用。

```dart
// 1. 数据模型
class CounterModel extends ChangeNotifier {
  int _count = 0;
  int get count => _count;
  void increment() {
    _count++;
    notifyListeners();
  }
}

// 2. 应用入口
void main() {
  runApp(
    // 必须提供 ChangeNotifierProvider
    ChangeNotifierProvider(
      create: (_) => CounterModel(),  // 创建数据模型实例
      child: MyApp(),
    ),
  );
}

// 3. 应用根组件
class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: MyWidget(),  // 使用 MyWidget
    );
  }
}

// 4. 使用 Consumer 的组件
class MyWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // Consumer 必须在 ChangeNotifierProvider 的子树中
    return Consumer<CounterModel>(
      builder: (context, value, child) {
        return Column(
          children: [
            Text('计数: ${value.count}'),
            ElevatedButton(
              onPressed: value.increment,
              child: Text('增加'),
            ),
            if (child != null) child,
          ],
        );
      },
      child: const Text('这个不会重建'),
    );
  }
}
```

你也可以在局部提供 Provider：

```dart
class LocalProviderExample extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return ChangeNotifierProvider(
      create: (_) => CounterModel(),  // 局部提供数据模型
      child: Builder(
        builder: (context) {
          return Column(
            children: [
              Consumer<CounterModel>(
                builder: (context, counter, child) {
                  return Text('Local Count: ${counter.count}');
                },
              ),
            ],
          );
        },
      ),
    );
  }
}
```

Provider 的查找规则：

1. Consumer 会在 widget 树中向上查找最近的 ChangeNotifierProvider
2. Provider 必须在 Consumer 之前创建
3. 一个 Provider 可以供多个 Consumer 使用

总结：

1. Consumer 必须和 ChangeNotifierProvider 配合使用
2. Provider 必须在 Consumer 的上层 widget 树中
3. 可以使用 MultiProvider 提供多个数据模型
4. Provider 可以在应用根部或局部提供
5. 一个 Provider 可以被多个 Consumer 使用

### Selector（选择性监听）

```dart
Selector<UserModel, String>(
  selector: (context, user) => user.name,  // 只监听name属性
  builder: (context, name, child) {
    return Text('Name: $name');
  },
)
```

### 实际应用示例

```dart
// 1. 用户状态管理
class UserState extends ChangeNotifier {
  User? _user;
  bool _isLoading = false;
  String? _error;

  User? get user => _user;
  bool get isLoading => _isLoading;
  String? get error => _error;

  Future<void> login(String username, String password) async {
    try {
      _isLoading = true;
      _error = null;
      notifyListeners();

      _user = await AuthService.login(username, password);
      
    } catch (e) {
      _error = e.toString();
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  void logout() {
    _user = null;
    notifyListeners();
  }
}

// 2. 购物车状态管理
class CartState extends ChangeNotifier {
  final List<Product> _items = [];
  double _total = 0;

  List<Product> get items => _items;
  double get total => _total;

  void addItem(Product product) {
    _items.add(product);
    _calculateTotal();
    notifyListeners();
  }

  void removeItem(Product product) {
    _items.remove(product);
    _calculateTotal();
    notifyListeners();
  }

  void _calculateTotal() {
    _total = _items.fold(0, (sum, item) => sum + item.price);
  }
}

// 3. 完整应用示例
class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (_) => UserState()),
        ChangeNotifierProvider(create: (_) => CartState()),
      ],
      child: MaterialApp(
        home: HomePage(),
      ),
    );
  }
}

class HomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('商城'),
        actions: [
          // 使用Consumer监听购物车
          Consumer<CartState>(
            builder: (context, cart, child) {
              return Badge(
                label: Text('${cart.items.length}'),
                child: IconButton(
                  icon: Icon(Icons.shopping_cart),
                  onPressed: () {
                    Navigator.push(context,
                      MaterialPageRoute(builder: (_) => CartPage()),
                    );
                  },
                ),
              );
            },
          ),
        ],
      ),
      body: Column(
        children: [
          // 使用Selector监听用户名
          Selector<UserState, String?>(
            selector: (_, user) => user.user?.name,
            builder: (context, name, child) {
              return Text('Welcome, ${name ?? 'Guest'}');
            },
          ),
          
          // 商品列表
          Expanded(
            child: ProductList(),
          ),
        ],
      ),
    );
  }
}

class ProductList extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      itemCount: products.length,
      itemBuilder: (context, index) {
        final product = products[index];
        return ListTile(
          title: Text(product.name),
          subtitle: Text('\$${product.price}'),
          trailing: Consumer<CartState>(
            builder: (context, cart, child) {
              return IconButton(
                icon: Icon(Icons.add_shopping_cart),
                onPressed: () => cart.addItem(product),
              );
            },
          ),
        );
      },
    );
  }
}

class CartPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('购物车')),
      body: Consumer<CartState>(
        builder: (context, cart, child) {
          if (cart.items.isEmpty) {
            return Center(child: Text('购物车为空'));
          }

          return Column(
            children: [
              Expanded(
                child: ListView.builder(
                  itemCount: cart.items.length,
                  itemBuilder: (context, index) {
                    final item = cart.items[index];
                    return ListTile(
                      title: Text(item.name),
                      trailing: IconButton(
                        icon: Icon(Icons.remove_circle),
                        onPressed: () => cart.removeItem(item),
                      ),
                    );
                  },
                ),
              ),
              Padding(
                padding: EdgeInsets.all(16),
                child: Text('总计: \$${cart.total}'),
              ),
            ],
          );
        },
      ),
    );
  }
}
```

### 其他状态管理方案：

#### GetX

```dart
// 控制器
class CounterController extends GetxController {
  var count = 0.obs;
  
  void increment() => count++;
}

// 使用
class HomePage extends StatelessWidget {
  final controller = Get.put(CounterController());
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Obx(() => Text('${controller.count}')),
      floatingActionButton: FloatingActionButton(
        onPressed: controller.increment,
      ),
    );
  }
}
```

#### Bloc

```dart
// 事件
abstract class CounterEvent {}
class IncrementEvent extends CounterEvent {}

// 状态
class CounterState {
  final int count;
  CounterState(this.count);
}

// Bloc
class CounterBloc extends Bloc<CounterEvent, CounterState> {
  CounterBloc() : super(CounterState(0)) {
    on<IncrementEvent>((event, emit) {
      emit(CounterState(state.count + 1));
    });
  }
}
```

#### Riverpod

```dart
// 提供者
final counterProvider = StateNotifierProvider<Counter, int>((ref) {
  return Counter();
});

class Counter extends StateNotifier<int> {
  Counter() : super(0);
  
  void increment() => state++;
}

// 使用
class CounterWidget extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final count = ref.watch(counterProvider);
    return Text('$count');
  }
}
```

## getter（获取器）& setter（设置器）

### Getter（获取器）

```dart
class Person {
  // 私有变量
  String _name;
  int _age;

  // getter - 只读属性
  String get name => _name;
  int get age => _age;

  // getter with logic - 带逻辑的getter
  bool get isAdult => _age >= 18;
  String get displayName => 'Mr/Ms $_name';
}
```

```dart
 _httpClient = HttpClient(baseUrl: baseUrl);
HttpClient get httpClient => _httpClient;
```

这是简写形式的getter方法，它的完整写法等同于：

```dart
HttpClient get httpClient {
  return _httpClient;
}
```

其中：

- HttpClient 是返回类型

- get 是声明这是一个getter的关键字

- httpClient 是这个getter的名称（即外部访问的属性名）

- => _httpClient 是箭头函数语法，直接返回_httpClient私有字段的值

使用场景与目的：

1. **封装私有字段**：通常_httpClient是一个类的私有字段（以下划线开头表示私有），通过getter提供对它的只读访问

2. **控制访问权限**：外部代码可以读取但不能直接修改该属性
3. **使用示例**:

```dart
   class ApiService {
     final HttpClient _httpClient; // 私有字段
     
     ApiService(this._httpClient);
     
     // 公开的getter
     HttpClient get httpClient => _httpClient;
   }
   
   // 使用时：
   final service = ApiService(client);
   final client = service.httpClient; // 通过getter访问
```

4. **计算属性**: getter也可以用于返回计算值，而不仅是存储的字段：

   ```dart
      String get fullName => "$firstName $lastName";
   ```

   

### Setter（设置器）

```dart
class Person {
  String _name;
  int _age;

  // setter - 设置属性
  set name(String value) {
    _name = value;
  }

  // setter with validation - 带验证的setter
  set age(int value) {
    if (value < 0) {
      throw ArgumentError('Age cannot be negative');
    }
    _age = value;
  }
}
```

### 完整示例

```dart
class BankAccount {
  // 私有变量
  double _balance = 0;
  String _accountNumber;
  
  // 简单的 getter
  double get balance => _balance;
  String get accountNumber => _accountNumber;
  
  // 带计算的 getter
  bool get isOverdrawn => _balance < 0;
  String get formattedBalance => '\$${_balance.toStringAsFixed(2)}';
  
  // 带验证的 setter
  set balance(double value) {
    if (value < -1000) {
      throw Exception('Balance cannot be less than -\$1000');
    }
    _balance = value;
  }
  
  // 带格式化的 setter
  set accountNumber(String value) {
    if (!value.contains('-')) {
      value = '${value.substring(0, 3)}-${value.substring(3)}';
    }
    _accountNumber = value;
  }
}
```

### 在 Flutter 中的应用

```dart
class CounterModel extends ChangeNotifier {
  // 私有状态
  int _count = 0;
  bool _isLoading = false;
  List<String> _items = [];

  // Getters
  int get count => _count;
  bool get isLoading => _isLoading;
  List<String> get items => List.unmodifiable(_items);  // 返回不可修改的列表
  bool get isEmpty => _items.isEmpty;
  bool get isNotEmpty => _items.isNotEmpty;
  int get itemCount => _items.length;

  // Setters
  set count(int value) {
    if (value != _count) {
      _count = value;
      notifyListeners();
    }
  }

  // 方法
  void increment() {
    _count++;
    notifyListeners();
  }
}
```

### 高级用法

```dart
class Rectangle {
  double _width = 0;
  double _height = 0;

  // 基本的 getter 和 setter
  double get width => _width;
  double get height => _height;

  set width(double value) {
    if (value < 0) throw ArgumentError('Width cannot be negative');
    _width = value;
  }

  set height(double value) {
    if (value < 0) throw ArgumentError('Height cannot be negative');
    _height = value;
  }

  // 计算属性
  double get area => _width * _height;
  double get perimeter => 2 * (_width + _height);
  bool get isSquare => _width == _height;

  // 带缓存的 getter
  double? _diagonalCache;
  double get diagonal {
    _diagonalCache ??= sqrt(_width * _width + _height * _height);
    return _diagonalCache!;
  }
}
```

### 实际应用示例

```dart
class UserProfile {
  String _firstName = '';
  String _lastName = '';
  DateTime? _birthDate;
  List<String> _roles = [];

  // 基本 getters
  String get firstName => _firstName;
  String get lastName => _lastName;
  DateTime? get birthDate => _birthDate;
  
  // 计算属性
  String get fullName => '$_firstName $_lastName';
  bool get hasName => _firstName.isNotEmpty || _lastName.isNotEmpty;
  
  // 带逻辑的 getter
  int get age {
    if (_birthDate == null) return 0;
    return DateTime.now().difference(_birthDate!).inDays ~/ 365;
  }
  
  // 列表相关的 getter
  List<String> get roles => List.unmodifiable(_roles);
  bool get isAdmin => _roles.contains('admin');
  bool get isUser => _roles.contains('user');
  
  // 带验证的 setters
  set firstName(String value) {
    if (value.isEmpty) throw ArgumentError('First name cannot be empty');
    _firstName = value;
  }
  
  set lastName(String value) {
    if (value.isEmpty) throw ArgumentError('Last name cannot be empty');
    _lastName = value;
  }
  
  set birthDate(DateTime? value) {
    if (value != null && value.isAfter(DateTime.now())) {
      throw ArgumentError('Birth date cannot be in the future');
    }
    _birthDate = value;
  }
}

// 使用示例
void main() {
  final user = UserProfile();
  
  // 使用 setters
  user.firstName = 'John';
  user.lastName = 'Doe';
  user.birthDate = DateTime(1990, 1, 1);
  
  // 使用 getters
  print(user.fullName);      // John Doe
  print(user.age);          // 计算年龄
  print(user.isAdmin);      // false
}
```

getter 和 setter 的优点：

1. 封装性：隐藏内部实现
2. 控制访问：可以只读或只写
3. 验证数据：可以在 setter 中验证
4. 计算属性：可以动态计算值
5. 延迟计算：可以实现懒加载

使用建议：

1. 使用 getter 代替简单的公共变量
2. 在需要验证的地方使用 setter
3. 使用私有变量配合 getter/setter
4. 合理使用计算属性
5. 注意性能影响

## Flutter 枚举类

### MainAxisAlignment（主轴对齐方式）

```dart
Row(
  mainAxisAlignment: MainAxisAlignment.start,  // 开始对齐
  // 可选值:
  // MainAxisAlignment.start      - 开始对齐
  // MainAxisAlignment.end        - 结束对齐
  // MainAxisAlignment.center     - 居中对齐
  // MainAxisAlignment.spaceBetween - 两端对齐，中间等距
  // MainAxisAlignment.spaceAround  - 平均分配空间，边缘空间是中间的一半
  // MainAxisAlignment.spaceEvenly  - 完全平均分配空间
  children: [Text('A'), Text('B')],
)
```

### CrossAxisAlignment（交叉轴对齐方式）

```dart
Column(
  crossAxisAlignment: CrossAxisAlignment.start,  // 起始对齐
  // 可选值:
  // CrossAxisAlignment.start     - 起始对齐
  // CrossAxisAlignment.end       - 结束对齐
  // CrossAxisAlignment.center    - 居中对齐
  // CrossAxisAlignment.stretch   - 拉伸填充
  // CrossAxisAlignment.baseline  - 基线对齐
  children: [Text('A'), Text('B')],
)
```

### Alignment（对齐方式）

```dart
Container(
  alignment: Alignment.topCenter,  // 顶部居中
  // 预定义常量:
  // Alignment.topLeft        - 左上角
  // Alignment.topCenter      - 顶部居中
  // Alignment.topRight       - 右上角
  // Alignment.centerLeft     - 左侧居中
  // Alignment.center         - 完全居中
  // Alignment.centerRight    - 右侧居中
  // Alignment.bottomLeft     - 左下角
  // Alignment.bottomCenter   - 底部居中
  // Alignment.bottomRight    - 右下角
  
  // 自定义对齐位置:
  // Alignment(0.0, 0.0)      - 中心点
  // Alignment(-1.0, -1.0)    - 左上角
  // Alignment(1.0, 1.0)      - 右下角
)
```

### TextAlign（文本对齐方式）

```dart
Text(
  'Hello World',
  textAlign: TextAlign.center,  // 居中对齐
  // 可选值:
  // TextAlign.left           - 左对齐
  // TextAlign.right          - 右对齐
  // TextAlign.center         - 居中对齐
  // TextAlign.justify        - 两端对齐
  // TextAlign.start          - 起始位置对齐（根据文本方向）
  // TextAlign.end            - 结束位置对齐（根据文本方向）
)
```

### TextDirection（文本方向）

```dart
Directionality(
  textDirection: TextDirection.ltr,  // 从左到右
  // 可选值:
  // TextDirection.ltr        - 从左到右
  // TextDirection.rtl        - 从右到左
  child: Text('Hello'),
)
```

### VerticalDirection（垂直方向）

```dart
Column(
  verticalDirection: VerticalDirection.down,  // 从上到下
  // 可选值:
  // VerticalDirection.up     - 从下到上
  // VerticalDirection.down   - 从上到下
  children: [Text('A'), Text('B')],
)
```

### Axis（轴向）

```dart
Scrollable(
  axisDirection: AxisDirection.down,  // 向下滚动
  // AxisDirection 可选值:
  // AxisDirection.up         - 向上
  // AxisDirection.down       - 向下
  // AxisDirection.left       - 向左
  // AxisDirection.right      - 向右
  
  // Axis 可选值:
  // Axis.horizontal          - 水平方向
  // Axis.vertical            - 垂直方向
)
```

### BoxFit（盒子适应方式）

```dart
Image.network(
  'image_url',
  fit: BoxFit.cover,  // 覆盖填充
  // 可选值:
  // BoxFit.fill            - 拉伸填充
  // BoxFit.contain         - 包含（保持比例，确保完全可见）
  // BoxFit.cover           - 覆盖（保持比例，可能裁剪）
  // BoxFit.fitWidth        - 适应宽度
  // BoxFit.fitHeight       - 适应高度
  // BoxFit.none            - 不调整
  // BoxFit.scaleDown       - 缩小（如果需要）
)
```

### FontWeight（字体粗细）

```dart
Text(
  'Bold Text',
  style: TextStyle(
    fontWeight: FontWeight.bold,  // 粗体
    // 可选值:
    // FontWeight.w100        - 极细
    // FontWeight.w200        - 很细
    // FontWeight.w300        - 细体
    // FontWeight.w400, FontWeight.normal - 常规
    // FontWeight.w500        - 中等
    // FontWeight.w600        - 半粗体
    // FontWeight.w700, FontWeight.bold   - 粗体
    // FontWeight.w800        - 很粗体
    // FontWeight.w900        - 极粗体
  ),
)
```

### MainAxisSize（主轴尺寸）

```dart
Row(
  mainAxisSize: MainAxisSize.min,  // 最小化主轴尺寸
  // 可选值:
  // MainAxisSize.min        - 最小化主轴尺寸
  // MainAxisSize.max        - 最大化主轴尺寸
  children: [Text('A'), Text('B')],
)
```

### BorderStyle（边框样式）

```dart
Container(
  decoration: BoxDecoration(
    border: Border.all(
      style: BorderStyle.solid,  // 实线边框
      // 可选值:
      // BorderStyle.solid      - 实线
      // BorderStyle.none       - 无边框
    ),
  ),
)
```

### BlendMode（混合模式）

```dart
ColorFiltered(
  colorFilter: ColorFilter.mode(
    Colors.red,
    BlendMode.srcOver,  // 源图像在上层
    // 众多可选值，例如:
    // BlendMode.srcOver      - 源图像在上层
    // BlendMode.dstOver      - 目标图像在上层
    // BlendMode.color        - 保留亮度，使用源颜色
    // BlendMode.colorBurn    - 加深混合
    // BlendMode.overlay      - 叠加
  ),
)
```

### StrokeCap（线条端点样式）

```dart
CustomPaint(
  painter: MyPainter(),  // 自定义绘制
  // 在自定义绘制中:
  // Paint()
  //   ..strokeCap = StrokeCap.round
  //
  // 可选值:
  // StrokeCap.butt         - 平直端点
  // StrokeCap.round        - 圆形端点
  // StrokeCap.square       - 方形端点
)
```

### FloatingLabelBehavior（浮动标签行为）

```dart
TextField(
  decoration: InputDecoration(
    labelText: 'Username',
    floatingLabelBehavior: FloatingLabelBehavior.auto,
    // 可选值:
    // FloatingLabelBehavior.auto    - 自动
    // FloatingLabelBehavior.always  - 总是浮动
    // FloatingLabelBehavior.never   - 从不浮动
  ),
)
```

### 实际应用示例

```dart
import 'package:flutter/material.dart';

class LayoutExamplePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Layout Examples')),
      body: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // 主轴对齐示例
          Container(
            height: 80,
            color: Colors.amber[100],
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
              children: [
                Text('Item 1'),
                Text('Item 2'),
                Text('Item 3'),
              ],
            ),
          ),
          
          SizedBox(height: 16),
          
          // 交叉轴对齐示例
          Container(
            height: 100,
            color: Colors.blue[100],
            child: Row(
              crossAxisAlignment: CrossAxisAlignment.center,
              children: [
                Container(
                  width: 100,
                  child: Text('Left Aligned', 
                    textAlign: TextAlign.center,
                  ),
                ),
                Expanded(
                  child: Container(
                    alignment: Alignment.center,
                    child: Text('Center Aligned'),
                  ),
                ),
              ],
            ),
          ),
          
          SizedBox(height: 16),
          
          // 图片适应示例
          Row(
            children: [
              Expanded(
                child: Column(
                  children: [
                    Text('BoxFit.cover'),
                    Container(
                      height: 100,
                      child: Image.network(
                        'https://picsum.photos/200',
                        fit: BoxFit.cover,
                      ),
                    ),
                  ],
                ),
              ),
              Expanded(
                child: Column(
                  children: [
                    Text('BoxFit.contain'),
                    Container(
                      height: 100,
                      child: Image.network(
                        'https://picsum.photos/200',
                        fit: BoxFit.contain,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
          
          SizedBox(height: 16),
          
          // 文本样式示例
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children: [
              Text('Normal',
                style: TextStyle(
                  fontWeight: FontWeight.normal,
                ),
              ),
              Text('Bold',
                style: TextStyle(
                  fontWeight: FontWeight.bold,
                ),
              ),
              Text('w900',
                style: TextStyle(
                  fontWeight: FontWeight.w900,
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }
}
```

