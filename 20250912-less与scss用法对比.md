# 20250912-less与scss用法对比

## **SCSS 和 LESS 的主要区别：**

1.  **变量声明**:
    
    *   **SCSS**: 使用 `$` 符号，例如：`$blue: #337ab7;`
    *   **LESS**: 使用 `@` 符号，例如：`@blue: #337ab7;`
    
2.  **Mixin (混合)**:
    *   **SCSS**: 使用 `@mixin` 声明，使用 `@include` 引入。
        ```scss
        @mixin border-radius($radius) {
          -webkit-border-radius: $radius;
          border-radius: $radius;
        }
        .box { @include border-radius(10px); }
        ```
    *   **LESS**: 将 mixin 声明为带括号的 class，并直接像 class 一样引用它。
        ```less
        .border-radius(@radius) {
          -webkit-border-radius: @radius;
          border-radius: @radius;
        }
        .box { .border-radius(10px); }
        ```

3.  **逻辑控制**:
    *   **SCSS**: 支持更强大的逻辑控制，如 `@if`, `@for`, `@each`, 和 `@while` 循环。这使得它更像一门编程语言，可以处理非常复杂的样式逻辑。
    *   **LESS**: 只有 "Guarded Mixins"（守护 Mixin），可以根据表达式的真假来决定是否应用一个 mixin，功能上类似于 `if` 语句，但没有循环功能。

4.  **编译环境**:
    *   **SCSS**: 主要的编译器是 Dart Sass（基于 Dart 语言），性能非常高。过去也有基于 C/C++ 的 LibSass 和基于 Ruby 的版本。
    *   **LESS**: 基于 JavaScript，通常在 Node.js 环境中运行。这使得它与前端构建工具（如 Webpack）的集成非常自然。

**哪个更强？**

这没有一个绝对的答案，取决于你的项目需求和团队偏好：

*   **功能和复杂性方面，SCSS 更强**。它提供了完整的编程语言特性（如循环和条件判断），非常适合大型、复杂的项目，可以编写出高度结构化和可维护的样式代码。
*   **易用性和集成方面，LESS 有一定优势**。它的语法更简单，学习曲线更平缓。由于它是基于 JavaScript 的，对于主要使用 Node.js 技术栈的前端团队来说，集成和使用可能更方便。

**总结：**
如果你需要处理复杂的逻辑，或者希望使用更强大的编程功能，**SCSS 是更好的选择**。目前它也是社区更主流、生态更丰富的选择（例如 Bootstrap 从 LESS 迁移到了 Sass）。
如果你追求简单，或者你的项目与 Node.js 环境紧密集成，**LESS 也是一个不错的选择**。

## scss 与 less 转换

- scss 代码:

  ```scss
  @use './variables.module.scss' as *;
  
  @mixin colorBtn($color) {
    background: $color;
  
    &:hover {
      color: $color;
  
      &:before,
      &:after {
        background: $color;
      }
    }
  }
  
  .blue-btn {
    @include colorBtn($blue);
  }
  
  .light-blue-btn {
    @include colorBtn($light-blue);
  }
  
  .red-btn {
    @include colorBtn($red);
  }
  
  .pink-btn {
    @include colorBtn($pink);
  }
  
  .green-btn {
    @include colorBtn($green);
  }
  
  .tiffany-btn {
    @include colorBtn($tiffany);
  }
  
  .yellow-btn {
    @include colorBtn($yellow);
  }
  
  .pan-btn {
    font-size: 14px;
    color: #fff;
    padding: 14px 36px;
    border-radius: 8px;
    border: none;
    outline: none;
    transition: 600ms ease all;
    position: relative;
    display: inline-block;
  
    &:hover {
      background: #fff;
  
      &:before,
      &:after {
        width: 100%;
        transition: 600ms ease all;
      }
    }
  
    &:before,
    &:after {
      content: '';
      position: absolute;
      top: 0;
      right: 0;
      height: 2px;
      width: 0;
      transition: 400ms ease all;
    }
  
    &::after {
      right: inherit;
      top: inherit;
      left: 0;
      bottom: 0;
    }
  }
  
  .custom-button {
    display: inline-block;
    line-height: 1;
    white-space: nowrap;
    cursor: pointer;
    background: #fff;
    color: #fff;
    -webkit-appearance: none;
    text-align: center;
    box-sizing: border-box;
    outline: 0;
    margin: 0;
    padding: 10px 15px;
    font-size: 14px;
    border-radius: 4px;
  }
  ```

- less :

  ```less
  @import './variables.module.less';
  
  .colorBtn(@color) {
    background: @color;
  
    &:hover {
      color: @color;
  
      &:before,
      &:after {
        background: @color;
      }
    }
  }
  
  .blue-btn {
    .colorBtn(@blue);
  }
  
  .light-blue-btn {
    .colorBtn(@light-blue);
  }
  
  .red-btn {
    .colorBtn(@red);
  }
  
  .pink-btn {
    .colorBtn(@pink);
  }
  
  .green-btn {
    .colorBtn(@green);
  }
  
  .tiffany-btn {
    .colorBtn(@tiffany);
  }
  
  .yellow-btn {
    .colorBtn(@yellow);
  }
  
  .pan-btn {
    font-size: 14px;
    color: #fff;
    padding: 14px 36px;
    border-radius: 8px;
    border: none;
    outline: none;
    transition: 600ms ease all;
    position: relative;
    display: inline-block;
  
    &:hover {
      background: #fff;
  
      &:before,
      &:after {
        width: 100%;
        transition: 600ms ease all;
      }
    }
  
    &:before,
    &:after {
      content: '';
      position: absolute;
      top: 0;
      right: 0;
      height: 2px;
      width: 0;
      transition: 400ms ease all;
    }
  
    &::after {
      right: inherit;
      top: inherit;
      left: 0;
      bottom: 0;
    }
  }
  
  .custom-button {
    display: inline-block;
    line-height: 1;
    white-space: nowrap;
    cursor: pointer;
    background: #fff;
    color: #fff;
    -webkit-appearance: none;
    text-align: center;
    box-sizing: border-box;
    outline: 0;
    margin: 0;
    padding: 10px 15px;
    font-size: 14px;
    border-radius: 4px;
  }
  
  ```

  

### 变量语法转换：
- `$blue` → `@blue`
- `$light-blue` → `@light-blue`
- 所有其他变量都从 `$` 改为 `@`

### Mixin 语法转换：
- `@mixin colorBtn($color)` → `.colorBtn(@color)`
- `@include colorBtn($blue)` → `.colorBtn(@blue)`

### 导入语法转换：
- `@use './variables.module.scss' as *;` → `@import './variables.module.less';`

## 需要注意的差异：

1. **:export 功能**：SCSS 的 `:export` 指令在 LESS 中不被支持。这个功能通常用于在 JavaScript 中访问 SCSS 变量。如果你需要在 JS 中使用这些变量，可能需要：
   - 使用 CSS 自定义属性（CSS Variables）
   - 创建单独的 JS 配置文件
   - 使用构建工具插件来处理变量导出

2. **CSS 自定义属性**：好消息是你的代码大量使用了 CSS 自定义属性（`--variable-name`），这些在 LESS 中完全兼容。

## SCSS 的 `:export` 功能详解

`:export` 是 SCSS 的一个特殊指令，它允许你将 SCSS 变量导出给 JavaScript 使用。这是一个非常实用的功能，特别是在需要在 CSS 和 JavaScript 之间共享变量值的场景中。

### 基本语法

 `variables.module.scss` 文件：

```scss
// 定义 SCSS 变量
$--color-primary: #409eff;
$--color-success: #67c23a;
$base-sidebar-width: 200px;

// 使用 :export 导出变量
:export {
  menuColor: $base-menu-color;
  menuLightColor: $base-menu-light-color;
  menuColorActive: $base-menu-color-active;
  menuBackground: $base-menu-background;
  menuLightBackground: $base-menu-light-background;
  subMenuBackground: $base-sub-menu-background;
  subMenuHover: $base-sub-menu-hover;
  sideBarWidth: $base-sidebar-width;
  logoTitleColor: $base-logo-title-color;
  logoLightTitleColor: $base-logo-light-title-color;
  primaryColor: $--color-primary;
  successColor: $--color-success;
  dangerColor: $--color-danger;
  infoColor: $--color-info;
  warningColor: $--color-warning;
}
```

### 工作原理

1. **编译过程**：当 Webpack 的 `css-loader` 处理这个 SCSS 文件时，`:export` 块会被转换为一个 JavaScript 对象
2. **模块导出**：这些变量会作为 ES6 模块的默认导出，可以在 JavaScript 中直接 import

### JavaScript 中的使用

```javascript
// 在 JavaScript 中导入
import variables from '@/assets/styles/variables.module.scss'

console.log(variables.primaryColor)  // "#409eff"
console.log(variables.sideBarWidth)  // "200px"
console.log(variables.menuBackground) // "var(--menuBg)"

// 在 Vue 组件中使用
export default {
  data() {
    return {
      themeColors: {
        primary: variables.primaryColor,
        success: variables.successColor,
        danger: variables.dangerColor
      }
    }
  },
  computed: {
    sidebarStyle() {
      return {
        width: variables.sideBarWidth,
        backgroundColor: variables.menuBackground
      }
    }
  }
}
```

### 实际应用场景

1. **主题切换**：
```javascript
// theme.js
import variables from '@/styles/variables.module.scss'

export const lightTheme = {
  primary: variables.primaryColor,
  background: variables.menuLightBackground
}

export const darkTheme = {
  primary: variables.primaryColor,
  background: variables.menuBackground
}
```

2. **动态样式计算**：
```javascript
// 根据 SCSS 变量计算 JavaScript 中的样式
const sidebarWidth = parseInt(variables.sideBarWidth) // 200
const contentWidth = `calc(100% - ${variables.sideBarWidth})`
```

3. **图表库配置**：
```javascript
// 在 ECharts 等图表库中使用统一的颜色
const chartOptions = {
  color: [
    variables.primaryColor,
    variables.successColor,
    variables.warningColor,
    variables.dangerColor
  ]
}
```

### 注意事项

1. **文件命名**：通常使用 `.module.scss` 后缀，这样 CSS Modules 会正确处理
2. **值类型**：导出的都是字符串类型，如果需要数值需要手动转换
3. **CSS 变量**：如果 SCSS 变量引用了 CSS 自定义属性（如 `var(--menuBg)`），导出的值就是字符串 `"var(--menuBg)"`

### 构建工具配置

需要确保 Webpack 配置支持 CSS Modules：

```javascript
// webpack.config.js
module.exports = {
  module: {
    rules: [
      {
        test: /\.module\.(scss|sass)$/,
        use: [
          'style-loader',
          {
            loader: 'css-loader',
            options: {
              modules: true // 启用 CSS Modules
            }
          },
          'sass-loader'
        ]
      }
    ]
  }
}
```

### 替代方案

如果不使用 SCSS，可以考虑：

1. **纯 CSS 自定义属性**：
```css
:root {
  --primary-color: #409eff;
}
```

2. **JavaScript 配置文件**：
```javascript
// theme.js
export const theme = {
  primaryColor: '#409eff',
  sideBarWidth: '200px'
}
```

3. **CSS-in-JS 解决方案**：如 styled-components、emotion 等

`:export` 功能让 SCSS 在现代前端开发中更加强大，实现了样式和逻辑的无缝连接，这也是 SCSS 相比 LESS 的一个重要优势。

## SCSS vs LESS 强弱对比总结：

**SCSS 更强的地方：**
- 更强大的编程功能（循环、条件判断）
- 更好的模块系统（@use, @forward）
- 更活跃的社区和生态
- 更好的性能（Dart Sass）

**LESS 的优势：**
- 语法更简洁直观
- 基于 JavaScript，前端集成更自然
- 学习曲线更平缓

总的来说，**SCSS 在功能性和生态方面更强**，但 LESS 在简洁性方面有优势。你的代码转换很顺利，因为它主要使用了两者都支持的基础功能。