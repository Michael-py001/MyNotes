## 用turborepo重构

### 可行性结论
- 结论：高度可行。把两个项目收敛进一个 Turborepo monorepo，并将 `bigdata-common_wsl` 重命名为一个 workspace 包（例如 `@sea/map-com`），在开发环境下直接从源码被 `sea-vue` 的 Vite 编译，避免 UMD 打包循环。
- 关键点：
  - 保持生产环境仍可通过 `<script src="/commonJs/bigDataCom/mapCom.umd.min.js">` 使用 UMD 形式（兼容现有部署）。
  - 开发环境用 Vite 的 alias/FS allow 直接编译 `packages/map-com/src` 源码，避免每次重打包。
  - 解决单例依赖与全局对象问题：将 `vue`、`vuex`、`ant-design-vue`、`echarts`、`axios` 等作为 `peerDependencies`，确保全仓库单实例；`Cesium` 继续由 `sea-vue` 的 `index.html` 以全局 `window.Cesium` 注入，不影响。

### 目录与工具链
- 仓库结构（建议）：
  - `apps/sea-vue`：现有的 `sea-vue_wsl`
  - `packages/map-com`：现有的 `bigdata-common_wsl`（重命名）
  - 根目录：`package.json`（workspaces）、`turbo.json`（流水线）、（可选）`pnpm-workspace.yaml`
- 包管理器：推荐 pnpm（更适合 monorepo 下依赖去重和多版本管理）

### 具体改造点（最小侵入）
1) packages/map-com 包规范化
- 重命名 `bigdata-common_wsl` 到 `packages/map-com`，并调整 `package.json`：
  - `name` 改为 `@sea/map-com`
  - 将 `vue`、`vuex`、`ant-design-vue`、`echarts`、`axios` 等转为 `peerDependencies`（并放入 `devDependencies` 供包内开发）
  - 保留现有 CLI 构建产物用于生产（UMD），同时暴露源码入口用于开发（ESM）

示例：
```json
{
  "name": "@sea/map-com",
  "version": "0.1.0",
  "private": false,
  "main": "dist/mapCom.umd.min.js",
  "module": "src/main.js",
  "types": "./dist/index.d.ts",
  "scripts": {
    "dev": "vue-cli-service serve",
    "build": "vue-cli-service build --target lib --inline-vue --name mapCom ./src/main.js",
    "build:watch": "vue-cli-service build --target lib --inline-vue --name mapCom ./src/main.js --watch --clean --mode production"
  },
  "peerDependencies": {
    "vue": "^2.6.14",
    "vuex": "^3.6.2",
    "ant-design-vue": "^1.7.8",
    "echarts": "^5.5.1",
    "axios": "^1.7.7"
  },
  "devDependencies": {
    "vue-template-compiler": "^2.6.14"
  }
}
```

2) 根工作区与 Turbo
- 根 `package.json`（使用 pnpm/yarn workspaces 皆可）：
```json
{
  "name": "sea-monorepo",
  "private": true,
  "packageManager": "pnpm@8.15.0",
  "workspaces": [
    "apps/*",
    "packages/*"
  ],
  "scripts": {
    "dev": "turbo run dev --parallel",
    "build": "turbo run build"
  },
  "devDependencies": {
    "turbo": "^2.0.0"
  }
}
```

- Turbo pipeline：
```json
{
  "$schema": "https://turbo.build/schema.json",
  "pipeline": {
    "dev": {
      "cache": false,
      "persistent": true
    },
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["dist/**"]
    }
  }
}
```

3) apps/sea-vue（Vite）侧直读源码
- 目标：开发环境不再使用 `window.mapCom` 的 UMD，全流程通过 Vite 直接编译 `@sea/map-com/src`。
- 做法 A（推荐，零改后端/部署）：保持生产 UMD 不变，在组件处做“环境分支”异步加载，dev 走源码，prod 走 UMD。
```js
<script>
import Vue from 'vue';

export default {
  components: {
    // {{ AURA: Modify - 开发环境直读源码，生产环境保持 UMD 兼容 }}
    MapsCom: () =>
      new Promise(async (resolve) => {
+       // 开发：直接 import 源码（由 Vite 处理 SFC/TS 等）
+       if (import.meta.env.DEV) {
+         const mod = await import('@sea/map-com/src/main.js');
+         return resolve(mod.default.mapsCom(Vue));
+       }
+       // 生产：继续使用全局 UMD
        resolve(window.mapCom.default.mapsCom(Vue));
      })
  },
  // ... existing code ...
}
</script>
```
- 为了让 Vite 访问外部源码路径，需要允许上层目录并设置别名：
```js
import { fileURLToPath, URL } from 'node:url';
import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue2';
// ... existing imports ...

export default defineConfig({
  // ... existing config ...
  resolve: {
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url)),
+     '@sea/map-com': fileURLToPath(new URL('../../packages/map-com', import.meta.url))
    }
  },
+ server: {
+   fs: {
+     // 允许访问 monorepo 根以及 map-com 包源码
+     allow: [
+       fileURLToPath(new URL('.', import.meta.url)),
+       fileURLToPath(new URL('../../packages/map-com', import.meta.url))
+     ]
+   }
+ }
});
```

4) 依赖单例与样式
- 保证 `apps/sea-vue` 安装了 `@sea/map-com` 的 peer deps（vue、vuex、ant-design-vue、echarts、axios 与版本对齐），pnpm 会在根统一管理。
- CSS：
  - 若 `map-com` 源码内部有 `import './xxx.scss'`，Vite 会直接打包，不再依赖 `<link href="/commonJs/bigDataCom/mapCom.css">`；你可以保留生产的 `<link>` 以兼容 UMD。
  - 如需在 dev 与 prod 行为一致，可在 `map-com/src/main.js` 首行显式 `import './style/mapCom.css'`，并保证样式源码存在。

5) Cesium 全局
- 继续由 `apps/sea-vue/index.html` 注入 `<script src="/commonJs/modules/cesium/Cesium.js">`，`map-com` 使用 `window.Cesium` 即可（开发与生产一致）。不建议把 Cesium 作为 npm 依赖打进包。

### 风险点与规避
- Vite 编译 node_modules 默认不处理 SFC：本方案用 alias 直指源码路径，规避此限制；或可把包名加入 `optimizeDeps.exclude`，但 alias 更稳定。
- 多实例 Vue：通过 `peerDependencies` + workspace 保证全局单例。
- 组件副作用注册（Vue.use）：`map-com/src/main.js` 顶层 `Vue.use()` 在作为源码编译时会执行一次，一般可接受；如需更纯净，可以把 UI 插件注册迁入 `mapsCom(Vue)` 内由上层传入控制。
- API/资源路径：`window.location.origin + url` 这类逻辑在 monorepo 下不变，保持兼容。

### 开发与构建命令（monorepo）
- 启动开发（并行）：
  - `pnpm -w i`
  - `pnpm dev`（Turbo 将并行运行 `apps/sea-vue:dev` 和 `packages/map-com:dev`；`map-com` 的 `dev` 用来本地预览或可直接空跑，关键是源码被 sea-vue 引用）
- 构建：
  - `pnpm build`（Turbo 会先构建 `@sea/map-com` UMD，再构建 `sea-vue`）

如果你同意，我可以下一步：
- 初始化根 `package.json` 与 `turbo.json`；
- 移动两个项目到 `apps/` 和 `packages/`；
- 添加 `vite.config.js` 的 alias/allow；
- 在 `WeatherDetail.vue` 加入“环境分支”的异步组件引入。

## 为什么要使用 '@sea/map-com': fileURLToPath(new URL('../../packages/map-com', import.meta.url))，不是应该在sea-vue的package.json里面引入子包map-com吗



简短回答：可以。用 workspace 依赖在 `package.json` 里引入子包是更标准的做法；我之前给出 alias 指到源码路径，是在“未搭建 monorepo/未链接本地包”的前提下的权衡方案。只要把两个项目合到一个 monorepo（pnpm/yarn workspaces + turborepo）里，就能用包名直接引入，同时让 Vite 编译源码，彻底摆脱每次打 UMD 包。

如何用 package 方式直读源码（推荐配置）
- 根目录（monorepo）：
  - `package.json`（workspaces）和 `turbo.json`。
  - `apps/sea-vue`、`packages/map-com`。
- `packages/map-com/package.json`：
  - 设置双入口，生产走 UMD，开发走源码：
    - `"main": "dist/mapCom.umd.min.js"`
    - `"module": "src/main.js"`（指向源码）
  - 把 `vue`、`vuex`、`ant-design-vue`、`echarts`、`axios` 等放入 `peerDependencies`（并在 `devDependencies` 保留以便包内开发）。
- `apps/sea-vue/package.json`：
  - 依赖声明：`"@sea/map-com": "workspace:*"`（或 `"link:../packages/map-com"`）
- `apps/sea-vue/vite.config.js` 关键点（让 Vite 把 workspace 包当源码编译）：
  - 默认 `preserveSymlinks: false`（保持默认即可）
  - 允许访问包源码路径：
    ```js
    server: {
      fs: {
        allow: [
          fileURLToPath(new URL('../../packages/map-com', import.meta.url))
        ]
      }
    }
    ```
  - 避免预打包吞掉插件处理：
    ```js
    optimizeDeps: {
      exclude: ['@sea/map-com']
    }
    ```
  - 不必须再写 alias；只要 `module` 指向源码，直接 `import '@sea/map-com'` 即可。
- `WeatherDetail.vue` 动态组件（开发走源码，生产走 UMD，保持兼容）：
  ```js
  components: {
    MapsCom: () =>
      new Promise(async (resolve) => {
        if (import.meta.env.DEV) {
          const mod = await import('@sea/map-com'); // module->src/main.js
          return resolve(mod.default.mapsCom(Vue));
        }
        resolve(window.mapCom.default.mapsCom(Vue));
      })
  }
  ```

如果你现在不是 monorepo（你把根的 turbo/workspaces 删掉了）：
- 仅在 `sea-vue/package.json` 里加依赖并不能“直读本地源码”。要么：
  - 建 monorepo（推荐）；要么
  - 用 `pnpm link`/`npm link` 将本地 `map-com` 链接为依赖，然后同样配置 Vite：
    - `optimizeDeps.exclude: ['@sea/map-com']`
    - `server.fs.allow` 指到被链接包的真实路径
    - 保证包 `package.json` 有 `"module": "src/main.js"`

总结
- 用 alias 指源码路径：适合“未搭 monorepo/未 link”的临时方案。
- 用 `package.json` 引入子包名：需要 monorepo 或 link，外加 Vite 配置，优点是工程化更标准、依赖管理更清晰，开发时直接编译源码，无需反复打包。