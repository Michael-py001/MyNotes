# HTML

## 浏览器渲染过程

\> 1. 1.解析HTML，得到一个DOM tree
\2. 2.解析CSS，得到CSSOM tree
\3. 3.将DOM和CSSOM来构造render tree
\4. 4.布局（layout）， 根据Render Tree计算每个节点的位置大小等信息
\5. 5.绘制（Painting ）根据计算好的信息绘制整个页面

# CSS

## flex布局以及其他的布局方式

父元素的6大属性**display:flex**

1. 1.(主轴方向)**flex-derection:row/column/row-reverse/column-reverse**
2. 2.(换行)**flex-wrap: wrap/nowrap/wrap-reverse**
3. 3.简写属性 **flex-flow:flex-derection flex-wrap**
4. 4.更改flex方向 **flex-direction\**\**属性值:row/column/row-reverse/column-reverse**
5. 5.**justify-content**属性用来使元素在主轴方向上对齐**属性值:stretch/flex-start/flex-end/center/space-around/space-between**
6. 6.**align-items**属性用来使元素在侧轴方向上对齐**属性值:center/flex-end/flex-start/stretch/baseline**

子元素的6大属性(flex-item)

1. 1.align-self
2. 2.flex-basis
3. 3.flex-grow
4. 4.flex-shrink
5. 5.order

## 常见布局

圣杯布局:

```
 &lt;style&gt;
    * {
      margin: 0;
      padding: 0;
    }

    .container {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    .header,
    .footer {
      height: 50px;
      background-color: paleturquoise;
    }

    .content {
      flex: 1;
      display: flex;
    }

    .left,
    .right {
      width: 100px;
      background-color: red;
    }

    .middle {
      flex: 1;
      background-color: aqua;
    }
  &lt;/style&gt;
  <div>
    <div>header</div>
    <div>
      <div>left</div>
      <div>middle</div>
      <div>right</div>
    </div>
    <div>footer</div>
  </div>
```

![20200719143317.png](http://img.nanwayan.cn/20200719143317.png)

# JS

## 1.值类型和引用类型

```
//值类型
let a = 100;
let b = a;
a = 200;
console.log(b, a);//100
//引用类型
let a = { age: 20 };
let b = a;
b.age = 21;
console.log(a.age);//21
```

数据类型
七种原始类型`Undefined,Number,Null,String,Boolean,Symbol,BigInt和Object`
`只有0、NaN、null、undefined、"",五个值会变为false`

```
// 1.识别所有值类型
let a; console.log(typeof (a)); //undefined
const str = "abc"; console.log(typeof (str));//string
const n = 100; console.log(typeof (n));//number
const b = true; console.log(typeof (b));//boolean
const s = Symbol("s"); console.log(typeof (s));//symbol
 // 2.识别函数
console.log(typeof (function(){}));//function
 // 3.判断是否是引用类型(不可细分)
console.log(typeof (null));//object
console.log(typeof ({x:100}));//object
```

## 2.深拷贝

```
    function deepClone(obj) {
      if (typeof obj !== "object" || obj == null) {
        //obj不是对象或者是null直接返回
        return obj
      }
      //初始化返回结果
      let result
      if (obj instanceof Array) {
        result = []
      } else {
        result = {}
      }
      for (const key in obj) {
        //保证 key 不是原型的属性
        if (obj.hasOwnProperty(key)) {
          //递归
          result[key] = deepClone(obj[key])
        }
      }
      return result
    }
```

## 3.隐性转换

```
//1.字符串拼接
const a = 100 + 10 //110
const b = 100 + "10" //"10010"
const c = true + "10" //"true10"
//2.==运算符
100 == "100"  //true
0 == "" //true
0 == false //true
false == "" //true
null == undefined //true
//3.truly变量 
!!1 === true
//falsely变量
!!0 === false
```

\##4.假值
Javascript只有6个假值
`0 undefined null NaN "" false`

# instanceof

```
var simpleStr = "This is a simple string"; 
var myString  = new String();
var newStr    = new String("String created with constructor");
var myDate    = new Date();
var myObj     = {};
var myNonObj  = Object.create(null);

simpleStr instanceof String; // 返回 false, 检查原型链会找到 undefined
myString  instanceof String; // 返回 true
newStr    instanceof String; // 返回 true
myString  instanceof Object; // 返回 true

myObj instanceof Object;    // 返回 true, 尽管原型没有定义
({})  instanceof Object;    // 返回 true, 同上
myNonObj instanceof Object; // 返回 false, 一种创建非 Object 实例的对象的方法

myString instanceof Date; //返回 false

myDate instanceof Date;     // 返回 true
myDate instanceof Object;   // 返回 true
myDate instanceof String;   // 返回 false
```

## 闭包

- 闭包是指有权访问另外一个函数作用域中的变量的函数.可以理解为(能够读取其他函数内部变量的函数).
- 闭包的作用: 正常函数执行完毕后,里面声明的变量被垃圾回收处理掉,但是闭包可以让作用域里的 变量,在函数执行完之后依旧保持没有被垃圾回收处理掉.
- 最简单的函数内将函数作为返回值

```
function foo() {
  var name = "kebi";
  return function() {
    console.log(name);
  };
}
var bar = foo();
bar(); //kebi
```

# VUE

## 1.v-if. v-show 的原理和作用是什么，它是如何封装的?

- 共同作用是将元素不可见
- v-if会直接在DOM对标签进行创建或销毁,v-show则是对标签添加display:none
- v-if是惰性的只有当条件为真时才会真正渲染标签；如果初始条件不为真，则v-if不会去渲染标签。v-show则无论初始条件是否成立，都会渲染标签，它仅仅做的只是简单的CSS切换。
- 原理:
- v-if会调用addlfCondition方法，生成vnode的时候会忽略对应节点,render的时候就不会渲染;
- v-show会生成vnode, render的时 候也会渲染成真实节点，只是在render过程中会在节点的属性中修改show属性值,也就
- 是常说的display;

## vue的特性

- 数据响应式
- 组件化