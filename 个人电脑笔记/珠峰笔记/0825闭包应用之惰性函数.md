### JS高阶编程函数——惰性函数

> +懒
>
> +能执行一次的绝对不会执行第二次 

如果我们需要编写一个函数来获取一个元素的信息，用getComputedStyle这个API，且要兼容IE6-8

#### 方案一

> 这样编写，我们每一次执行方法都需要处理兼容：其实这种操作是没必要的，第一次执行已经知道兼容情况了，后期再执行方法（浏览器也没有刷新、也没有换浏览器）兼容校验是没必要处理的

```js
function getCss(element, attr) {
    if (window.getComputedStyle) {
        return window.getComputedStyle(element)[attr];
    }
    // IE6~8
    return element.currentStyle[attr];
}
console.log(getCss(document.body, 'width'));
```

#### 方案二

> 页面一加载就把是否兼容处理了，后期执行方法直接基于变量的值判断使用哪个办法即可

```js
let isCompatible = 'getComputedStyle' in window;
function getCss(element, attr) {
    if (isCompatible) {
        return window.getComputedStyle(element)[attr];
    }
    // IE6~8
    return element.currentStyle[attr];
}
console.log(getCss(document.body, 'width'));
```

#### 方案三——惰性思想

> 惰性函数，就是函数重构的过程，第一次运行就判断是否兼容，如果兼容，则把函数重构成兼容下的写法，如果不兼容，则重构成不兼容的写法，第一次返回是运行一次重构后的方法，把结果返回，后续的运行，则直接运行重构后的方法

```js
function getCss(element, attr) {
    if (window.getComputedStyle) {
        // 把全局的getCss重构成为具体的小函数
        getCss = function (element, attr) {
            return window.getComputedStyle(element)[attr];
        };
    } else {
        getCss = function (element, attr) {
            return element.currentStyle[attr];
        };
    }
    // 重构后首先执行一次：确保第一次调用getCss也可以获取到自己想要的结果
    return getCss(element, attr);
}
console.log(getCss(document.body, 'width'));
// 第二次执行：执行是的重构后的小函数，这样告别了兼容校验的操作
console.log(getCss(document.body, 'padding'));
```

