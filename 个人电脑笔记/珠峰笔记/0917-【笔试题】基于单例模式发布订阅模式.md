## 发布订阅模式

> 创建一个自定义事件池，发布一个计划表，基于on/off向事件池中增删方法，订阅计划/任务，fire就是到达条件，通知计划表中的订阅任务的执行。

<img src="https://i.loli.net/2020/09/17/XMIfuD3aBiyqtve.png" alt="image-20200917231908632" style="zoom:80%;" />

设计模式是一种思想：用来有效管理代码的思想 

### 「经典设计模式：发布订阅」

> 类似于DOM二级事件，
>
> 添加：`div.addEventListener("click",fn1)`；
>
> 删除：`div.removeEventListener("click",fn1)`
>
>  注意：`removeEventListener`使用的必须是外部函数，匿名函数是不能移除的。

发布订阅模式需要自己自定义一个事件池，里面放置事件类型和每一个事件类型需要执行的方法。

#### **事件池的数据结构：**

+ 第一种：`pond = [{"type":click,"func":[fn1,fn2]}]`

+ 第二种：`pund = {type:[fn1,fn2],type2:[fn1.fn2]}` (推荐这种，处理更方便)

#### 代码实现

```js
// subscribe -> sub
let sub = (function () {
    // 自定义事件池
    let pond = {};

    // 关于事件池中方法的管理
    // 向事件池中添加方法
    const on = function on(type, func) {
        // 验证当前事件池中是否存在这个自定义事件:不存在则新增一个
        !pond.hasOwnProperty(type) ? pond[type] = [] : null;
        let arr = pond[type];
        // 重复验证：因为一个事件类型里可能有多个方法，验证是否已经存在，如果存在则不处理
        // if (arr.includes(func)) return;
        for (let i = 0; i < arr.length; i++) {
            if (arr[i] === func) {
                return;
            }
        }
        arr.push(func);
    };
    //从事件池中移除方法
    const off = function off(type, func) {
        let arr = pond[type] || [];
        for (let i = 0; i < arr.length; i++) {
            if (arr[i] === func) {
                // 想要移除的
                // arr.splice(i, 1);//splice会改变数组长度

                // 防止数组塌陷，实现当前项的假删除
                arr[i] = null;
                break;
            }
        }
        // arr = arr.filter(item => item !== func);
    };
    //通知事件池中指定的方法执行
    const fire = function fire(type, ...params) {
        let arr = pond[type] || [];
        // 命令式编程
        for (let i = 0; i < arr.length; i++) {
            let item = arr[i];
            if (typeof item === "function") {
                // 把传进来的参数，放到每一个函数里执行
                item(...params);
                continue;
            }
            // 如果当前项是null，在这里把它删除
            arr.splice(i, 1);
            i--;
        }
        // arr.forEach(item => item(...params));
        // 函数式编程：不在乎过程如何实现，只关注结果。把实现功能的方法封装好了，用的时候调用就好。"高内聚，低耦合，提高开发效率"
        // 命令式编程：自己把控过程，我们可以在过程中灵活处理。
        // 例如遍历一个数组，如果中间件没有其他处理，用函数式最好，如果中间需要处理某些东西，则命令式最好。
    };

    // 暴露API
    return {
        on,
        off,
        fire
    };
})();
//模拟执行
let box = document.querySelector('#box');
//通知指定事件执行
box.onclick = function (ev) {
    sub.fire('@A', 10, 20, ev);
};
//自己写的方法
function fn1(x, y, ev) {
    console.log(1, x, y, ev);
}
sub.on('@A', fn1); //添加该方法到事件池

function fn2() {
    console.log(2);
    sub.off('@A', fn1); //在fn2中执行off移除了fn1方法，在@A事件中的方法数组arr中的length会减1，而接下来执行fn3时，循环中的i，还是按原来的i,删除项后面的每一项的index都提前了一位，导致执行方法错误，这就是数组塌陷
    sub.off('@A', fn2);
}
sub.on('@A', fn2);

function fn3() {
    console.log(3);
}
sub.on('@A', fn3);

```

#### 函数式编程&命令式编程

- **函数式编程：**
  - 不在乎过程如何实现，只关注结果。
  - 把实现功能的方法封装好了，用的时候调用就好。"高内聚，低耦合，提高开发效率"

- **命令式编程：**
  - 自己把控过程，我们可以在过程中灵活处理。
  - 例如遍历一个数组，如果中间件没有其他处理，用函数式最好，如果中间需要处理某些东西，则命令式最好。

#### 数组塌陷问题

​	上面的例子中，在fn2中执行off移除了fn1方法，在@A事件中的方法数组arr中的length会减1，而接下来执行fn3时，循环中的i，还是按原来的i,删除项后面的每一项的index都提前了一位，导致执行方法错误，这就是数组塌陷

####  扩展：基于面向对象的思想实现发布订阅

```js
 //jQuery里的发布订阅模式
 let $plan=$.Callbacks();
 $plan.add(fn1);
 $plan.remove(fn2);
 $plan.fire() 
```

