### 面向对象作业详解

一、输出结果

```js
function fun() {
    this.a = 0;
    this.b = function () {
        alert(this.a);
    }
}
fun.prototype = {
    b: function () {
        this.a = 20;
        alert(this.a);
    },
    c: function () {
        this.a = 30;
        alert(this.a)
    }

}
var my_fun = new fun();
console.log(my_fun);
my_fun.b(); //因为和fun里的私有属性同名，调用的是fun里的this.b
console.log(my_fun);
my_fun.c();
console.log(my_fun);
```

二、

```js
function C1(name) {
    if (name) {
        this.name = name;
    }
}

function C2(name) {
    this.name = name;
}

function C3(name) {
    this.name = name || 'join';
}
C1.prototype.name = 'Tom';
C2.prototype.name = 'Tom';
C3.prototype.name = 'Tom';
alert((new C1().name) + (new C2().name) + (new C3().name));
//Tom-->没有传参name,条件不成立，所以不会执行if里面的代码，.name是外面在prototype设置的Tom
//undefined-->没有传参name,所以this.name设置的是undefined
//join-->没有传参name,所以执行||后面的join
```

三、

```js
function Fn() {
    let a = 1;
    this.a = a;
}
Fn.prototype.say = function () {
    this.a = 2;
}
// Fn.prototype = new Fn;
let f1 = new Fn
Fn.prototype.b = function () {
    this.a = 3;
};
console.log(f1.a); //1
console.log(f1.prototype); //undefined 实例没有prototype
console.log(f1.b); //fcuntion(){this.a=3}
console.log(f1.hasOwnProperty('b')); //false 不是自己私有属性
console.log('b' in f1); //ture  in判断共有私有只要有都是true
console.log(f1.constructor == Fn); //true 判断f1是否是Fn类的实例
console.log(f1);
```

四、

```js
function Foo() {
    getName = function () {
        console.log(1);
    };
    return this;
}
Foo.getName = function () {
    console.log(2);
};
Foo.prototype.getName = function () {
    console.log(3);
};
var getName = function () {
    console.log(4);
};

function getName() {
    console.log(5);
}
Foo.getName(); //2
getName(); //4
Foo().getName(); //运行完Foo()返回this是window，而且里面的getName覆盖了原来全局的getName, window.getName()-->1
getName(); //1
new Foo.getName(); //优先级问题，先运行Foo.getName()->2 new Function(){-->2} -->2
new Foo().getName(); //3 同优先级，从左往右运行，先运行new Foo(),返回一个实例X, x.getName()-->查找的是x原型链上的getName-->找到类上的Foo.prototype.getName，输出3
new new Foo().getName(); //3
```

五、

```js
let n = 10;

Number.prototype.plus = function (x) {
    return this + x
}
Number.prototype.minus = function (y) {
    return this - y
}
//实现以下代码输出
let m = n.plus(10).minus(5);
console.log(m); //=>15（10+10-5）
```

六、

```js
/*
 * 编写queryURLParams方法实现如下的效果（至少两种方案）
 */
// let url = "http://www.zhufengpeixun.cn/?lx=1&from=wx#video";
// console.log(url.queryURLParams("from")); //=>"wx"
// console.log(url.queryURLParams("_HASH")); //=>"video"
//自己的答案：
let url = "http://www.zhufengpeixun.cn/?lx=1&from=wx#video";

String.prototype.queryURLParams = function queryURLParams(key) {
    let wenhaoIndex = this.indexOf('?')
    let jinghaoIndex = this.indexOf('#')
    let paramsString = this.slice(wenhaoIndex + 1, jinghaoIndex)
    let eachParms = paramsString.split('&')
    let obj = {}
    eachParms.forEach((item, index) => {
        let keyValue = item.split('=')
        obj[keyValue[0]] = keyValue[1]
    })
    let hash = url.slice(jinghaoIndex + 1)
    obj._HASH = hash
    return key ? obj[key] : obj
}

console.log(url.queryURLParams("from")); //=>"wx"
console.log(url.queryURLParams("_HASH")); //=>"video"
```

七、重构类

```js
//7. 基于ES6中的class重构下面的代码

function Modal(x, y) {
    this.x = x;
    this.y = y;
}
Modal.prototype.z = 10;
Modal.prototype.getX = function () {
    console.log(this.x);
}
Modal.prototype.getY = function () {
    console.log(this.y);
}
Modal.n = 200;
Modal.setNumber = function (n) {
    this.n = n;
};
let m = new Model(10, 20);
//My答案:
 class Modal {
    //私有属性
    constructor(x, y) {
        this.x = x;
        this.y = y
    }
    //原型上的“公共方法”
    getX() {
        console.log(this.x)
    }
    getY() {
        console.log(this.y)
    }
    //把其当作普通对象设置“静态”属性和方法
    static n = 200;
    static setNumber = function (n) {
        this.n = n
    }

} 
// 原型属性需要写在外面
Modal.prototype.z = 10;
let m = new Modal(10, 20);
console.log(m);
console.dir(Modal) 
```

八、

```js
//8、代码输出的结果

Array.prototype.push = function push(value) {
    // 内部运行机制
    // 1.把value放到末尾
    this[this.length] = value;
    // 2.上述代码完成后，数组的Length自动会增加
    this.length++ //自己需要知道有这个自增的过程
}
let obj = {
    2: 3,
    3: 4,
    length: 2,
    push: Array.prototype.push
}
obj.push(1);
//相当于obj[obj.length] = 1  //按照数组的Push把1放到obj末尾
//而obj.length = 2 ,==>obj[2] = 1-->把obj里属性为2的值 改为1 -->obj={2:1,...}
//里面默认的length会自增1  -->length=3
obj.push(2);
//obj[obj.length]=2 -->obj[3]=2-->length自增1，obj={2:1,3:2,length:4}
console.log(obj);
```

九、

```js
//9. a等于什么值会让下面条件成立

var a = ?;
if (a == 1 && a == 2 && a == 3) {
    console.log('OK');
}

// 方案一：
var a = {
    value: 0,
  //按照对象类型转换为数字机制，Symbol.toPrimitive->valueof->toString有任意一种就可以调用自己的私有方法
    // valueOf / toString
    [Symbol.toPrimitive](hint) {
        // 浏览器调取这个方法的时候会传递一个hint：存储当前对象即将转换为什么值
        // + default:可能转换为数字或者字符串，例如：==比较或者加号运算
        // + number:一定是要转换为数字的，例如：减乘除等数学运算中
        // + string:一定是要转换为字符串的，例如：字符串拼接
        //可以根据hint的值做不同的判断：数字，字符串，这里是与数字比较，所以按照数字的来运算++this.value
        return ++this.value;
    }
};
// 根据数据类型转换的思想，另外的方法：
let a = [1, 2, 3];
a.toString = a.shift;
if (a == 1 && a == 2 && a == 3) {
    console.log('OK');
}
/* 方案二：利用数据劫持 Object.defineProperty / Proxy */
// 如果a不是全局变量，则再看是否为window的一个属性...
let i = 0;
Object.defineProperty(window, 'a', {
    //调取a的时候浏览器会触发get()
    get() {
        // window.a 触发GETTER函数
        return ++i;
    },
    //设置a的值时会触发set()
    set(value) {
        // window.a=xxx 触发SETTER函数
    }
});
if (a == 1 && a == 2 && a == 3) {
    console.log('OK');
}
```

十、

```js
//10. 实现如下需求

let utils = (function () {
    /*
     * toArray：转换为数组的方法
     *   @params
     *      不固定数量，不固定类型
     *   @return
     *      [Array] 返回的处理后的新数组
     * by zhufengpeixun on 2020
     */
    function toArray(...args) {
        //=>实现你的代码（多种办法实现）
        //1、
        return args
        //2、
        // return Array.from(arguments); //ES2015
        //3、
        // return [...arguments]; //ES6中的展开运算符
        //4、兼容写法
        /* let arr = [];
        for (let i = 0; i < arguments.length; i++) {
            arr.push(arguments[i]);
        }
        return arr; */
        //5、JS中的“鸭子”类型，arguments本身不是数组类型，但是借用了[]空数组里的方法，只是把slice里面的this改成arguments运行
        return [].slice.call(arguments);
    }
    return {
        toArray
    };
})();
let ary = utils.toArray(10, 20, 30); //=>[10,20,30]
console.log(ary);
ary = utils.toArray('A', 10, 20, 30); //=>['A',10,20,30]
```

