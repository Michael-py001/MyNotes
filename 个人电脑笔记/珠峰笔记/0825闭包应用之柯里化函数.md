### JS高阶函数：柯理化函数

> +预处理思想
>
> +应用的也是闭包的机制

从一道面试题入手：

```js
//需要实现一个函数，按下面的代码执行，输入如下结果
let res = fn(1, 2)(3);
console.log(res); //=>6  1+2+3 
```

#### 柯里化函数

> 第一次执行大函数，形成一个闭包（原因：返回一个小函数），把一些信息存储到闭包中（传递的实参信息或当前闭包中声明的一些私有变量等信息）；等到后面需要把返回的小函数anonymous执行，遇到一些非自己私有变量，则向其上级上下文中中查找（也就是把之前存储在闭包中的信息获取到）；

```js
function fn(...outerArgs) {
    // outerArgs存放第一次执行fn传递的实参信息 [1,2]

    return function anonymous(...innerArgs) {
        // innerArgs存放第二次执行匿名函数传递的实参信息 [3]

        let arr = outerArgs.concat(innerArgs);
        // let arr=[1,2,3];
        return arr.reduce(function (total, item) {
            return total + item;
        });
    };
}
```

