# vue代码渲染编辑器

## 兄弟组件之间 传递信息的方法

### 通过$parent当中间件桥梁

> 子组件中使用`$parent`当做中间桥梁，在父组件上发布&订阅事件，实现兄弟组件通信。

`Parent.vue`引用并使用两个子组件，把这两个子组件当做兄弟组件。

```js
import Son from "./Son";
import Son2 from "./Son2";
```

`Son.vue`生命周期函数中，监听一个事件：

```js
 mounted(){//生命周期函数
        this.$parent.$on("test",function(data){
            //data是从Son2.vue中通过$emit()的第二个参数传过来的，实现兄弟间传递数据
            console.log(data);
        })
    },
```

`Son2.vue`触发这个事件：

```js
mounted(){//生命周期函数
        this.$parent.$emit("test",1000)//把1000的参数传了过去
    }
```

也就是说，在两个子组件上，通过$parent操作父组件，在父组件上$on监听和$emit触发相应的事件，可以实现把数据传递到兄弟组件中。

### 子组件1传给父组件，父组件再传给子组件2

子组件1：

> 子组件上监听`input`事件，用户输入字符后，会触发事件并且执行`handleInput`方法，在方法里通过`this.$emit("input", this.code);`通知父组件，并且携带了参数。

```html
<template>
  <div class="edit">
    <main class="edit-box">
      <!-- v-model就是value属性和input事件的语法糖，这里拆开使用 ;input事件传递给父组件-->
      <textarea :value="code" @input="handleInput"></textarea>
    </main>
  </div>
</template>

<script>
export default {
  data() {
    return {
      code: "",
    };
  },
  methods: {
    handleInput(e) {
      this.code = e.target.value;
      this.$emit("input", this.code);
    },
  },
};
</script>
```

父组件：

> 接收到子组件的$emit通知后，得知是`input`事件，随即执行`handleEditInput`方法，并且把接收到的参数更新到data中的`editCode`，这样就可以更新`Show`子组件2上的数据了。

```vue
<template>
  <div id="app">
    <Edit
      @input="handleEditInput"
      @run="handleRun"
      @clear="clearShowCode"
    ></Edit>
    <Show :codeText="editCode" ref="show"></Show>
  </div>
</template>
<script>
export default {
      data() {
        return {
          editCode: "",
        };
      },
    methods: {
        // 子组件传过来的value
        handleEditInput(value) {
          this.editCode = value;
        },
        handleRun() {
            // 方法一：通过$childern选中子组件，然后让子组件上的方法执行
            console.log(this.$children);
            if (this.editCode) {
                this.$children[1].renderCode();
            }
            return;

            // 方法二：通过$refs 让子组件上的方法执行
            // this.$refs["show"].renderCode();
            // this.$refs.show.renderCode();
        },
    },
}
</script>
```

## 父组件通知子组件上的方法执行

### 方法一：通过$childern选中子组件，然后让子组件上的方法执行

```js
 this.$children[1].renderCode();
```

### 方法二：通过$refs 让子组件上的方法执行

```js
this.$refs["show"].renderCode();
this.$refs.show.renderCode();
```



## v-model：value属性和input事件的语法糖

```html
<textarea
    :value="code"
    @input="handleInput"
    class="topnav_box"
    ref="textarea"
></textarea>
<!-- 等价于-->
<textarea
 v-model="code"
 class="topnav_box"
 ref="textarea"
></textarea>
```



## 正则表达式知识点

> JS中创建正则表达式有两种方法，第一种是创建正则对象`new RegExp`，第二种简写方法:`/^xxx$/`

### 语法

- 模式描述了一个表达式模型。
- 修饰符(modifiers)描述了检索是否是全局，区分大小写等。

```js
var patt=new RegExp(pattern,modifiers);

或更简单的方法

var patt=/pattern/modifiers;
```

### 注意事项

当使用构造函数创造正则对象时，需要常规的字符转义规则（在前面加反斜杠 \）。比如，以下是等价的：

```js
var re = new RegExp("\\w+");
var re = /\w+/;
```

```js
let scriptReg = new RegExp(`export default\\s*{`); // \s代表空白字符
let scriptReg = /export default\s*{((.|\n)*)};?/; // \s* 代表匹配空白字符0或多个
```

### RegExp 修饰符

> 修饰符用于执行不区分大小写和全文的搜索。

- **i** - 修饰符是用来执行不区分大小写的匹配。

- **g** - 修饰符是用于执行全文的搜索（而不是在找到第一个就停止查找,而是找到所有的匹配）。

- 实例 1
  在字符串中不区分大小写找"runoob"

  ```js
  var str = "Visit RUnoob";
  var patt1 = /runoob/i;
  ```

  

- 实例 2
  全文查找 "is"

  ```js
  var str="Is this all there is?";
  var patt1=/is/g;
  ```

  

- 实例 3
  全文查找和不区分大小写搜索 "is"

  ```js
  var str="Is this all there is?";
  var patt1=/is/gi;
  ```

  

## 正则中的方法

### 1. test()

> test()方法搜索字符串指定的值，根据结果并返回真或假。

```js
var patt1=new RegExp("e");
document.write(patt1.test("The best things in life are free"));
```

由于该字符串中存在字母 "e"，以上代码的输出将是：true

### 2. exec()

> exec() 方法检索字符串中的指定值。返回值是被找到的值。如果没有发现匹配，则返回 null。

```js
var patt1=new RegExp("e");
document.write(patt1.exec("The best things in life are free"));
```

由于该字符串中存在字母 "e"，以上代码的输出将是：e

## String方法中支持正则的方法

### 1. match()

> match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。

#### 语法

`string.match(regexp)`

#### 参数值：正则对象

| 参数     | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| *regexp* | 必需。规定要匹配的模式的 RegExp 对象。如果该参数不是 RegExp 对象，则需要首先把它传递给 RegExp 构造函数，将其转换为 RegExp 对象。 |

#### 返回值：数组

| 类型  | 描述                                                         |
| :---- | :----------------------------------------------------------- |
| Array | 存放匹配结果的数组。该数组的内容依赖于 regexp 是否具有全局标志 g。 如果没找到匹配结果返回 *null* 。 |

#### 案例：

```js
判断是否微信浏览器:

function is_weixn(){  
    var ua = navigator.userAgent.toLowerCase();  
    if(ua.match(/MicroMessenger/i)=="micromessenger") {  
        return true;  
    } else {  
        return false;  
    }  
}
```

```js
在字符串中查找 "ain":

var str="The rain in SPAIN stays mainly in the plain"; 
var n=str.match(/ain/g);
n 输出数组结果值:

ain,ain,ain
```

**注意**： match() 方法将检索字符串 String Object，以找到一个或多个与 regexp 匹配的文本。这个方法的行为在很大程度上有赖于 regexp 是否具有标志 g。如果 regexp 没有标志 g，那么 match() 方法就只能在 stringObject 中执行一次匹配。如果没有找到任何匹配的文本， match() 将返回 null。否则，它将返回一个数组，其中存放了与它找到的匹配文本有关的信息。

### 2. replace()

> replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。

#### 语法

`string.replace(searchvalue,newvalue)`

`str.replace(reg,function(){}) `

#### 参数值

| 参数          | 描述                                                         |
| :------------ | :----------------------------------------------------------- |
| *searchvalue* | 必须。规定子字符串或要替换的模式的 RegExp 对象。 请注意，如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换为 RegExp 对象。 |
| *newvalue*    | 必需。一个字符串值。规定了替换文本或生成替换文本的函数。     |

#### 返回值

| 类型   | 描述                                                         |
| :----- | :----------------------------------------------------------- |
| String | 一个新的字符串，是用 replacement 替换了 regexp 的第一次匹配或所有匹配之后得到的。 |

### replace()中的$符号

> $1--$9 是RegExp 自带的，代表的是分组，即小括号里面的正则捕获到的内容。 test() exec() str.replace() 都会有。

`/^(\d{4})[\/-](\d{1,2})[\/-](\d{1,2})$/`
比如这个简单的匹配年月日的正则，我们就可以通过 $1 $2 $3 获取到并进行处理。



## 子组件中如何获取Vue类？

有时候我们需要在组件中获取到Vue类，创建一个vue的实例。

如果在父组件上，可以直接获取Vue类，但是子组件上不能直接获取到。这时使用this.$option._base就可以获取到Vue这个类了；

通过在子组件上输出：`console.log(this.$options)`，在其原型链上的`_base`可以获取到Vue类。获取到后就可以使用`Vue.extend()`创造一个Vue的子类了。

![image-20210304010606279](https://i.loli.net/2021/03/04/NdqYH98gWlPQpvB.png)

Vue.extend(component)构造一个vue的子类；

new Vue.extend(component)创建一个子类的实例；

this.$option._base可以获取到Vue这个类

## 模拟组件component对象，借助Vue.extend(component)渲染component组件

### [Vue.extend( options )](https://cn.vuejs.org/v2/api/#Vue-extend)

- **参数**：

  - `{Object} options`

- **用法**：

  使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。

  `data` 选项是特例，需要注意 - 在 `Vue.extend()` 中它必须是函数

  ```
  <div id="mount-point"></div>
  ```

  ```js
  // 创建构造器
  var Profile = Vue.extend({
    template: '<p>{{firstName}} {{lastName}} aka {{alias}}</p>',
    data: function () {
      return {
        firstName: 'Walter',
        lastName: 'White',
        alias: 'Heisenberg'
      }
    }
  })
  // 创建 Profile 实例，并挂载到一个元素上。
  new Profile().$mount('#mount-point')
  ```

  结果如下：

  ```html
  <p>Walter White aka Heisenberg</p>
  ```

### vm.$mount( [elementOrSelector] )

- **参数**：

  - `{Element | string} [elementOrSelector]`
  - `{boolean} [hydrating]`

- **返回值**：`vm` - 实例自身

- **用法**：

  如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。可以使用 `vm.$mount()` 手动地挂载一个未挂载的实例。

  如果没有提供 `elementOrSelector` 参数，模板将被渲染为文档之外的的元素，并且你必须使用原生 DOM API 把它插入文档中。

  这个方法返回实例自身，因而可以链式调用其它实例方法。

- **示例**：

  ```js
  var MyComponent = Vue.extend({
    template: '<div>Hello!</div>'
  })
  
  // 创建并挂载到 #app (会替换 #app)
  new MyComponent().$mount('#app')
  
  // 同上
  new MyComponent({ el: '#app' })
  
  // 或者，在文档之外渲染并且随后挂载
  var component = new MyComponent().$mount()
  document.getElementById('app').appendChild(component.$el)
  ```



### 把JS代码添加到模拟的component中

1. 首先，模拟component对象：

   ```js
   let component = {}; //模拟一个组件的大对象，最终这个对象里会像是输出组件里的内容
   ```

   

2. 把通过正则匹配到的JS代码字符串，与return拼接， 把里面的代码拼接成一个对象形式，加return是为了添加到Function里运行

   ```js
    //提取出js代码中的export default里面的部分
           if (type === "script") {
             // 当使用构造函数创造正则对象时，需要常规的字符转义规则（在前面加反斜杠 \）普通简写：var re = /\w+/;则不用
             //   let scriptReg = new RegExp(`export default\\s*{`); //与下面等价
             let scriptReg = /export default\s*{((.|\n)*)};?/; // \s* 代表匹配空白字符0或多个
             let scriptCode = firstMatchCode.match(scriptReg);
             let matchCode = scriptCode[1];
             console.log(matchCode);
             //   把里面的代码拼接成一个对象形式，加return是为了添加到Function里运行
             return `return {${matchCode}}`;
           }
   ```

   

3. 把代码放入Function里运行，得到一个个对象

   ```js
   if (script) {
           //   把代码放入Function里运行，得到一个个对象
           component = new Function(script)();
         }
   ```

这时，component中，已经有了data, component, methods等方法了。



### 转换template模板成真实标签

首先，把template属性添加到component:

```js
component.template = template;
```

核心代码：

- 借助Vue.extend()方法，我们可以传入各项参数，比如template，即可生成一个子类，然后通过new 生成一个子类实例，相当于一个vm，上面有各种方法可以调用。

```js
let myVueComponent = new (this.$options._base.extend(component))()
myVueComponent.$mount()  没有传入参数，将挂载到内存中，这个方法返回实例自身，因而可以链式调用其它实例方法。
myVueComponent.$mount().$el 可以获取到子类把template模板转换成标签的内容
```

比如：

```html
<template>
  <!-- 在这输入template模板 -->
  <div class="test">
    666
    <button @click="fn">按钮</button>
  </div>
</template>
```

就可以转换为真实的DOM标签：

```html
<div class="test">
    666
    <button>按钮</button>
  </div>
```

这里需要配置vue.config.js 设置CLI的runtimeCompiler: true，允许运行时编译。

处理template代码：

```js
   if (template) {
        component.template = template;
        // 需要把template挂载到DOM上，通过$mount方法手动挂载
        // 使用vm.$mount 首先需要获取到实例vm
        // main.js中render: h => h(App) 中的App只是一个对象，需要new Vue()，才能产生一个实例
        // 使用基础 Vue 构造器，创建一个“子类”：Vue.extend(component)构造一个vue的子类（继承于Vue），new Vue.extend(component)创建一个子类的实例
        //this.$option._base可以获取到Vue这个类
        console.log(this.$options);
        let myVueComponent = new (this.$options._base.extend(component))(); //创建子类的实例，后面需要包起来成为一个整体，不然会直接new this
        // vm.$mount()返回值：vm - 实例自身，所以可以继续链式调用其他实例方法
        console.log(myVueComponent.$mount()); //
        console.log(myVueComponent.$mount().$el);
        //myVueComponent.$mount()不加参数：挂载到内存中，加了就挂载到对应的标签中

        // myVueComponent.$mount().$el 把挂载的结果挂载到$el上，$el就是nodeElement对象标签
        // 需要配置vue.config.js 设置CLI的runtimeCompiler: true，允许运行时编译
        this.isShow = true;
        // 解决TypeError: Cannot set property 'innerHTML' of undefined的问题
        // 在Dom跟新了再进行节点插入
        this.$nextTick(() => {
          this.$refs.showBox2.innerHTML = ""; //每次点击运行，都会清空showBox的内容
          this.$refs.showBox2.appendChild(myVueComponent.$mount().$el); //添加到div中
        });
      }
```

### 把CSS样式添加到页面中

```js
     if (style) {
        let newStyle = style.replace(/[\r\n]/g, "");
        let element = document.createElement("style");
        element.type = "text/css";
        element.innerText = newStyle;
        document.body.appendChild(element);
      }
```

##  runtimeCompiler

> https://cli.vuejs.org/zh/config/#runtimecompiler

- Type: `boolean`

- Default: `false`

  是否使用包含运行时编译器的 Vue 构建版本。设置为 `true` 后你就可以在 Vue 组件中使用 `template` 选项了，但是这会让你的应用额外增加 10kb 左右。

  更多细节可查阅：[Runtime + Compiler vs. Runtime only](https://cn.vuejs.org/v2/guide/installation.html#运行时-编译器-vs-只包含运行时)。

## Codemirror的使用

> https://codemirror.net/doc/manual.html#config 官方文档

## 最终效果展示

![image-20210304033139259](https://i.loli.net/2021/03/04/joZlkEXnfR2h8Wq.png)

运行代码：

![image-20210304033207146](https://i.loli.net/2021/03/04/Fv3DcJzQsSnAPqK.png)

