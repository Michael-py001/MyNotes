## 浏览器的底层渲染机制

### 目录

[TOC]

### 浏览器解析代码步骤

​		客户端从服务器获取到需要渲染页面的源代码后，开辟一个“GUI渲染线程”，自上而下解析代码，最后绘制出对应的页面。自上而下渲染解析代码的过程是“同步”的，但是有些操作也是异步的

### 关于CSS资源的加载

- 遇到的是`<style> `“内嵌样式”
  “同步” 交给GUI渲染线程解析

- 遇到的是`<link> `“外链样式”

  - “异步” 开辟一个新的“HTTP网络请求线程”　，注意：同一个源下，根据不同的浏览器，最多只允许同时开辟4～7个HTTP线程 “HTTP的并发数”

  - 不等待资源信息请求回来，GUI渲染线程继续向下渲染
  - GUI渲染线程同步操作都处理完成后，再把基于HTTP图片络线程请求回来的资源文件进行解析渲染

- 遇到`@import `“导入式样式”

  - “同步” 开辟一个新的“HTTP网络请求线程”去请求资源文件
  - 但是在资源文件没有请求回来之前，GUI渲染线程会被“阻塞”，不允许其继续向下渲染

### 遇到`<script>`资源的请求

- `<script>`默认都是**“同步”**的：必须基于HTTP网络线程，把资源请求回来之后，并且交给“JS渲染线程”渲染解析完成后，GUI渲染线程才能继续向下渲染，所以`<script>`默认也是“阻碍GUI渲染”的.
- `async属性-「把默认的同步改为“异步”」`：遇到`<script async>`首先也是开辟一个HTTP网络线程去请求加载资源文件，与此同时GUI渲染线程继续向下渲染，但是一旦当资源请求回来后，**会中断GUI的渲染**，先把请求回来的JS进行渲染解析
- `defer属性-「“异步”」`：遇到`<script defer> `和`async`类似，都是新开辟HTTP网络线程去请求加载资源文件，与此同时GUI还会继续渲染，但是不一样的地方是，defer和link类似，**是在GUI同步的代码渲染完成后**，才会渲染解析请求回来的JS代码

### 遇到`<img>`或者`<audio>`等音视频资源

​		**「“异步”」**-- 遇到这些资源，也会发送新的HTTP网络线程，请求加载对应的资源文件，**不会阻碍**GUI的渲染；当GUI渲染完成后，才会把请求回来资源信息进行渲染解析；

### Webkit浏览器预测解析

​		chrome的预加载扫描器html-preload-scanner通过扫描节点中的 “src” , “link”等属性，找到外部连接资源后进行预加载，避免了资源加载的等待时间，同样实现了提前加载以及加载和执行分离

### 页面渲染的步骤

#### 	1. DOM TREE（DOM树）

​		自上而下渲染完页面，整理好整个页面的DOM结构关系
![image-20200917182446569](https://i.loli.net/2020/09/17/LobiBuT46GVxID3.png)

#### 	2. CSSOM TREE（样式树）

​		当把所有的样式资源请求加载回来后，按照引入CSS的顺序，依次渲染样式代码，生成样式树
![image-20200917182513907](https://i.loli.net/2020/09/17/ETKS2AlGI8nmWoa.png)

####   3. RENDER TREE（渲染树）

​		把生成的DOM树和CSSOM树合并在一起，生成渲染树（设置display:none的元素不进行处理）
![image-20200917182523154](https://i.loli.net/2020/09/17/YDkPmeQCxt5Bial.png)

#### 4. Layout 布局/回流/重排

​		根据生成的渲染树，计算它们在设备视口(viewport)内的确切位置和大小

#### 5. 分层处理

​		按照层级定位分层处理，每一个层级都有会详细规划出具体的绘制步骤

#### 6. 绘制(Painting)

​		按照每一个层级计算处理的绘制步骤，开始绘制页面

#### 总结步骤：

- 处理 HTML 标记，构建 DOM 树
- 处理 CSS 标记，构建 CSSOM 树
- 将 DOM 树和 CSSOM 树融合成渲染树
- 根据生成的渲染树，计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流 => 布局（Layout）或 重排（reflow）
- 根据渲染树以及回流得到的几何信息，得到节点的绝对像素 => 绘制（painting）
  ![image-20200917182613879](https://i.loli.net/2020/09/17/lqT4CvcSJrP73VA.png)

### 前端性能优化 「CRP：关键渲染路径」

#### 	生成DOM TREE

- 减少DOM的层级嵌套
- 使用语义化标签，不要使用“非标准”的标签

#### 生成CSSOM

- **尽可能不要使用`@import`**（阻塞GUI渲染）
- 如果CSS代码比较少，尽可能使用“**style内嵌样式**”（尤其是移动端开发）
- 如果使用`link`，**尽可能把所有的样式资源合并为一个**，且压缩（减少HTTP请求数量，因为HTTP的并发性也是有限制的，以及渲染CSS的时候，也不需要再计算依赖关系...）
- **CSS选择器链短一些**（因为CSS选择器渲染是从右到左的）
- **把link等导入CSS的操作放在HEAD中**（目的是：一加载页面就开始请求资源，同时GUI去生成DOM树 “CSS等资源预先加载”）

#### JS和图片资源加载的优化

##### 避免阻塞的JS加载

- 对于<script>，尽可能放置在页面的底部（防止其阻塞GUI的渲染）；对于部分<script>需要使用async或者defer；
- async是不管JS的依赖关系的，哪一个资源先获取到，就先把这个资源代码渲染执行

- defer不会这样的，和link一样，是等待所有<script defer>都请求回来后，按照导入顺序/依赖关系依次渲染执行的 

##### 图片`<img>`加载 优化

- **懒加载**：第一次加载页面的时候不要加载请求图片，哪怕它是异步的，但是也占据了HTTP并发的数量，导致其他资源延后加载
- **图片的BASE64**：不用去请求加载图片，BASE64码基本上代表的就是图片，而且页面渲染图片的时候速度也会很快（慎用，但是在webpack工程化中可以使用，因为它基于file-loader可以自动base64）

#### 减少DOM的“回流/重排”和重绘(Repaint &Reflow)

>  Layout/Painting：重要的优化手段（减少DOM的“回流/重排”和重绘）

- [x] 重绘：元素样式的改变（但宽高、大小、位置等不变）
  如outline,visibility color.background-color等

- [x] 回流:元素的大小或者位置发生了变化(当页面布局和几何信息发生变化的时候触发了重新布局，导致渲染树重新计算布局和渲染。

  ​         如：

  - 添加或删除可见的DOM元素、
  - 元素的位重发生变化、
  - 元素的尺寸发生变化、
  - 内容发生变化(比如文本变化或图片被另一个不同尺寸的图片所替代、
  - 页面一开始渲染的时候(这个无法避免)
  - 浏览器的窗口尺寸变化也会引发回流，因为回流是根据视口的大小来计算元素的位置和大小的

  **注意：回流一定会触发重绘,而重绘不一定会回流**

- [x] **放弃传统操作DOM的时代**，基于Vue/React开始数据影响视图模式
  mvvm / mvc / virtual DOM / DOM diff

- [x] **分离读写操作**(现代的浏览器都有渲染队列的机制)
  `offsetTop`、`offsetLeft` 、`offsetWidth` 、`offsetHeight `、`clientTop`、 `clientLeft`、 `clientWidth`、 `clientWidth`、 `clientHeight`、 `scrollTop`、 `scrollLfet`、 `scrollWidth`、 `scrollHeight`、 `getComputedStyle`、 `currentStyle`...会刷新渲染队列

  ```js
  box.style.width = "100px";
  box.style.height = "200px";
  box.style.position = "absolute";
  box.style.top = "100px";
  //获取样式和上面的修改样式分离开，因为遇到浏览器渲染队列机制以上的代码会一次性修改，而如果中间件遇到了div.offset等获取样式会发生刷新渲染队列，导致多次回流
  box.offsetHeight;
  ```

  例子二：

  ```js
  setTimeout(() => {
      // 立即回到left:0的位置
      box.style.transitionDuration = '0s';
      box.style.left = 0;
  
      // 刷新渲染队列（会增加一次回流）
      box.offsetLeft;
  
      // 回到开始位置后，再次运动到left:200位置(有动画)
      box.style.transitionDuration = '0.5s';
      box.style.left = '200px';
  }, 1000);
  ```

  

- [x] 样式集中改变

  div.style.cssText = 'width:20px; height:20px;'

  divclassName = 'box';

- [x] 缓存布局信息

  ```
  div.style.left = div.offset.left + 1 + 'px';
  
  div.style.top = div.offsetTop + 1 + 'px';
  ```

  改为==>

  ```
  var curLeft = div.offsetLeft ; var curTop = div.offsetTop;
  
  div.style/left = curLeft + 1 + 'px'; div.style.top = curTop + 1 + 'px';
  ```

- [x] 元素批量修改

  - 文档片段(临时存放元素对象的容器): `createDocumentFragment()`

    > `DocumentFragments` 是DOM节点。它们不是主DOM树的一部分。通常的用例是创建文档片段，将元素附加到文档片段，然后将文档片段附加到DOM树。在DOM树中，文档片段被其所有的子元素所代替。
    >
    > 因为文档片段存在于**内存中**，并不在DOM树中，所以将子元素插入到文档片段时不会引起页面[回流](https://developer.mozilla.org/zh-CN/docs/Glossary/Reflow)（对元素位置和几何上的计算）。因此，使用文档片段通常会带来更好的性能。

    ```js
    var element  = document.getElementById('ul'); // assuming ul exists
    var fragment = document.createDocumentFragment();
    var browsers = ['Firefox', 'Chrome', 'Opera', 
        'Safari', 'Internet Explorer'];
    
    browsers.forEach(function(browser) {
        var li = document.createElement('li');
        li.textContent = browser;
        fragment.appendChild(li);
    });
    
    element.appendChild(fragment);
    ```

    

  - 模板字符串拼接
        使用可能模板字符串拼接因为把原始容器的内容变为字符串和新的字符串拼接，最后再整体渲染回去，导致原始容器中的元素绑定的一些事件失效，

    ```js
    let str = ``;
    arr.forEach(item => {
        str += `<span>
            ${item}
        </span>`;
    });
    document.body.innerHTML += str;
    ```

    

- [x] 把动画等频发样式改变的操纵，运用到position:fixed/absolute...上 「脱离文档流：单独一层」

  - 利用分层机制，如果只改变一个层面上的位置大小等信息，浏览器回流和重绘的速度会加快很多

- [x] CSS3硬件加速(GPU加速)
      比起考虑如何减少回流重绘,我们更期望的是,根本不要回流重绘; 

- 修改元素的 transform / opacity（filters）... 的这些样式，不会引发DOM的回流 「浏览器的硬件加速，弊端就是消耗浏览器的内存」，这些属性会触发硬件加速,不会引发回流和重绘;

- 可能会引发的坑: 过多便用会占用大量内存性能消耗严重、有时候会导致字体模糊等

- [x] 避免使用table布局和使用css的javascript表达式

  