## 一、堆内存（HEAP）和 栈内存（STACK）

### 1、堆内存（HEAP）

- **堆内存**是用来存储**引用数据类型**值的
  - （例如：创建函数和创建对象，就是开辟一个堆内存，把代码字符串或者键值对存储到堆内存中的）==>var a = {'name':'lili'}

### 2、栈内存（STACK）

- **栈内存**是用来**执行代码**和**存储基本数据类型值**的（创建的变量也存栈里面了），
  - 不仅全局代码执行（EC(G)全局执行上下文），
  - 而且函数执行（EC(X)私有上下文），最后也都会进栈执行的
  - 基于ES6中的let/const形成的块作用域也是栈内存

### 创建变量且赋值的过程

1. 创建一个值
   - 基本数据类型直接存储在栈内存中
   - 引用数据类型需要开辟一个堆内存，把内容存储进去后，把堆内存地址存放到栈内存中供变量调用
2. 声明变量
   - 创建一个变量，存储在变量对象中
3. 定义
   - 让变量和值进行关联（指针指向的过程）

### 例题

1. ```js
   var a = 12;
   var b = a;
   b = 13;
   console.log(a);
   //过程
   var a = 12 --> 在栈内存创建一个12的值，创建一个a变量，存储到变量对象中，并与12相关联，赋值完成
   var b = a  -->a已经创建过，直接把b指向a的值的内存地址
   b = 13 --> 创建一个13的值，并把栈内存地址指向b，b赋值完成
   console.log(a) 此时a的值的地址并没有改变，所以还是输出12
   ```

2. ```js
   var a = {n: 12};
   var b = a;
   b['n'] = 13;
   console.log(a.n);
   //过程
   var a = {n: 12}; -->开辟一个堆内存，把对象存进去，地址指向a
   var b = a; --> a已经创建，只需把地址指向b
   b['n'] = 13; -->在b中取出属性为'n'的成员，并赋值13，此时b指向的内存地址是{n:12} ，所以把n修改成13 
   console.log(a.n); -->因为a、b共用一个地址，所以a.n取出的就是13
   ```

   

3. ```js
   var a = {n: 12};-->对象-开辟堆内存存入内容
   var b = a; -->指向a关联的地址
   b = {n: 13};-->新开辟一个堆内存，地址指向b
   console.log(a.n);-->此时a的地址不受b影响，输出12
   ```

4. ```js
   var a={}, b='0', c=0;  -->{}是创建堆内存,按地址操作，b、c是栈内存，按值操作
   a[b]='珠峰';-->a[b]是指把b的值当做属性值存入a，并赋值'珠峰'
   a[c]='培训';  -->a[c]==>a[0]，把a中索引为0的值改为'培训'
   console.log(a[b]);-->由于a指向的对象只有一个成员，a['0']是取出属性值为'0'的值，但同时该成员索引是0已经被改成了'培训',所以输出‘培训’
   ```

   

5. ```js
   var a={}, b=Symbol('1'), c=Symbol('1');  
   a[b]='珠峰';
   a[c]='培训';  
   console.log(a[b]);
   //每个Symbol值都是唯一的值
   a[b]、a[c]是两个不同的值
   所以a[b] ==>珠峰
   ```

6. ```js
   var a={}, b={n:'1'}, c={m:'2'};  
   a[b]='珠峰';
   a[c]='培训';  
   console.log(a[b]);
   //a[b] -->把一个对象当做对象的属性，需要转成字符串，所以{n:'1'}转成字符串后为[object Object]
   同理a[c]也是一样，所以就是同一个属性赋值两次，结果输出'培训'
   ```

   

7. ```js
   var a = {n: 1};
   var b = a;
   a.x = a = {n: 2};
   console.log(a.x);
   console.log(b);
   //{n: 1}--引用类型-堆内存 a--基本数据类型
   //连等赋值
   a.x取出对象成员的优先级是19，比等号的优先级高，所以a.x优先赋值
   a.x = a = {n: 2} ==> a.x={n:2}:在a对象中添加x:{n:2},
     a={n:2}:给a重新赋值，指向的内存地址会改变
   console.log(a.x);==>此时a={n:2}，并没有x的属性，所以输出undefined
   console.log(b);==>此时b指向的内存地址还是第一次a赋值的地址，
   所以输出{n: 1,x:{n:2}}
   ```

   

8. ```js
   var x = [12, 23];
   function fn(y) {
       y[0] = 100;
       y = [100];
       y[1] = 200;
       console.log(y);
   }
   fn(x);
   console.log(x);
   //步骤
   变量提升--声明x 声明并定义fn()--x赋值--运行fn(x)
   形参赋值 y=[12,23] 注意：这里的[12,23]的内存地址和全局变量x共用
   y[0]=100--等于把[12,23]的索引0的值改为100，这里是内存地址操作，所以全局变量x的值也会改变，此时y=[100,23] x=[100,23]
   y=[100] y重新赋值，会把值的内存地址指向新的堆内存，
   y[1]=200  把y的索引1的值赋值200 此时y=[100,200]
   console.log(y) 输出[100,200]
   console.log(x); 输出[100,23]，
   
   ```

   