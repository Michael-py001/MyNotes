## 函数

[TOC]

### 普通函数

> 1. 不确定用户到底传递多少个实参(首先不能设置形参变量了，因为我们无法确定设置多少个形参变量)，我们可以基于“函数内置的实参集合 arguments”来获取传递的实参信息
>
> 2. 不论是否传递实参，也不论是否设定形参，arguments都会存在，不传递实参，arguments是一个空集合，如果传递了实参，所有实参的信息都在arguments集合中存储着
> 3. arguments可以在形参处写成...args
>
> 3. arguments集合是一个类数组集合



```js
function sum() {
    var total = 0;
    for (var i = 0; i < arguments.length; i++) {
        // item:每一轮循环获取的集合中的指定项内容，字符串转换成数字类型
        var item = Number(arguments[i]);
        //判断是否是一个数字
        if (isNaN(item)) continue; //如果if后面的内容只有一行，比如break，continue，可以写在同一行
        total += item;
    }
    return total;
}

var result = sum(10, 20, 30);
console.log(result);

result = sum(10, 20, 30, '40');
console.log(result); //会转换字符串

result = sum('AA', 20, 30);
console.log(result); //会过滤字母

result = sum();
console.log(result);
```

```js
//多个传入数据，可以用...args
function getSum(...args) {
    var sum = 0;
    for (var i in args) {
        // console.log(i);
        var item = Number(args[i]);
        if (isNaN(item)) continue
        sum += item
    }
    return sum
}

// console.log(getSum(1, 2, 3, '40', 'a')); 
+function (n) {
    console.log(n)
}(100)
```

### 函数表达式

> 函数表达式：把一个函数当作值，赋值给变量或者元素的某个事件

```js
var x = function () {};
// 事件绑定：把函数当作值赋值给body的点击事件，当点击body的时候触发函数执行
document.body.onclick = function () {};
```

### 匿名函数

```
//自执行函数：创建函数后立即执行
(function (n) {
    console.log(n);
})(100); 
// 解决语法错误：除了把创建函数用小括号包起来，在前面写“~ ! +”都可以（没有运算的含义）
//~ function (n) {
    console.log(n);
}(100);
```

### 回调函数

> 把一个函数当作实参值，在另外一个函数执行的时候传递给它

```js
function A(callback) {
    callback(10);
    callback(20);
}
//A(实参)
A(function (m) {
    console.log('OK');
});
```

```js
// 把匿名的回调函数当做值传递给forEach函数，以后在forEach函数内部可以把匿名回调函数执行
arr.forEach(function (item) {

}); 
```

### 变量提升

- 变量提升只是提升变量声明，并没有提升变量赋值

```
例如：
console.log(a)
var a = 100
//输出undefined 未定义
//实际执行时
var a 
console.log(a)//此时a还未赋值
a=100
```

- 函数内也有变量提升

  > 1、在函数{}中，var命令声明的变量不管在何处，都会被提升至函数体头部
  >
  > 2、函数是对象类型，函数名可以进行变量提升
  > 3、函数表达式优先于函数声明，当两者同时出现先执行函数表达式定义的函数
  >
  > 4、函数的作用域指的是函数定义时的作用域，而不是函数调用时所在的作用域
  >
  > 5、函数提升只会提升函数声明，而不会提升函数表达式。

  ```js
  //1、函数表达式优先于函数声明，当两者同时出现先执行函数表达式定义的函数
  var a=function(){console.log('1')}
  function a(){console.log('2')}
  a();         ==>1
  
  //2、函数的作用域指的是函数定义时的作用域，而不是函数调用时所在的作用域
  //  同理，函数体内部绑定的函数，作用域在函数体内部
  var a = 2;
  
  function f() {
      var a = 1;
  
      function x() {
          console.log(a);
      }
      return x;
  }
  var foo = f();
  foo();
  //===>1
  //分析
  var a
  var f = function() {
      var a 
      a= 1
  
      function x() {
          console.log(a);
      }
      return x;
  }
  var foo
  a = 2
  foo = f()
  foo()
  //运行foo()==>输出1
  ```

  ```js
  var a = 1;
  function foo() {
      a = 10;
      console.log(a);
      return;
      function a() {};
  }
  foo();
  console.log(a);
  //结果 10 1
  //分析
  var a = 1; // 定义一个全局变量 a
  function foo() {
      // 首先提升函数声明function a () {}到函数作用域顶端， 然后function a () {}等同于 var a =  function() {};最终形式如下
      var a = function () {}; // 定义局部变量 a 并赋值。
      a = 10; // 修改局部变量 a 的值，并不会影响全局变量 a
      console.log(a); // 打印局部变量 a 的值：10
      return;
  }
  foo();
  console.log(a); // 打印全局变量 a 的值：1
  ```

  

  ```js
  global = 100;
  
  function fn() {
      console.log(global);
      global = 200;
      console.log(global);
      var global = 300;
  }
  fn();
  var global;
  //输出 undefined 200 
  //实际运行
  function fn() {
    	var gloval
      console.log(global); //undefined
      global = 200; //赋值
      console.log(global);//200
      global = 300;
  }
  ```

  