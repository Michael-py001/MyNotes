[TOC]



## JQ中数据类型检测的处理

```js
var class2type = {};
var toString = class2type.toString; //Object.prototype.toString
var hasOwn = class2type.hasOwnProperty; //Object.prototype.hasOwnProperty
var fnToString = hasOwn.toString; //hasOwn是一个函数，所以是调用函数上的toString-->Function.prototype.toString
var ObjectFunctionString = fnToString.call(Object); //因为除了Obejct上的toString是数据类型检测，其他对象上比如函数上的toString是用来转换成字符串的，所以这里的fnToString.call(Object)相当于-->Function.prototype.toString.call(Object)-->Object.toString()，得到的是Object函数的字符串-->"function Object() { [native code] }"
var getProto = Object.getPrototypeOf; //兼容ie，获取对象原型链__proto__指向的原型
```

### 建立数据类型检测的映射表 [object Xxx]:xxx：

> 相当于是把已知的数据类型在class2type上建立映射表，跟我们用Object.prototype.toString检测出来的结果很相似，在后面toType中使用toString.call(obj)即可拿到对应的数据类型值。

```js
	jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
		function (_i, name) {
			class2type["[object " + name + "]"] = name.toLowerCase();
		});
```

改写后的：

```js
["Boolean", "Number", "String", "Function", "Array", "Date", "RegExp", "Object", "Error", "Symbol", "BigInt", "GeneratorFunction"].forEach(name => {
    class2type[`[object ${name}]`] = name.toLowerCase();
});
```

### toType：数据类型检测的公共方法

```js
function toType(obj) {
    // null/undefiend
    if (obj == null) {
        return obj + ""; //转为字符串
    }
    // 基本数据类型检测基于typeof
    // 引用数据类型检测基于Object.prototype.toString.call
    return typeof obj === "object" || typeof obj === "function" ?
        class2type[toString.call(obj)] || "object" :
        typeof obj;
}
```

### isFunction 检测是否为函数

jQ源码：

```js
	var isFunction = function isFunction(obj) {

		// Support: Chrome <=57, Firefox <=52
		// In some browsers, typeof returns "function" for HTML <object> elements
		// (i.e., `typeof document.createElement( "object" ) === "function"`).
		// We don't want to classify *any* DOM node as a function.
    //在ie浏览器中，<object>xxx</object>标签返回的是一个函数，我们需要进行排除这种情况-->利用html标签上的nodeType是一个数字来进行验证，
		return typeof obj === "function" && typeof obj.nodeType !== "number";
	};
```

### 检测是否为window对象

```js
var isWindow = function isWindow(obj) {
    // window.window===window
  	//window中有一个一模一样的window属性，用这个进行验证
    return obj != null && obj === obj.window;
};
```

### 检测是否为数组或者类数组

```js
function isArrayLike(obj) {
    // length:对象的length属性值或者是false
    // type:获取检测值的数据类型
    var length = !!obj && "length" in obj && obj.length,//都为真，取最后一个值-->obj.length
        type = toType(obj);//调用公共方法toType
    // 函数和window一定不是数据或者类数组（但是他们确实有length属性，需要排除）
    if (isFunction(obj) || isWindow(obj)) {
        return false;
    }

    // type === "array"：数组
    // length === 0：我们认为其是一空的类数组集合
    // (length - 1) in obj：对于非空集合，我们认为只要最大索引在对象中，则证明索引是逐级递增的（不准确）-->不排除{2:'li',3:'bi',length:3}这种情况
    return type === "array" || length === 0 ||
        typeof length === "number" && length > 0 && (length - 1) in obj;
}
```

### 验证是否为空对象

> 主要是看当前对象中是否存在私有属性

```js
function isEmptyObject(obj) {
    var name;
    for (name in obj) {
        if (!obj.hasOwnProperty(name)) break;
        return false;//如果能遍历，则证明不是空对象
    }
    return true;
}
```

### 检测是否为纯粹的对象

```js
function isPlainObject(obj) {
    var proto, Ctor;//原型 ， constructor

    // 基于toString.call返回结果不是[object Object]则一定不是纯粹的对象
    if (!obj || toString.call(obj) !== "[object Object]") {
        return false;
    }

    // 获取当前对象所属类的原型
    proto = getProto(obj);//var getProto = Object.getPrototypeOf;-->getPrototypeOf获取对象原型链__proto__指向的原型

    // Object.create(null)：创建一个空对象，但是没有__proto__
    if (!proto) return true;

    // Ctor：获取当前对象所属类的constructor
    // 纯粹对象的特点：直属类的原型一定是Object.prototype（DOM元素对象/自定义的实例对象...都不是）
    Ctor = hasOwn.call(proto, "constructor") && proto.constructor;//如果都为真，则返回proto.constructor-->obj原型上的constructor

    // fnToString = Function.prototype.toString
    //fnToString.call(Ctor) = Function.prototype.toString.call(Ctor)-->调用函数上的toString方法转换成字符串
    //ObjectFunctionString = fnToString.call(Object)//在上面声明定义的ObjectFunctionString值就是：function Object() { [native code] }
    //这一连串都是为了保证obj是纯粹的对象
    return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
}
```

