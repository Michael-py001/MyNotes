### new函数与普通函数的区别

> 1. 和普通函数执行一样，形成私有上下文EC(xxx)、AO(xxx)、作用域链... 「普通函数」
> 2. 也有自己特殊的处理 「构造函数」

```js
function sum(x, y) {
    let total = x + y;
    this.total = total;
    return total;
}
let res = new sum(10, 20);
console.log(res); //sum { total: 30 }

let res = sum(10, 20);
console.log(res); // 30  window.total=30	
```

不同点：

1. new函数执行，会在代码执行之前，创建一个对象
2. 初始化THIS：让this指向创建的对象==>this=0x0000(对象的堆内存地址)
3. 代码执行中：
   - 遇到的this.xxx = xxx ，都是给创建的对象**设置属性**{xxx:xxx}
   - 除了this.xxx=xxx以外，其他的变量和这个对象没有直接关系，都是函数上下文中的私有变量
   - 如果**没有写return**: 默认把创建的对象0x0000返回
   - 如果**有return**: 如果你写的是返回**基本类型值**，不起作用，返回的还是创建的那个对象；如果返回的是**引用类型值**，则按你写的返回。

### 自定义类

> 内置类首字母大写，所以自己创造的类首字母也会大写；（构造函数）
>
> 所有的类都是一个函数数据类型的值，包括内置类 / 自定义类；
>
> 比如：typeof Object => "function"，Object是对象类，本身也是一个函数(构造函数)

```js
function Fn(x = 0, y = 0) {
    let str = `珠峰培训`;
    this.total = x + y;
    this.say = function () {
        console.log('OK');
    };
}
let f1 = new Fn(10, 20);//带参数
console.log(f1)
console.log(f1.total); // 30
console.log(f1.say); // 函数
console.log(f1.str); // undefiend  str是私有上下文中的私有变量，和实例没关系，this.xxx=xxx才是给实例设置的私有属性方法

let f2 = new Fn;//不带参数
console.log(f2);
//这样Fn也和上面一样执行了  
```

#### 带参数列表的new与不带参数的区别

- new Fn(); 带参数列表的new 优先级19
- new Fn; 不带参数列表的new  优先级18
- 最后Fn都一定会执行，而且都会创造这个类的实例，区别：是否传递实参，以及运算优先级不一样

 console.log(f1 === f2); // ==>false 每一次new类创造的实例都是“独立的实例对象”「很多人把这个称为“单例设计模式”的原因也是如此，这种模式在JS中有单独称呼“构造函数模式”」