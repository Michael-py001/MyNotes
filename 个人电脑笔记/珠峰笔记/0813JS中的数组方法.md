## 数组中常用的API

> API（Application Programming Interface 应用程序接口【凡是能被外界调用，实现某个功能的都是API】

[TOC]

### 本身提供的工具类方法

#### console.dir(Array)

##### Array.from([value])

> 把一个类数组集合（或者Set结构），转换换成数组

- 元素集合/节点集合都是类数组
- arguments也是类数组
- 我们自己构造的类数组集合
- 只有数组才能调取Array.prototype上的方法，类数组是无法调取这些方法使用的，如果想让其调用，办法就是把其转换为数组

##### Array.isArray([value])

> 检测当前的值是否是一个数组，是返回true,否返回false

```js
var allNodes = document.querySelectorAll('*');//元素集合是类数组
console.log(allNodes);
console.log(Array.isArray(allNodes)); //false

var arr = Array.from(allNodes);//把类数组转换成数组
console.log(arr);
console.log(Array.isArray(arr)); //true
```



### 供数组调用的方法

>   数组可以调取的各种方法，主要记以下几点
>
> + 方法的作用
>
> + 方法的实参
>
> + 方法的返回值
>
> + 原始数组是否发生改变

#### console.dir(Array.prototype) 查看数组的所有方法

##### arr.push([value])

- 向数组**末尾**插入内容 

- 实参:要插入的内容 

- 返回值:插入内容后数组最新的长度 

- 原始数组改变

  ```js
  var arr = [10, 20, 30];
  var res = arr.push('lili');
  console.log(res, arr); // 4 [10, 20, 30, "lili"]
  ```

  

##### arr.pop()

- 删除数组**最后一项**的内容 

- 实参:-- 

- 返回值:删除了的内容 

- 原始数组改变

  ```js
  var arr = [10, 20, 30];
  var res = arr.pop();
  console.log(res, arr); // 30 [10,20]
  ```

  

##### arr.shift()

- 删除数组**第一项**内容 

- 实参:-- 

- 返回值:删除的内容 

- 原始数组改变

  ```js
  var arr = [10, 20, 30];
  var res = arr.shift();
  console.log(res, arr); // 10 [20,30]
  ```

  

##### arr.unshift([value])

- 向数组**开始的位置**插入内容 

- 实参:要插入的内容

- 返回值:插入后数组最新的长度 

- 原始数组改变

  ```js
  var arr = [10, 20, 30];
  var res = arr.unshift('lili', 100, 200);
  console.log(res, arr); // 6 ['lili', 100, 200 , 10, 20, 30] 
  ```

  

##### arr.splice(n,m)

- 从索引n开始，**删除**m个元素

- 把删除的内容以新数组返回

- 原始数组改变(m不设定，是一直删除到数组末尾)

  - 普通用法 splice(n,m)

    ```js
    var arr = [10, 20, 30, 40, 50, 60];
    var res = arr.splice(2, 3);//从下标2开始（包括2）
    console.log(res, arr); // [30,40,50]  [10,20,60]
    ```

  - splice(n,m,x,...)

    > 从索引n开始删除m个元素，用x及后面传递的值替换删除的内容，返回删除部分内容[数组]，原始数组改变

    ```js
    var arr = [10, 20, 30, 40, 50, 60];
    var res = arr.splice(1, 2, 'zhufeng', 'peixun', 'javascript');
    console.log(res, arr); // [20,30] [10,'zhufeng', 'peixun', 'javascript',40...]
    ```

  - splice(n,0,x,...)

    > 从索引n开始，一个都不删除，把x插入到索引n的后面（包括x），返回一个空数组(没有删除任何内容)，原始数组改变

    ```js
    var arr = [10, 20, 30, 40, 50, 60];
    var res = arr.splice(1, 0, 'zhufeng', 'peixun');
    console.log(res, arr); // [] [10, "zhufeng", "peixun", 20, ...] 
    ```

    

##### arr.slice(n,m)

- 从索引n开始，找到索引为m处（**不包含m**)

- 把找到的结果以新数组返回

- 原始数组不变（数组查找）

  ```js
  //类似Python中的切片
  var arr = [10, 20, 30, 40, 50, 60];
  var res = arr.slice(2, 4);
  console.log(res, arr); // [30, 40] [10, 20, 30, 40, 50, 60] 
  ```

  

##### arr.concat([value])

- 实现数组的拼接

- 参数是拼接的数组/值(可以传入多个值)

- 返回拼接后的数组

- 原始数组不变

  ```
  var arr1 = [10, 20, 30];
  var arr2 = [40, 50, 60];
  var res = arr1.concat('lili', arr2);
  console.log(res); // [10, 20, 30, "lili", 40, 50, 60]
  ```

  

##### arr.toString()

- 把数组转为字符串（数组中的每一项基于逗号分隔)

- 原始数组不变

  ```js
  var arr = [1,2,3,'abc']
  arr.toString()
  console.log(arr) ==> "1,2,3,abc"
  ```

##### arr.join([char])

- 把数组按照指定分隔符转换为字符串

- 原始数组不变

  ```
  var arr = [10, 20, 30];
  console.log(arr.join('+')); // "10+20+30"
  ```

  

##### arr.indexOf([char])

- 查找value在数组第一次出现位置的索引

- 如果数组中没有这一项，返回-1

- 可以用来查找有没有这一项

  ```js
  var arr = [10, 20, 30, 20, 40];
  console.log(arr.indexOf(20)); //1
  console.log(arr.indexOf(50)); //-1
  ```

##### arr.lastIndexOf([char])

- 查找当前项在数组最后一次出现位置的索引

- 如果数组中没有这一项，返回-1

  ```js
  var arr = [10, 20, 30, 20, 40];
  console.log(arr.lastIndexOf(20)); //3 最后一次出现的索引值
  console.log(arr.lastIndexOf(50)); //-1
  ```

##### arr.includes([char])

- 直接验证数组中是否包含某一项

- 包含则返回true，否则是false

  ```js
  var arr = [10, 20, 30, 20, 40];
  console.log(arr.includes(20)) //true
  ```

##### arr.sort(function(a,b){return a-b})

- 把数组进行排序

- 原始数组也是改变的

- 实现升序和降序需要配合函数使用

  ```js
  var arr = [1, 3, 5, 2, 3, 7];
  arr.sort();
  console.log(arr); //[1, 2, 3, 3, 5, 7]
  
  arr = [1, 6, 3, 7, 2, 17, 23, 15];
  arr.sort();
  console.log(arr); //[1, 15, 17, 2, 23, 3, 6, 7] 在两位及两位数以上，sort无法按照数字的大小进行排序，它是按照unicode编码值进行排序的(先比较第一位，第一位相同再比较第二位...)
  ```

- 常用用法(升序，降序)

  ```js
  var arr = [1, 6, 3, 7, 2, 17, 23, 15];
  arr.sort(function (a, b) {
      // 再sort内部处理的时候，会按照数组的长度，依次遍历数组中的每一项(以及和每一项的后一项)，每一次遍历都会把匿名函数触发执行一次，并且把当前遍历的当前项和后一项传递给这个函数
      // a:后一项
      // b:当前项
      // 如果当前匿名函数返回<=0的值，则让当前项和后一项交换位置(从而实现排序)
      // + a-b 升序
      // + b-a 降序
      return a - b;
  });
  console.log(arr); // [1, 2, 3, 6, 7, 15, 17, 23]
  ```

  ```js
  //需求：按照每个人年龄的降序进行排序
  var arr = [{
      name: '张三',
      age: 18
  }, {
      name: '李四',
      age: 35
  }, {
      name: '王五',
      age: 25
  }];
  arr.sort(function (a, b) {
      return b.age - a.age;//前一项 - 后一项 <=0 ，位置互换
  });
  console.log(arr);
  ==>
  //[
    { name: '李四', age: 35 },
    { name: '王五', age: 25 },
    { name: '张三', age: 18 }
  ]
  ```

  

##### arr.reserve()

- 把数组倒过来排列

- 原始数组改变

  ```js
  var arr = [1, 3, 5, 2, 3, 7];
  var res = arr.reverse();
  console.log(res, arr); // [7, 3, 2, 5, 3, 1] *2 
  ```

  

##### arr.forEach([callback])

- 迭代/遍历数组中每一项，传递一个回调函数

- 不支持返回值

- 原始数组不变

  ```js
  var arr = [10, 20, 30, 40, 50, 60];
  
   基于“命令式编程”遍历数组每一项：注重编程的过程（把控每一个步骤）
   for (var i = 0; i < arr.length; i++) {
       console.log('当前项:' + arr[i], '索引:' + i);
   }
  
  // 基于“函数式编程”遍历数组每一项：注重的是结果，不在乎你处理的过程
  arr.forEach(function (item, index) {
      // 内部会依次遍历数组中的每一项，而且每遍历一项，都会触发回调匿名函数执行，并且把当前遍历这一项和索引传递给函数
      // item:当前遍历的这一项
      // index:当前遍历这一项的索引
      console.log('当前项:' + item, '索引:' + index);
  }); 
  
  ```

  

##### arr.map(]callback)

**语法：**
		

```js
var new_array = arr.map(function callback(currentValue[, index[, array]]) {
 // Return element for new_array 
}[, thisArg])
```

**参数：**

- **callback**

  > 生成新数组元素的函数，使用三个参数：

  - **currentValue**

    > `callback` 数组中正在处理的当前元素。

  - `index`(可选)

    > `callback` 数组中正在处理的当前元素的索引。

  - `array`(可选)

    > `map` 方法调用的数组。

- `thisArg`(可选)

  > 执行 `callback` 函数时值被用作`this`。

- 和forEach类似，也是依次遍历数组中的每一项，并且通知匿名回调函数执行（当前项/当前项索引 传递给函数)

- 区别是map支持返回值的，回调函数中返回的结果会替换数组中的当前项（原始数组不变，以新数组返回）

  ```js
  var arr = [10, 20, 30, 40, 50, 60];
  var res = arr.map(function (item, index) {
      // 返回啥相当于把当前项替换成啥
      return item * index; (==>这个值就是变成当前item的值)
  });
  console.log(res); // [0, 20, 60, 120, 200, 300]
  ```

  

##### arr.filter([callback])

- 遍历数组中的每一项(item/index)，在每一次遍历的时候，如果回调函数中返回的是true，则我们把这一项留下，如果返回的是false，则这一项不要了，把最后筛选的结果按照新数组返回，原始数组不变；

- 数组筛选的办法，把符合条件的筛选出来；

  ```js
  var arr = [10, 20, 30, 40, 50, 60];
  var res = arr.filter(function (item, index) {
      //索引是偶数代表第奇数个
      //0 2 4
      return index % 2 === 0;
  });
  console.log(res, arr); // [10, 30, 50]
  ```

  

##### arr.find([callback])

- 在数组中查找符合条件的这一项，没有则返回unddfined

  ```js
  const array1 = [5, 12, 8, 130, 44];
  
  const found = array1.find(element => element > 10);
  
  console.log(found);
  // expected output: 12
  ```

  ```js
  var arr = [10, 20, 30, 40, 50, 60];
  var res = arr.find(function (item, index) {
      // 一但找到符合条件的，则遍历结束
      return index > 2;
  });
  console.log(res); // 40
  ```

  

##### arr.findIndex([callback])

- 查找到符合条件这一项的索引，找不到则返回-1

  ```js
  const array1 = [5, 12, 8, 130, 44];
  
  const isLargeNumber = (element) => element > 13;
  
  console.log(array1.findIndex(isLargeNumber));
  // expected output: 3
  ```

  

  

##### arr.some([callback])

- 依次遍历数组中的每一项，只要有一项符合我们设定的条件，整体为true，反之是false

  ```js
  var arr = [10, 20, 30, 40, 50, 60];
  var res = arr.some(function (item, index) {
      return item >= 50;
  });
  console.log(res); //true
  ```

  ```js
  const array = [1, 2, 3, 4, 5];
  
  // checks whether an element is even
  const even = (element) => element % 2 === 0;
  
  console.log(array.some(even));
  // expected output: true
  ```

  

##### arr.every([callback])

- 每一项都要符合这个条件，整体才是true

  ```js
  var arr = [10, 20, 30, 40, 50, 60];
  
  res = arr.every(function (item, index) {
      return item >= 50;
  });
  console.log(res); //false 
  ```

  ```js
  const isBelowThreshold = (currentValue) => currentValue < 40;
  
  const array1 = [1, 30, 39, 29, 10, 13];
  
  console.log(array1.every(isBelowThreshold));
  // expected output: true
  
  ```

  

##### arr.reduce([callback])

语法：

```js
arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])
```



- **callback**

  > 执行数组中每个值 (如果没有提供 `initialValue则第一个值除外`)的函数，包含四个参数

- 回调函数可以有4个参数

  - 累加器(`accumulator`)  （必须）

    > 累计器累计回调的返回值; 它是上一次调用回调时返回的累积值，或`initialValue`

  - 当前值(`currentValue`) （必须）

    > 数组中正在处理的元素。

  - 当前索引(`index`)  （可选）

    > 数组中正在处理的当前元素的索引。 如果提供了`initialValue`，则起始索引号为0，否则从索引1起始。

  - 源数组(`array`)  （可选）

    > 调用`reduce()`的数组

- `initialValue`  (可选)

  > 作为第一次调用 `callback`函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。

- 返回值：函数累计处理的结果

- 数组里所有值的和

  ```js
  var sum = [0, 1, 2, 3].reduce(function (accumulator, currentValue) {
    return accumulator + currentValue;
  }, 0); //initialValue初始值为0，不写的话就是按数组里的第一个为初始值
  // 和为 6
  ```

  ```js
  //箭头函数
  var total = [ 0, 1, 2, 3 ].reduce(
    ( acc, cur ) => acc + cur,
    0
  );
  ```

- 累加对象数组里的值

  > 要累加对象数组中包含的值，必须提供初始值，以便各个item正确通过你的函数。

  ```js
  var initialValue = 0;
  var sum = [{x: 1}, {x:2}, {x:3}].reduce(function (accumulator, currentValue) {
      return accumulator + currentValue.x;
  },initialValue)
  
  console.log(sum) // logs 6
  ```

  ```js
  //箭头函数
  var initialValue = 0;
  var sum = [{x: 1}, {x:2}, {x:3}].reduce(
      (accumulator, currentValue) => accumulator + currentValue.x
      ,initialValue
  );
  
  console.log(sum) // logs 6
  ```

- 将二维数组转化为一维

  ```js
  var flattened = [[0, 1], [2, 3], [4, 5]].reduce(
    function(a, b) {
      return a.concat(b);
    },
    [] //调用的数组
  );
  过程：
  a: [] b: [ 0, 1 ]
  a: [ 0, 1 ] b: [ 2, 3 ]
  a: [ 0, 1, 2, 3 ] b: [ 4, 5 ]
  最终结果[ 0, 1, 2, 3, 4, 5 ]
  // flattened is [0, 1, 2, 3, 4, 5]
  ```

  ```js
  //箭头函数
  var flattened = [[0, 1], [2, 3], [4, 5]].reduce(
   ( acc, cur ) => acc.concat(cur),
   []
  );
  
  ```

- 计算数组中每个元素出现的次数

  ```js
  var names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice'];
  
  var countedNames = names.reduce(function (allNames, name) { 
    if (name in allNames) {
      allNames[name]++;
    }
    else {
      allNames[name] = 1;
    }
    return allNames;
  }, {});
  // countedNames is:
  // { 'Alice': 2, 'Bob': 1, 'Tiff': 1, 'Bruce': 1 }
  ```

  

##### arr.fill([value])

- 数组填充

  ```js
  var arr = new Array(5); //创建一个长度为10的数组，但是此时每一项没有内容
  arr.fill(null); //填充后拥有了每一项，只不过结果为null（拥有每一项之后就可以遍历了）
  console.log(arr);
  ==>[ null, null, null, null, null]
  ```

  

##### arr.flat([number])

- 数组扁平化，把多维数组降级为一维数组

- 参数是控制降几个维度，默认降一个维度，Infinity是控制直接降为一维数组

- 原始数组不变

  ```js
  arr3 = [1,[2],[3,4,[5,6,7,[8,9]]]]
  ==>(3) [1, Array(1), Array(3)]
  arr3.flat(1)
  ==>(5) [1, 2, 3, 4, Array(4)]
  arr3.flat(2)
  ==>(8) [1, 2, 3, 4, 5, 6, 7, Array(2)]
  arr3.flat(Infinity)
  ==>(9) [1, 2, 3, 4, 5, 6, 7, 8, 9]
  ```

  

