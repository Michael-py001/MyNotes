# Vuex学习

## Vuex中的各模块关系

- state: 存放响应式数据，存储在 Vuex 中的数据和 Vue 实例中的 `data` 遵循相同的规则，例如状态对象必须是纯粹 (plain) 的。**参考：**[Vue#data (opens new window)](https://cn.vuejs.org/v2/api/#data)。
- getter: 存放的是计算属性，就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。
- mutations: 存放commit提交的mutation，必须要通过`store`中的commit方法才能唤醒mutation，才能修改数据。
- actions: 存放dispatch派发的action

![vuex](https://i.loli.net/2021/04/09/HotaleExRPWn6Ci.png)

## state

> 官方文档：https://vuex.vuejs.org/zh/guide/state.html#mapstate-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0

### 在 Vue 组件中获得 Vuex 状态

想要在各个组件中取到vuex中的数据，需要在全局下把store注入到Vue中。

1. main.js中引入store:

   ```js
   import Vue from 'vue'
   import App from './App.vue'
   import store from './store'
   
   Vue.config.productionTip = false
   
   new Vue({
     store,
     render: h => h(App)
   }).$mount('#app')
   
   ```

2. store中的index.js需要使用Vuex:

   ```js
   import Vue from 'vue'
   import Vuex from 'vuex'
   import state from './state'
   import getter from './getter'
   import mutations from './mutations'
   import actions from './actions'
   import user from './modules/user'
   Vue.use(Vuex)  //Vuex暴露在全局下
   
   export default new Vuex.Store({
     state,
     mutations,
     actions,
     getter,
     // modules是子模块
     modules: {
       user
     }
   })
   
   ```

那么我们如何在 Vue 组件中展示状态呢？由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在[计算属性 (opens new window)](https://cn.vuejs.org/guide/computed.html)中返回某个状态：

```js
// 创建一个 Counter 组件
const Counter = {
  template: `<div>{{ count }}</div>`,
  computed: {
    count () {
      return store.state.count
    }
  }
}
```

每当 `store.state.count` 变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM。

通过在根实例中注册 `store` 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 `this.$store` 访问到。让我们更新下 `Counter` 的实现：

```js
const Counter = {
  template: `<div>{{ count }}</div>`,
  computed: {
    count () {
      return this.$store.state.count
    }
  }
}
```

## mapState 辅助函数

当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 `mapState` 辅助函数帮助我们生成计算属性，让你少按几次键：

```js
// 在单独构建的版本中辅助函数为 Vuex.mapState
import { mapState } from 'vuex'

export default {
  // ...
  computed: mapState({
    // 箭头函数可使代码更简练
    count: state => state.count, //其实就是省了store.state.count

    // 传字符串参数 'count' 等同于 `state => state.count`
    countAlias: 'count',

    // 为了能够使用 `this` 获取局部状态，必须使用常规函数
    countPlusLocalState (state) {
      return state.count + this.localCount
    }
  })
}
```

当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 `mapState` 传一个字符串数组。

```js
computed: mapState([
  // 映射 this.count 为 store.state.count
  'count'
])
```

### [#](https://vuex.vuejs.org/zh/guide/state.html#对象展开运算符)对象展开运算符

#### mapState返回的格式

```js
console.log(mapState(['userName']));
```

![image-20210409231859509](https://i.loli.net/2021/04/09/vjf2keiZcCJ3WLu.png)

可以看到mapState返回的是一个对象，跟计算属性一样，'userName'是名字，后面跟着的是它的函数。

`mapState` 函数返回的是一个对象。我们如何将它与局部计算属性混合使用呢？通常，我们需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 `computed` 属性。但是自从有了[对象展开运算符 (opens new window)](https://github.com/tc39/proposal-object-rest-spread)，我们可以极大地简化写法：

```js
computed: {
  localComputed () { /* ... */ },
  // 使用对象展开运算符将此对象混入到外部对象中
  ...mapState({
    // ...
  })
}
```

## 命名空间

默认情况下，模块内部的 action、mutation 和 getter 是注册在**全局命名空间**的——这样使得多个模块能够对同一 mutation 或 action 作出响应。

如果希望你的模块具有更高的封装度和复用性，你可以通过添加 `namespaced: true` 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。

```js
// ./modules/user.js
export default {
    namespaced:true, //指定命名空间
    state: {
        userName:'lili'
    },

}
```

使用：

```vue
<template>
  <div id="app">
    {{$store.state.lesson}}
    {{$store.state.room}}
    <p>{{userName}}</p>
  </div>
</template>
<script>
import {createNamespacedHelpers} from 'vuex' //引入辅助函数
let {mapState} = createNamespacedHelpers('user') //命名空间就是
export default {
  computed:{
    ...mapState(['userName'])
  }
}
</script>
```



### 带命名空间的绑定函数

当使用 `mapState`, `mapGetters`, `mapActions` 和 `mapMutations` 这些函数来绑定带命名空间的模块时，写起来可能比较繁琐：

```js
computed: {
  ...mapState({
    a: state => state.some.nested.module.a,
    b: state => state.some.nested.module.b
  })
},
methods: {
  ...mapActions([
    'some/nested/module/foo', // -> this['some/nested/module/foo']()
    'some/nested/module/bar' // -> this['some/nested/module/bar']()
  ])
}
```

对于这种情况，你可以将模块的空间名称字符串作为第一个参数传递给上述函数，这样所有绑定都会自动将该模块作为上下文。于是上面的例子可以简化为：

```js
computed: {
  ...mapState('some/nested/module', {
    a: state => state.a,
    b: state => state.b
  })
},
methods: {
  ...mapActions('some/nested/module', [
    'foo', // -> this.foo()
    'bar' // -> this.bar()
  ])
}
```

### createNamespacedHelpers辅助函数

而且，你可以通过使用 `createNamespacedHelpers` 创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数：

```js
import { createNamespacedHelpers } from 'vuex'

const { mapState, mapActions } = createNamespacedHelpers('some/nested/module')

export default {
  computed: {
    // 在 `some/nested/module` 中查找
    ...mapState({
      a: state => state.a,
      b: state => state.b
    })
  },
  methods: {
    // 在 `some/nested/module` 中查找
    ...mapActions([
      'foo',
      'bar'
    ])
  }
}
```

```vue
<template>
  <div id="app">
    <p>{{userName}}</p> 
  </div>
</template>
<script>
import {createNamespacedHelpers} from 'vuex' //引入辅助函数
let {mapState} = createNamespacedHelpers('user') //命名空间就是
export default {
  computed:{
    ...mapState(['userName']) 
  }
}
</script>
```

## mapState

在store中有state.js:

```js
export default {
    // 放的是响应式数据
    lesson:"English",
    room:"718"
}
```

从vuex中取出的mapState，可以拿到store中根模块的state，也能获取到子模块中的state。

```vue
<template>
  <div id="app">
    {{ $store.state.lesson }}
    {{ $store.state.room }}
    <p>{{ lesson }}</p>
    <p>{{ room }}</p>
  </div>
</template>
<script>
import {mapState} from "vuex"; //从vuex中取出的mapState，可以访问跟模块和子模块
export default {
  computed: {
    // ...mapState(["userName"]),
    ...mapState(["lesson",'room']),
  },
};
</script>
```

mapState的使用一共有三种方法：

1. 直接使用state中的变量名，传入一个数组。

   ```js
   ...mapState(["lesson",'room'])
   ```

2. 使用自定义变量名+函数，这种方法可以改变原变量名称。

   ```js
   ...mapState({
         name:state=>state.lesson,
         room2:state=>state.room  
       })
   ```

3. 传入两个参数，第一个指定模块名（子模块）,第二个传入一个对象或数组，里面是state中的变量名。

   ```js
   ...mapState('user',['userName'])
   ```

   

```js
import {mapState} from "vuex"; //从vuex中取出的mapState，可以访问跟模块和子模块
export default {
  computed: {
    //获取state中的响应式数据，方法一
    ...mapState(["lesson",'room']),
    //方法二 可以更改state中的变量名
    ...mapState({
      name:state=>state.lesson,
      room2:state=>state.room  
    }),
    // 方法三，传入第一个参数->模块名，第二个参数->模块中的state中的变量名，需要对象或者数组格式
    ...mapState('user',['userName'])
  },
};
```

## getters

getter相当于计算属性computed，可以对state中的数据进行过滤，再次计算后再返回。

### 使用方法

1. 获取根模块中的getters(注意import的变量名必须是getters)
   根模块中的`getters.js`:

   ```js
   export default {
       //放的是计算属性(computed)
       getName:(state)=>{ //这里的state就是根模块的state.js
           return "课程名称："+state.lesson
       }
   }
   ```

   在computed中使用：

   ```js
   ...mapGetters({lessonName:'getName'}), //对象参数
   ...mapGetters(['getName']),//数组参数
```
   
2. 获取子模块中的getters

   子模块中的getter:

   ```js
   export default {
       namespaced:true, //开启命名空间
       state: {
           userName:'lili'
       },
       getters:{
           getUserName:(state)=>{  //这里的state是本模块中的state
               return "我的名字："+state.userName
           }
       },
   
   }
   ```

   在computed中使用：

   ```js
   ...mapGetters('user',['getUserName']) //子模块中调用，第二个参数必须是数组
   ```

   

## mutations使用

更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 **事件类型 (type)** 和 一个 **回调函数 (handler)**。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：

```js
const store = new Vuex.Store({
  state: {
    count: 1
  },
  mutations: {
    increment (state) {
      // 变更状态
      state.count++
    }
  }
})
```

要唤醒一个 mutation handler，你需要以相应的 type 调用 **store.commit** 方法：

```js
store.commit('increment')
```

### 提交载荷（Payload）

你可以向 `store.commit` 传入额外的参数，即 mutation 的 **载荷（payload）**：

```js
// ...
mutations: {
  increment (state, n) {
    state.count += n
  }
}
store.commit('increment', 10)
```

在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：

```js
// ...
mutations: {
  increment (state, payload) {
    state.count += payload.amount
  }
}
store.commit('increment', {
  amount: 10
})
```

### [#](https://vuex.vuejs.org/zh/guide/mutations.html#对象风格的提交方式)对象风格的提交方式

提交 mutation 的另一种方式是直接使用包含 `type` 属性的对象：

```js
store.commit({
  type: 'increment',
  amount: 10
})
```

当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变：

```js
mutations: {
  increment (state, payload) {
    state.count += payload.amount
  }
}
```

###  Mutation 需遵守 Vue 的响应规则

既然 Vuex 的 store 中的状态是响应式的，那么当我们变更状态时，监视状态的 Vue 组件也会自动更新。这也意味着 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项：

1. 最好提前在你的 store 中初始化好所有所需属性。
2. 当需要在对象上添加新属性时，你应该

- 使用 `Vue.set(obj, 'newProp', 123)`, 或者

- 以新对象替换老对象。例如，利用[对象展开运算符 (opens new window)](https://github.com/tc39/proposal-object-rest-spread)我们可以这样写：

  ```js
  state.obj = { ...state.obj, newProp: 123 }
  ```

### 在组件中提交 Mutation

你可以在组件中使用 `this.$store.commit('xxx')` 提交 mutation，或者使用 `mapMutations` 辅助函数将组件中的 methods 映射为 `store.commit` 调用（需要在根节点注入 `store`）。

```js
import { mapMutations } from 'vuex'

export default {
  // ...
  methods: {
    ...mapMutations([
      'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')`

      // `mapMutations` 也支持载荷：
      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`
    ]),
    ...mapMutations({
      add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')`
    })
  }
}
```

### Mutation 必须是同步函数

一条重要的原则就是要记住 **mutation 必须是同步函数**

### 唤醒根模块下的mutation

App.vue中设置一个方法

```js
methods:{
    //--mutation的使用--
    change(){
      //同步 change_room 提交mutation的类型，第二个参数填需要改的数据
      this.$store.commit('change_room','999')
    }
  }
```

mutations.js中：

```js
export default {
    //放的commit提交的mutation
    change_room(state,payload){//payload 载荷
        state.room = payload
    }
}
```

### 使用辅助函数mapMutations

因为展开后的mapMutations是一个个的函数，所以需要在methods里面先展开，里面的方法已经存到了this当前组件里了，然后在change方法里面调用this.type，也可以传入载荷参数。

```js
methods:{
    //--mutation的使用--
    ...mapMutations(['change_room']),
    change(){
      this.change_room('999')
    }
  }
```

### mutations与state、getters的区别

state、getters需要在computed里使用，而mutations是在methods里使用

### 唤醒子模块下的mutation

子模块：

```js
export default {
    namespaced:true, //开启命名空间
    state: {
        userName:'lili'
    },
    getters:{
        getUserName:(state)=>{  //这里的state是本模块中的state
            return "我的名字："+state.userName
        }
    },
    mutations:{
        change_name(state,payload){//payload 载荷
            state.userName = payload
        }
    },
    actions:{

    }

}
```

App.vue中使用：

```js
methods:{
    //--mutation的使用--
    ...mapMutations('user',['change_name']),
    change(){
      this.change_name('Michael')
    }
  }
```

## actions

actions专门用来提交异步的mutation，需要用`dispatch`派发指令，然后在action里用commit唤醒mutation更改数据。

```js
  methods:{
      this.$store.dispatch('change_room','10')
    }
  }
```

在根模块下的action.js，

```js
export default {
    //通过dispatch派发的action
    change_room(state,payload){
        setTimeout(()=>{
            console.log(state);
            console.log(payload);
        },1000)
    }
}
```

每一个action的第一个参数是一个对象，里面包含了好几个方法：

![image-20210410155114258](https://i.loli.net/2021/04/10/VNFf9m4aJO51e6L.png)

所以需要解构出commit方法：

```js
export default {
    //通过dispatch派发的action
    change_room({commit},payload){
        setTimeout(()=>{
            commit('change_room',888)
        },1000)
    }
}
```

这里的commit方法会自动找到mutations中的change_room，从而修改数据。

### 使用辅助函数mapActions

```js
import {mapState,mapGetters,mapMutations,mapActions} from "vuex";  
methods:{
    ...mapActions(['change_room']),//根模块
    ...mapActions('user',['change_name']),//子模块
    change(){
      // Actions
      // this.$store.dispatch('change_room','10') //方法一
      this.change_room(78)//使用辅助函数
      this.change_name('hello')
    }
  }
```

**注意：**mapActions里传的需要一个数组或对象形式的参数，使用辅助函数只能用数组。

子模块：

```js
export default {
  namespaced: true, //开启命名空间
  state: {
    userName: "lili",
  },
  getters: {
    getUserName: (state) => {
      //这里的state是本模块中的state
      return "我的名字：" + state.userName;
    },
  },
  mutations: {
    change_name(state, payload) {
      //payload 载荷
      state.userName = payload;
    },
  },
  actions: {
    change_name({commit},payload){
      setTimeout(()=>{
        commit('change_name',payload)
      },1000)
    }
  },
};

```

根模块：

```js
export default {
    //放的commit提交的mutation
    change_room(state,payload){//payload 载荷
        state.room = payload
    }
}
```

## 优化

可以把每个mutation，action的名字抽离出一个文件中，改成一个个的常量，这样后期维护比较方便。

types.js:

```js
export const CHANGE_ROOM = 'change_room'
export const CHANGE_NAME = 'change_name'
```

在使用时先引入这个文件的所有常量：

```js
import * as types from '@/store/types'
 methods:{
    ...mapMutations([types.CHANGE_ROOM]),//根模块
    change(){
      this[types.CHANGE_ROOM]('999')
    }
  }
```

单独的mutation.js模块和actions.js模块也要引入types.js

```js
//mutation.js
import * as types from '@/store/types'
export default {
    //放的commit提交的mutation
    [types.CHANGE_ROOM](state,payload){//payload 载荷
        state.room = payload
    }
}
```

```js
//actions.js
import * as types from '@/store/types'
export default {
    //通过dispatch派发的action
    [types.CHANGE_ROOM]({commit},payload){
        setTimeout(()=>{
            commit(types.CHANGE_ROOM,payload)
        },1000)
    }
}
```

子模块中也可以引入：

```js
import * as types from '@/store/types'
export default {
  namespaced: true, //开启命名空间
  state: {
    userName: "lili",
  },
  getters: {
    getUserName: (state) => {
      //这里的state是本模块中的state
      return "我的名字：" + state.userName;
    },
  },
  mutations: {
    [types.CHANGE_NAME](state, payload) { //使用types中的常量
      //payload 载荷
      state.userName = payload;
    },
  },
  actions: {
    change_name({commit},payload){
      setTimeout(()=>{
        commit('change_name',payload)
      },1000)
    }
  },
};

```

