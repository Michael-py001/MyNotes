### 变量提升中的易错情况

变量提升阶段：

**[老版本浏览器]** 不论条件是否成立，都要把fn声明+定义，而且fn只是全局上下文中的变量

 **[新版本浏览器]** 为了兼容ES3/ES6，规则处理的非常的复杂

 全局变量提升：如果创建函数的代码出现在“非函数或者对象的大括号中（例如：判断体、循环体、代码块...）”，只会它进行声明，不进行赋值。

```js
console.log(fn); // undefined ，老版本中还是函数本身
if (1 == 1) {
  // 私有上下文变量提升：fn=0x000000;
  console.log(fn); //函数
  function fn() { //代码执行到这的时候，会把私有上下文中，之前对于fn的操作，映射给全局一份
   console.log('ok');
  }
  fn = 12;
  console.log(fn); //12
}
console.log(fn); //函数 */
```

### 出现代码块时的例题：

```js
//1、
{
    function foo() {} //新版浏览器在【判断体，循环体，代码块】中的特殊情况：运行到这里时，
    //会在代码块形参私有上下文，只声明foo,(老版本不论是否出现在{}中，都是声明加定义)并且会把这一步及之前的操作映射一份给全局，
    //此时全局变量里有一个变量 foo = function foo() {}
    //在这之后的操作都是在私有域里进行，和全局没有关系了
    foo = 1;
}
console.log(foo); //==>输出'function foo() {}'

//2、

{
    //声明并定义foo函数foo,给全局映射一份,这里foo(m)会覆盖foo(n)
    console.log(foo)

    function foo(n) {}
    //在这之后的操作都是在私有域里进行，对全局没有影响
    foo = 1;
    //console.log(window.foo);-->输出'funtion foo() {}',说明foo=1没有在全局进行操作

    function foo(m) {} //遇到了函数，又把之前的操作映射一份给全局
    // console.log(window.foo) -->此时输出1，说明对全局的foo进行了上面的赋值操作
}
console.log(foo); //-->输出1

//3、----

{
    //变量提升阶段，声明函数并赋值
    function foo() {} //在代码块中，遇到函数代码，会把之前的操作映射一份给全局，此时全局也有一个foo
    foo = 1; //不是函数，在私有域进行操作

    function foo() {} //遇到函数，又把之前的操作映射一份给全局，此时全局foo=1
    foo = 2; //在私有域进行
}
console.log(foo); //此时输出全局的foo-->1
```

### 函数形参有默认值的情况

```js
ar x = 1;

function func(x, y = function anonymous() {x = 2}) {
    x = 3;//没有声明，则按默认改变x形参的值
    y()
    console.log(x)
}
func(5)
console.log(x);
```

```js
var x = 1;

function func(x, y = function anonymous() {
    x = 2
}) {
    var x = 3; //如果当前函数有形参默认值，在{}里有用var/let/const声明(let/const不能声明和形参同名的变量)了变量
    //，则会创建一个私有块级上下文，和函数私有上下文不一样，下面的操作都是在块级里运行
    y();
    console.log(x) 
}
func(5)
console.log(x)
```

```js
var x = 1;

function func(x, y = function anonymousl() {x = 4}) {
    var x = 3;
    var y = function anonymousl() {
        x = 4
    };
    y()
    console.log(x)
}
func(5)
console.log(x);
```

### 匿名函数有变量提升吗？

> 答案是没有的

```js
var a = 9;

function fn() {
    a = 0;
    return function (b) { //匿名函数不参与变量提升
        return b + a++;
    }
}
var f = fn(); //运行fn()时，return的函数并没有执行，a不会++，还是0
console.log(f(5)); //5
console.log(fn()(5)); //5
console.log(f(5)); //6
console.log(a); //2
```

