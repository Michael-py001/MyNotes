### 各种数据类型相加的问题案例

```js
console.log(1 + false + undefined + [] + null + true + '珠峰培训' + [12] + 1);
console.log(1 + false); //1
console.log(1 + true); //2
console.log(1 + false + undefined); //NaN
console.log(typeof (1 + false + undefined)); //NaN
console.log(1 + undefined); //NaN    
console.log(1 + false + undefined + []); //NaN
console.log(typeof (1 + false + undefined + [])); //NaN
console.log(1 + []); //1
console.log(1 + false + undefined + [] + null); //NaNnull
console.log(1 + null); //1
console.log(1 + false + undefined + [] + null + true); //NaNnulltrue
console.log(undefined + null); //NaN
console.log(undefined + []); //nudefined
console.log(1 + false + undefined + [] + null + true + '立立'); //NaNnulltrue立立
console.log(1 + false + undefined + [] + null + true + '立立' + [12]); //NaNnulltrue立立12
console.log(1 + false + undefined + [] + null + true + '立立' + [12] + 1); //NaNnulltrue立立121
console.log(typeof null) //object 历史遗留问题 从逻辑角度上看，null是一个空的对象指针。而这也正是使用typeof操作符检测null值，会返回“object”的原因。
console.log(typeof undefined) //undefined
console.log(typeof NaN) //number
console.log(NaN + null) //NaN
console.log(NaN + null + undefined) //NaN
console.log(NaN + true) //NaN
console.log(1 + []) //1
console.log(typeof (1 + [])) //String
console.log(1 - true) //0
console.log(1 - undefined) //NaN
console.log(NaN + 1) //NaN

/* 
结论：
1、在数字相加减中，false =0 ; true = 1;
2、数字减字母，输出NaN
3、数字加[](空数组)，变成字符串类型的数字
4、字符串加任何字符都是拼接字符串
5、NaN加任何字符（数字，字母）都是输出NaN
6、typeof null输出是object
*/
```

#### 结论

**1、在数字相加减中，false =0 ; true = 1;**
**2、数字减字母，输出NaN**
**3、数字加空数组[]，变成字符串类型的数字**
**4、字符串加任何字符都是拼接字符串**
**5、NaN加任何字符（数字，字母）都是输出NaN**
**6、typeof null输出是object**

**7、值+字符串/对象：字符串拼接（有原始值的对象排除在外）**

**8、{}+值：此处的{}被认为是代码块，不参与运算，只处理+值**

**9、值+{}：参与运算**   {}--对象转换为字符串，调用的是原型上的Object.__proto__.toString()，是用来判断数据类型的，不是用来转换的，所以对象转换为字符串的结果都是"[object Object]"
![image-20200813001927895](https://i.loli.net/2020/08/13/nJChcWIsKZGeBQD.png)

**10：+值/++值/值++：数学运算**



