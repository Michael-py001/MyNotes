[TOC]



### 如何声明一个变量

- var/function/let/const/import 'xxx'
- 命名规范：
  - 严格区分大小写  body Body 是两个不同的变量
  - 采用驼峰命名法
  - 不能以数字开头
    - $xxx 基于JQ选择器获取的内容都存储在以$开头命名的变量中
    - _xxx 下划线开始的变量一般认为是公共变量（或者是仅供内部使用的）
  - 不能使用关键字和保留字

### JS中的九大数据类型

#### 	基本数据类型/原始值

- 数字 number  [0 1 -1 NaN Infinity]
 	- 字符串 string  
 	- 布尔 boolean  [true flase]
 	- 空 null
 	- 未定义 undefined
 	- 唯一值 symbol

- 大整型 bigint

#### 引用数据类型

- 对象类型 object
  - 普通对象 {xxx:'xxx'}
  - 数组对象 [10,20]
  - 正则对象 /^\d+$/
  - 日期对象 new Date() Tue Aug 04 2020 10:27:31 GMT+0800 (中国标准时间)
- 函数类型 function
  - 普通函数
  - 匿名函数
  - 回调函数
  - 函数表达式

### NaN

- not a number 不是一个有效数字，但是属于number数据类型

  ```
  console.log(typeof NaN) ==>'number'
  ```

- NaN与任何值都不相等，包括自己

  ```
  console.log(NaN == NaN); //=>false
  ```

- 可以使用Object.is(a,b)检测两个值是否相对

  ```
  console.log(Object.is(NaN, NaN)); //=>true
  ```

### Symbol 唯一值

```js
唯一值
let val = Symbol('00'); //创建一个唯一值00
console.log(val == val); //=>true
console.log(Symbol('AA') == Symbol('AA')); //=>false  因为每个Symbol('xx')都是新的唯一值
```

### bigint

>  console.log(Number.MAX_SAFE_INTEGER); ==>9007199254740991
>
> JS中的最大安全数，超过这个值的，需要用bigint处理（在一个数值后面加n就是bigint类型）
>
> 例如：9007199254740991999n  

**练习**：

```js
let res = parseFloat('left:200px'); //NaN
if (res === 200) {
    alert(200);
} else if (res === NaN) { //NaN!==NaN
    alert(NaN);
} else if (typeof res === 'number') {
    // typeof NaN==="number"
    alert('number'); //=>"number"  ==>正确答案
} else {
    alert('Invalid Number');
} 
```

### 对象

> 优多组键值对(属性和属性值)组成
>
> 每一个对象都是一个复杂的数据结构，包含很多描述自己特征的属性，而对象诞生的目的，就是为了把描述同一个事物的属性(键值对)放在一起，以此来解决多个对象中描述冲突的问题

#### 操作对象中的成员

> 对象的每个成员(属性名/键)可以是数字，字符串，js规定object的键名一律为字符串，数值键名会被自动转换成字符串

- 获取成员的值
  - 对象.成员  person.name 【注意】此方法不适用于数字成员,如person.1(报错Uncaught SyntaxError: Unexpected number)
  - 对象[成员]   person[1]  person['name']
  - 如果对象中没有这个成员，获取的值是undefined
- 新增或修改成员的值
  - 一个对象的成员不能重复，如果重复则以最后的值为主
  - 修改成员值时，若该成员不存在则设置一个新成员，若存在则修改值
- 删除对象的成员
  - 假删除：把成员值修改为null/undefined即可
  - 真删除：彻底删除 => delete 对象[成员]
  - 全部删除：obj.length = 0

### 数组对象

> 数组是特殊的对象，由零到多组键值对组成；
>
> 无需写属性名，直接写的是属性值，属性名默认是数字
>
> 默认有一个length的属性，存储的是数组长度

```js
var arr = [10, 20, 30];
console.log(arr.length); // => arr['length']
console.log(arr[1]); // 基于索引获取数组中的指定项信息
```

### 数据类型检测

- typeof [value]
- instanceof
- constructor
- Object.prototype.toString.call([value])

#### 基于typeof检测数据类型

- 检测结果是一个字符串，字符串中包含了所属类型的字符，例如：'number'/'string'/'boolean'/'undefined'/'object'/'function'...
-  typeof null -> 'object' ，事实上不属于object，是因为：所有值在计算机中都是按照2进制数据存储的(0/1)，null存储的是000，而typeof底层检测机制也是按照2进制值来检测的，并且认为以000开头的都是对象，这样导致了现有的BUG
- typeof检测对象返回都是'object'，所以没有办法用来区分是普通对象还是其他格式的对象 【局限性】

**小练习**

```js
//1、
var obj = {
    name: '小明',
    age: 17
}
console.log(obj[name])  //报错
console.log(obj['name'])//小明
```

