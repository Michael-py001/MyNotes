[TOC]

[TOC]



## JS中的多种继承方式

JS本身是基于面向对象开发的编程语言，JS中的类具备三大特征：封装、继承、多态

### 封装

类也是一个函数，把实现一个功能的代码进行封装，以此实现“低耦合高内聚”

### 多态：重载、重写

- 重写：子类重写
- 重载：相同的方法，由于参数或者返回值不同，具备了不同的功能(JS中不具备严格意义上的重载，同一个方法内，根据传参不同实现不同的功能)

### 继承

> JS中的继承跟其他语言不太一样；
>
> 继承的目的：让子类的实例同时具备父类中私有的属性和公共方法。

### JS中第一种继承方案：原型继承

> 让子类的原型等于父类的实例即可-->`Child.prototype = new Parent;`因为父类的实例可以找到父类的私有和公共方法。

```js
function Parent() {
	this.x = 100;
}
Parent.prototype.getX = function getX(){
	return this.x;
}
function Child(){
	this.y = 200
}
//一句话即可实现继承
Child.prototype = new Parent;//原型继承
Child.prototype.getY = function getY(){
	return this.y;
}
let c1 = new Child;
console.log(c1)
```

![image-20200909002924878](https://i.loli.net/2020/09/09/9iKmOrMvq6EJjZy.png)

![image-20200909012842156](https://i.loli.net/2020/09/09/O3o6ApPkKE8rRut.png)

#### 原型继承的特点

- 父类中私有属性和公有的属性方法最后都变为子类实例公有的
- 和其他语言不同的是，原型继承并不会把父类的属性方法"拷贝"给子类，而是让子类实例基于`__proto__`原型链找到自己定义的属性和方法，是“指向/查找”方式的。
- `c1.__proto__.xxx = xxx`修改子类原型(原有父类的一个实例)中的内容，内容被修改后。对子类的其他实例有影响，但是对父类的实例不会有影响，`c1.__proto__.__proto__.xxx = xxx`直接修改的是父类原型，这样不仅会影响其他父类的实例，也会影响其他子类的实例。

### JS中第二种继承方式：CALL继承

> 相当于拷贝式把父类的私有属性复制一份到子类上，缺点就是不能继承父类中公共的属性方法

```js
function Parent() {
	this.x = 100;
}
Parent.prototype.getX = function getX(){
	return this.x;
}
//在子类中
function Child(){
  //在子类构造函数中，把父类当做普通方法执行（没有父类实例，父类原型上的那些东西也就和它没有关系了）
  
  Parent.call(this);//praent里面的this.x=100，用Call后，相当于强制给c1这个实例设置一个私有的属性x，属性值100，相当于让子类的实例继承了父类的私有属性，并且也变为了子类私有的属性-->"拷贝式" 
	this.y = 200
}

Child.prototype.getY = function getY(){
	return this.y;
}
let c1 = new Child;
console.log(c1)
```

![image-20200909012955593](https://i.loli.net/2020/09/09/tazgXfmQU5DRC7j.png)

### JS中的第三中继承：寄生组合式继承(CALL继承+另类原型继承)

![image-20200919223054705](https://i.loli.net/2020/09/19/qdO2zHsPnMCQ9b5.png)

```js
function Parent() {
	this.x = 100;
}
Parent.prototype.getX = function getX(){
	return this.x;
}
//在子类中
function Child(){
  Parent.call(this);
	this.y = 200
}
Child.prototype.__proto__ = Parent.prototype
//ie浏览器下不能用__proto__，可以用以下方法
//Child.prototype = Object.create(Parent.prototype)
Child.prototype.getY = function getY(){
	return this.y;
}
let c1 = new Child;
console.log(c1)
```

![image-20200909014122648](https://i.loli.net/2020/09/09/bedYDnygXZHqcf3.png)

Child.prototype = Object.create(Parent.prototype)实现原理：

```js
let obj = {
	xxx:'xxx'
}
console.log(Object.create(obj))
```

![image-20200909014903042](https://i.loli.net/2020/09/09/1PDprHOBXokTe2Z.png)

可以看到使用Object.create( )后，会创建一个空对象，把空对象上的`__proto__`指向第一个传进来的对象，利用这个特点，我们可以写出兼容方案：

`Child.prototype = Object.create(Parent.prototype)`

解析：本来Child创建的实例c1的原型链`__proto__`是指向Child的原型`Prototype`，现在把Child的原型改变，指向`Object.create()`创建的空对象，而`Object.create(obj)`会把空对象实例的`__proto__`指向obj，所以`Object.create(Parent.prototype)`是指把空对象的`__proto__`指向`Parent.prototype`，这样，子类实例c1的原型链就变成了空对象，而空对象的原型链指向父类的原型：`c1.__proto__-->newObj`   `newObj.__proto__=Parent.prototype`

![image-20200919224103877](https://i.loli.net/2020/09/19/ymf3io8qBKrMk4A.png)

跟`Child.prototype.__proto__ = Parent.prototype`是一样的效果

### JS中的第四种继承：ES6 extends继承

> ES6上的继承，使用class 后面加extends；
>
> 注意：在子类的constructor的第一行需要加super(),不然会报错

```js
class Parent {
    constructor() {
        this.x = 100;
    }
    //在Parent的原型上设置方法-->Parent.prototype.getX = function...
    getX() {
        return this.x;
    }
}
// ES6上的继承，使用class 后面加extends
//注意：在子类的constructor的第一行需要加super(),不然会报错
class Child extends Parent {
    constructor() {
        super();//super相当于我们之前的call继承，super(100,200)，就相当一把Parent中的constructor执行， 传入100和200
        this.y = 200;
    }
    getY() {
        return this.y
    }
}
let c1 = new Child
console.log(c1);
```

