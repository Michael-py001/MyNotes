[TOC]



### 浅克隆方案

**前提代码**

```js
let obj = {
    a: 100,
    b: [10, 20, 30],
    c: {
        x: 10
    },
    d: /^\d+$/,
};
let arr = [10, [100, 200], {
    x: 10,
    y: 20
}];
```

#### 对象浅克隆

##### 1. 展开运算符

```js
let newObj = {
    ...obj
};//相当于把obj的每一项都赋予newObj
//虽然newObj是新的堆内存，但是里面的引用类型值还是原来的堆内存地址
```

#####  2. Object.assign( )合并对象

```js
let newObj = Object.assign({},obj);
//相当于把obj整个对象与新的空对象{}合并，新的对象堆内存地址是新的，但是里面的引用类型值还是原来的地址。
```

##### 3. for...in循环

> for in在遍历对象的时候，遍历是当前对象可枚举(列举)的属性
>
> + 私有属性（除一些特殊的内置属性是不可枚举的）
>
> + 公有属性（大部分都是不可枚举的，但是自己在类原型上扩展的一般都是可枚举的）
>
> 也说明了在遍历的过程中，很可能遍历到共有的属性方法**(Object.prototype上设置的公共方法)**，所以for in的循环的时候，我们需要判断是否为私有的

```js
let newObj = {};
for (let key in obj) {
   //for in在遍历的过程中，很可能遍历到共有的属性方法(Object.prototype上设置的公共方法)，所以for in的循环的时候，我们需要判断是否为私有的
    if (!obj.hasOwnProperty(key)) break;
    newObj[key] = obj[key];
} 
```

情况一：

```js
//如果在Object原型上设置公共方法，则for in 会遍历到
let obj2 = {
    name: 'lili',
    age: 12
}
Object.prototype.val = 100;
for (let i in obj2) {
    console.log(i);//name age  val
    // console.log(obj2[i]);
}
```

![image-20200905193200105](https://i.loli.net/2020/09/05/BTfr63jcy8EoSNu.png)

情况二：

```js
function Person(){
	this.x = 100;
	this.y = 200;
}
Person.prototype.z = 300;
let p1 = new Person;
for(let key in p1) {
  console.log(key)//x y z  这种情况也会导致获取的不是自己属性
}
```



#### 数组浅克隆

##### 1. 展开运算符

```js
let newArr = [...arr]
```

##### 2. Object.assign( )合并数组对象

```js
newArr = Object.assign([], arr);
```

各种循环和迭代 :

##### 3. arr.map( )

```js
newArr = arr.map(item => item);
```

##### 4. arr.slice( )

```js
newArr = arr.slice();
```

##### 5. arr.concat( )

```js
newArr = arr.concat([]);
```



### 深克隆方案

​	前提代码

```js
	let obj = {
    a: 100,
    b: [10, 20, 30],
    c: {
        x: 10
    },
    d: /^\d+$/,
    e: Symbol('AA'),
    f: new Date(),
    g: function () {},
    h: undefined,
    i: null
};
// obj.name = obj;

let arr = [10, [100, 200], {
    x: 10,
    y: 20
}];
```

#### 方案一：`JSON.stringify/JSON.parse`

> 整体变为字符串，再重新变为对象，这样浏览器会重新开辟全套的内存空间存储信息。
> 这种办法存在BUG:把对象中的某些属性值变为字符串，会存在问题：
>
> 	- 正则变为{ }
> 	- 日期对象变为日期字符串
>
> - Symbol/BigInt/function/undefined等会消失
>
> 所以这种办法适用于数据中只有 “number/string/boolean/null/普通对象/数组对象” 等内容的时候

**对象深克隆**

```js
let newObj = JSON.parse(JSON.stringify(obj));
console.log(obj, newObj);
```

![image-20200905200100633](https://i.loli.net/2020/09/05/rHSJImZCbXcyDN8.png)

**数组深克隆**

```js
let newArr = JSON.parse(JSON.stringify(arr));
console.log(arr, newArr);
```

![image-20200905200319654](https://i.loli.net/2020/09/05/x1fNgadYHs6LeiB.png)

#### 方案二：自己单独一层层遍历处理

```js
/ 方案2:自己单独一层层遍历处理
function cloneDeep(obj) {
    // 如果传递的不是对象类型，直接返回对应的值（基本类型/函数/Symbol/BigInt）
    let type = typeof obj;
    if (obj === null) return null;
    if (type !== "object") return obj;
    // 首先获取当前值的构造函数：获知它的类型
    let constructor = obj.constructor;
    // 如果是正则或者日期函数，我们则创建一个值类似但是不同实例的结果出来
    if (/^(RegExp|Date)$/i.test(constructor.name)) return new constructor(obj); //constructor就是上面获取到的obj的类
    // 如果是个对象再往下走，不然就在这之前返回结束
    // 创造对象的新实例:新数组或者新对象
    let clone = new constructor;
    for (let key in obj) {
        if (!obj.hasOwnProperty(key)) break;
        /* // 为了避免对象中的某个属性用的还是这对象，导致的循环嵌套(死递归) 代码本身就应该避免循环嵌套
        if (obj === obj[key]) {
            clone[key] = obj[key];
            break;
        } */
        //通过递归的方式，把obj的每一项都再次克隆一次，如果是基本类型值，则直接返回这个值，如果是引用类型值，则会再次创建新对象，再次遍历这个引用类型值里的每一项给到新对象(for...in)
        clone[key] = cloneDeep(obj[key]);
    }
    return clone;
}
```

