### 面试题

```js
function fun(){
    this.a=0;
    this.b=function(){
        alert(this.a);
    }
}
fun.prototype={ //原型重定向
    b:function(){
        this.a=20;
        alert(this.a);
    },
    c:function(){
        this.a=30;
        alert(this.a)
    }
}
var my_fun=new fun();
my_fun.b();
my_fun.c();			
```

### 原型重定向

- 为什么要重定向？

  > 为了方便批量给原型上扩充属性和方法

- 带来的问题

  > 1. 新定向的原型对象上没有`constructor`属性，结构不完整
  > 2. 浏览器默认生成的原型对象因为缺少引用会被释放掉，可能导致原始加入的属性和方法丢失。

  正常的完整结构：

  ![image-20200830215102370](https://i.loli.net/2020/08/30/k4upH97LK3GeZgm.png)

  重定向后的结构：-->丢失`constructor`属性，`getX`也丢失了

  ![image-20200830215405459](https://i.loli.net/2020/08/30/mh2qdPMTeyb65El.png)

那么有什么办法可以解决这个问题吗？以下列举4个重定向方法。

### 原型重定向的方案

#### 1.设置别名

> 缺点：步骤繁琐，且会丢失`construction`及之前设置的属性方法

```js
function Fn() {
    this.x = 100;
    this.y = 200;
}
let A = Fn.prototype;
A.getX = function () {};
A.getY = function () {};
A.getZ = function () {};
```

#### 2.一次性设置多个方法

> 最常用的方法

```js
function Fn() {
    this.x = 100;
    this.y = 200;
}
Fn.prototype = {
    getX() {},
    getY() {},
    getZ() {}
};
```

#### 3.手动设置`constructor`

> 如果原始原型对象上不存在其他属性方法，我们只需要把constructor手动设置一下即可

```js
function Fn() {
    this.x = 100;
    this.y = 200;
}
Fn.prototype = {
    // 原始原型对象上如果不存在其他属性方法，我们只需要把constructor手动设置一下即可
    constructor: Fn,
    getX() {},
    getY() {},
    getZ() {}
};
let f1 = new Fn;
```

#### 4.`Object.assign`合并对象

> `Object.assign(对象1,对象2)`：合并两个对象，重复的属性以对象2为主

```js
function Fn() {
    this.x = 100;
    this.y = 200;
}
Fn.prototype.z = 300;
// 重定向之前，最好拿新原型对象和原始的原型对象合并一下 
// Object.assign(对象1,对象2)：合并两个对象，重复的属性以对象2为主
Fn.prototype = Object.assign(Fn.prototype, {
    getX() {},
    getY() {},
    getZ() {}
});
let f1 = new Fn; 
```

