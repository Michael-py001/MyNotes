### 目录

[TOC]



### 把其他数据类型转换为Number类型

#### 	1. 直接转换成为Number

```js
	- Number([value])
	- parserInt/parseFloat([value])
```

#### 2.隐式转换

> 浏览器内部默认要先转换为Number再进行计算

- isNaN([val])
- 数学运算（特殊情况：+在出现字符串的情况下不是数学运算，是字符串拼接）
- 在==比较的时候，有些值需要转换为数字再进行比较

#### Number([value])规则

1. ##### 把字符串转换为数字

   > 要求字符串中的字符都必须是有效数字才能转换，如果包含字母或其他字符，则返回NaN

```js
console.log(Number("")); // 0  空字符串转数字变成0
console.log(Number("10")); // 10
console.log(Number("10px")); // NaN
```

2. ##### 把布尔转换为数字

   > true --- 0 ; false---1

   ```js
   console.log(Number(true)); // 1
   console.log(Number(false)); // 0
   ```

   

3. ##### 把空转换为数字

   ```js
   console.log(Number(null)); // 0
   console.log(Number(undefined)); // NaN
   ```

   

4. ##### 把Symbol/BigInt转换为数字

   ```js
   console.log(Number(Symbol(''))); // 不允许转换
   console.log(Number(BigInt(10))); // 10
   ```

   

5. ##### 把对象或者函数转换为数字

   > 先用Symbol.toPrimitive，再用valueOf()，如果返回是原始值则转为数字并返回，如果不是原始值，则继续调用toString把对象转换为字符串，再把字符串转换为数字

   对象类型转换为数字机制，Symbol.toPrimitive->valueof->toString有任意一种就可以调用自己的私有方法

   **注意**：只有普通对象-->{} 调取toString()是调取Object.prototype.toString()，是用来检测数据类型的，所以返回结果是'[object Object]'
   
   ```js
   console.log(Number({
       0: 10
   })); // NaN  =>普通对象.toString()是检测数据类型"[object Object]"，再转换为数字NaN
   console.log(Number([10])); // 10  =>数组.toString()是转换为字符串"10"
   console.log(Number([10, 20])); // NaN  先转换为"10,20"，这包含的','不是有效数字，所以最后输出NaN
console.log(Number([])); // 0  =>空数组转字符串为""，空字符串转数字变成0
   ```

   #### parseInt/parseFloat([val])转换规则

   > 先把[val]值转换为字符串，再按照从字符串左边第一个字符开始查找，把所有找到的有效数字字符变为数字（直到遇到一个非有效的数字字符则停止查找），如果一个有效数字字符都没有找到，返回结果就是NaN（parseFloat只是比parseInt多识别一个小数点而已）
   
   ```js
   console.log(parseInt("10px12")); // 10  后面的p就开始不解析的
   console.log(parseInt("10.5px")); // 10
   console.log(parseFloat("10.5px")); // 10.5
console.log(parseInt("width:10px")); // NaN 
   ```
   
   

### 把其它数据类型转换为字符串

#### 直接转换

- toString()
- String()

#### 隐式转换

> 一般都是借助调用toString()转换

1. 在加号运算的时候，如果**加号的某一边出现字符串**，则不是数学运算，而是字符串拼接
2. 把**对象转换为数字**，需要先**toString()转换为字符串**，再去转换为数字
3. 基于alert/confirm/prompt/document.write...这些方式输出内容，都是把内容先转换为字符串，然后再输出的

 **注意**：除了“普通对象.toString()调用的是Object.prototype.toString，这个方法是检测数据类型的，其余的都是调用自己类原型上的toString，用来转换字符串。

{}/{a:10}.toString() ==> [object Object]  普通对象转字符串都是输出同一个

### 把其它数据类型转换为布尔

#### 直接转换

1. ! 转换为布尔值，然后取反
2. !! 转换为布尔值
3. Boolean([value])

#### 隐式转换

1. 在循环或在条件判断中，条件处理的结果就是布尔值类型

#### 规则：

直接记住这几个规则去判断：

**只有 ‘0、NaN、null、undefined、空字符串’ 五个值会变为布尔的FALSE，其余都是TRUE**

```js
console.log(!0); // true
console.log(!!0); // false
console.log(!![]); // true
if(1){
	// 要把1先转换为布尔，验证真假
}

!!({})  TRUE  验证是否为空对象

```

### 练习

1. ```js
   let result = 10 + false + undefined + [] + 'Tencent' + null + true + {};
   console.log(result);
   //步骤
   10 + false ==>10 + 0 = 10
   10 + undefined ==>先把undefined转数字，为NaN(任何数加NaN都是NaN), 10+NaN = NaN
   NaN + [] ==> NaN + 0 = NaN
   NaN + 'Tencent' = 'NaNTencent' 开始字符串拼接了
   'NaNTencent'+null = 'NaNTencentnull'
   'NaNTencentnull'+ true = 'NaNTencentnulltrue'
   'NaNTencentnulltrue' + {} = 这里注意的是对象转字符串结果是'object Object'
   所以最终结果为：'NaNTencentnulltrue[object Object]'
   ```

   

2. ```js
   parseInt("") // NaN
   Number("") // 0
   isNaN("") // false   isNaN(Number("")) -> isNaN(0)
   parseInt(null) // NaN   parseInt("null")
   Number(null) // 0
   isNaN(null) // false  isNaN(Number(null)) -> isNaN(0)
   parseInt("12px") // 12
   Number("12px") // NaN
   isNaN("12px") // true
   parseFloat("1.6px") + parseInt("1.2px") + typeof parseInt(null)
   // 1.6 + 1 + "number" => "2.6number"
   isNaN(Number(!!Number(parseInt("0.8"))))
   // parseInt("0.8") -> 0
   // !!Number(0) -> false
   // Number(false) -> 0
   // isNaN(0) -> false
   typeof !parseInt(null) + !isNaN(null)
   //parseInt(null) == >0  
   //!0 ==>先转换成布尔值，再取反 !false ==> ture
   // typeof true -> "boolean"
   // !isNaN(null) -> true
   // "booleantrue" 
   ```

   

### ==与===的比较

- == : 普通比较
- ===：绝对比较(switch case基于===比较)

如果左右两边数据类型不一致，==会默认把数据类型转换为一致的，再去进行比较；

===则直接返回false，因为它要求数据类型和值都一样才相等（严谨）；

#### ==比较的转换规则

- 【类型一样的几个特殊点】
  - {}=={}：false 对象比较的是堆内存的地址
  - []==[]：false
  - NaN==NaN：false
- 【类型不一样的转换规则】
  -  null==undefined：true，但是换成===结果是false（因为类型不一致），剩下null/undefined和其它任何数据类型值都不相等
  - 字符串==对象 要把对象转换为字符串
  - 剩下如果==两边数据类型不一致，都是需要转换为数字再进行比较

```js
console.log([] == false); // TRUE  
// 规则：比较过程中，两边数据值不一样，都转换为数字再比较
// 0 == 0

console.log(![] == false); // TRUE
// 规则：优先级高，先算![] => 记住：只有'0 NaN null undefined 空字符串'这五个是flase，，其余的都是true，所以空数组是true,==>!true = false
// false == false  ==> 答案是true
```

