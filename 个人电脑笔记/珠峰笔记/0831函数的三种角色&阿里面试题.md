### 函数的三种角色

1. 普通函数
   - 闭包作用域

2. 构造函数
   - new
   - 类和实例
3. 普通对象
   - 键值对

三种角色之间没有必然的联系

### 函数和对象的关系

- Object通过`__proto__`能够找到原型链是Function，所以Object是Function的一个实例

- Function的`__proto__`指向自己的`prototype`，但是它的`prototype`的`__proto__`指向Object的`prototype`，所以Function也是Object的一个实例

- Object的`__proto__`指向Function的`prototype`，但是Function的`prototype`的`__ptoto__`又指向回了Object的`prototype`，所以Object也是Object的一个实例

  `Object.__proto__.__proto__` === `Object.prototype`

- Function的`prototype`指向自己的`__proto__`，所以Function也是Function的一个实例

  `Function.prototype`===`Function.__proto__`

在Function.prototype上有call/apply/bind三种改变this的方法，所以所有的函数包括Object/Array/Function都可以调用。

### 面试题

**JS中运算符优先级的问题：**

- obj.xxx 成员访问：19
- new Foo()带参数 19
- new Foo不带参数 18
- 如果优先级一样，一般是从左到右运算

```js
function Foo() {
    getName = function () {
        console.log(1);
    };
    return this;
}
Foo.getName = function () {
    console.log(2);
};
Foo.prototype.getName = function () {
    console.log(3);
};
var getName = function () {
    console.log(4);
};
function getName() {
    console.log(5);
}
Foo.getName();//2
getName();//4
Foo().getName();//运行Foo()，返回值.getName(),返回的是this-->window
//所以调用的是全局的getName()-->1
getName();//1
new Foo.getName();//运算符优先级的问题
/*
JS中运算符优先级的问题：
obj.xxx 成员访问：19
new Foo()带参数 19
new Foo不带参数 18
如果优先级一样，一般是从左到右运算
...
所以先运算Foo.getName -->function=>2
-->new function=>2 在new的过程中会运行函数，所以输出2
*/
new Foo().getName();
/*new Foo()和Foo().getName()优先级一样，所以从左往右执行
new Foo()-->创建一个实例A
new Foo().getName()等于A.getName()-->查找的是原型链上的getName-->输出3
*/
new new Foo().getName();
/*
new function () {console.log(3);
new的过程中也会执行函数，所以输出3
};
*/
答案：2411233
```

