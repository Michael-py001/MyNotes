[TOC]



## jQ代码的核心

```js
(function (global, factory) {

	"use strict";

	if (typeof module === "object" && typeof module.exports === "object") {

		module.exports = global.document ?
			factory(global, true) :
			function (w) {
				if (!w.document) {
					throw new Error("jQuery requires a window with a document");
				}
				return factory(w);
			};
	} else {
		factory(global);
	}

})(typeof window !== "undefined" ? window : this, function (window, noGlobal){
    //jQ代码的核心在这
}

```

### jQuery暴露到全局&jQ选择器

```js
(function (global, factory) {
	//...
})(typeof window !== "undefined" ? window : this, function (window, noGlobal){
    //jQ代码的核心在这
  var
		version = "3.5.1",
		// Define a local copy of jQuery
		jQuery = function (selector, context) {
			//$('selector')选择器的代码入口
			return new jQuery.fn.init(selector, context);
		};
	// 暴露到全局
    if (typeof noGlobal === "undefined") {
        window.jQuery = window.$ = jQuery;
      //$===jQuery===函数内部的jQuery
      //JQ选择器就是把JQ方法执行 [selector]选择器  [context]上下文(默认:document)
      //$([selector],[context])
      //jQuery([selector],[context])
    }
}
```

### 防止多库共存“$冲突”：JQ转让$使用权的方法

> 转让$使用权：导入JQ的时候，首先它会记录之前$的使用情况，存储到_$中；并且让$归为JQ；当执行noConflict的时候，把$的使用权回归_$，返回JQ，外部变量j是JQ新的代言人；

```js
    // 在jQuery执行之前，就把当前的$和jQuery保存起来
    var _jQuery = window.jQuery, //保存当前window中的jQuery
        _$ = window.$; //保存window中的$,可能是Zepto中的$
    jQuery.noConflict = function (deep) {
        if (window.$ === jQuery) {
            window.$ = _$;
        }
        if (deep && window.jQuery === jQuery) {
            window.jQuery = _jQuery;
        }
        return jQuery;
    };

    // 暴露到全局
    if (typeof noGlobal === "undefined") {
        window.jQuery = window.$ = jQuery;
    }
```

```js
/* 
 * <script src='zepto.min.js'>   Zepto使用的也是$
 *   $ -> Zepto
 * 
 * <script src='jquery.min.js'>  jQuery使用的也是$
 *   在jQ还没加载完之前，做了一些事情:用_$保存当前的$，也就是说_$代表的是Zepto,加载完后$就变成了jQ了
 *      + var _$=window.$   _$->Zepto
 *   $ -> jQuery
 * $.noConflict()-->执行这个方法就把$转让出去了
 * 如果想重新恢复使用jQ，noConflict返回的是jQ,所以只需要定义一个变量接收一下，这个变量就是jQ了，可以使用这个变量执行jQ的方法
 * var j=$.noConflict() 转让了$使用权
 *   做了一些事情：
 *      + window.$ = _$
 *      + return jQuery
 *   $ -> Zepto
 *   j -> jQuery-->j就代表了jQuery
 */
```

如果noConflict( deep )传一个true，就相当于把jQuery的使用权也转让出去，比如导入多个jQ版本时，传入true可以回退到上个版本。然后新版本jQ可以使用j来接收使用。

### jQuery核心部分

> JQ的代码核心：jQuery既是一个普通函数、也是一个构造函数、也是一个普通的对象。

JQ中提供的方法 

+ jQuery.prototype「类」 供其实例调用的公共属性方法 $(...).xxx()
  ![image-20200907212951658](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200907212951658.png)

+ jQuery「对象」 这上面的方法是类库提供的工具类方法 $.xxx()
  ![image-20200907212714285](https://i.loli.net/2020/09/07/IQVWvKA5TUP24EF.png)

#### jQuery的"工厂模式"

> 因为jQuery返回的是`new jQuery.fn.init(selector,context)`，也就是说$(...)执行是创造了init这类的一个实例，而init的原型链就是jQuery的原型-->`实例.__proto__`===`init.prototype`===`jQuery.prototype`，所以也可以说$(...)创造出来的是jQuery类的一个实例 =>“把jQuery当作普通函数执行，也可以创造它的一个实例「工厂模式」”

```js
	  var rootjQuery = jQuery(document);//获取document
    var init = jQuery.fn.init = function (selector, context, root) {
        var match, elem;
        // 如果传入的是""/null/undefined/false，直接返回jQuery.fn.init
        if (!selector) return this;
        root = root || rootjQuery;
				//开始判断传进来的是【字符串】还是【DOM元素】还是【函数】
        if (typeof selector === "string") {
            // 字符串
            //   + HTML结构字符串  创建一个DOM元素  跟原生的createElement类似
            //   + 选择器字符串  获取页面中符合条件的元素
            /* if (selector[0] === "<" &&
                selector[selector.length - 1] === ">" &&
                selector.length >= 3) {} else {} */
            //...
        } else if (selector.nodeType) {
            /*  真实项目中，我们会遇到JQ对象(JQ实例/类数组集合)和原生DOM对象相互切换的过程 
             *     + JQ对象不能用原生内置的属性方法
             *     + 原生DOM对象也不能用JQ原型上的方法
             * 
             *   原生DOM->JQ对象
             *     + $(原生DOM)
             * 
             *   JQ对象->原生DOM
             *     + JQ对象[索引]
             *     + JQ对象.get([索引])  上述两个都是获取原生DOM对象的
             *     + JQ对象.eq([索引])   获取的结果还是JQ对象(类数组集合/JQ新的实例)，里面存储一项：索引对应的 
             */

            // 原生DOM元素对象(JS内置方法获取的)：把DOM对象变为了一个类数组集合
            this[0] = selector; //给jQuery添加了一个0属性，代表着这个原生的DOM元素
            this.length = 1;
            return this; //返回添加属性后的jQuery
        } else if (isFunction(selector)) {
            // 函数 $(function(){}) <==> $(document).ready(function(){})
            // 等待页面中DOM结构加载完成(DOMContentLoaded)触发回调函数函数执行，触发点优先于window.onload(DOM结构及页面中所有资源都加载完才会触发执行)
            /*  所以我们在使用JQ时，一般这样使用：
                 $(function () {
                    // DOM结构加载完触发执行
                    // JQ不论是在HEAD还是BODY末尾导入，都可以获取到DOM元素
                }); 
            */
            return root.ready !== undefined ?
                root.ready(selector) :
                selector(jQuery);
        }

        // 创造一个类数组集合
        return jQuery.makeArray(selector, this);
    };
    init.prototype = jQuery.fn;
```

### jQuery.prototype的构造函数

```js
// 构造函数
    jQuery.fn = jQuery.prototype = {
        constructor: jQuery, //原型重定向后constructor会丢失，需要手动设置
        jquery: version,
        get: function (num) {
            // 把JQ类数组集合变为数组集合(Array的实例)
            if (num == null) {
                return Array.prototype.slice.call(this); //slice是支持负数索引的
            }
            // 支持负数索引
            return num < 0 ? this[num + this.length] : this[num];
        },
        eq: function (i) {
            var len = this.length,
                j = +i + (i < 0 ? len : 0); //也是为了支持负数索引

            return this.pushStack(j >= 0 && j < len ? [this[j]] : []); //传入的是[this[j]]
        },
        // 传递一个数组，我们把其变为JQ实例
        pushStack: function (elems) {
            // this.constructor()：jQuery()，空集合(JQ实例)
            // 合并后的结果，既是一个JQ实例(集合)，也包含你传递进来的这些项的信息
            var ret = jQuery.merge(this.constructor(), elems); //this.constructor()-->是jQuery的一个空集合，elems-->上面传入的[this[j]]-->元素索引，merge把两者合并
            ret.prevObject = this;
            return ret;
        },
    };
```

#### eq和get的区别：

![image-20200908001546872](https://i.loli.net/2020/09/08/r6EbmlONRvgCic2.png)

#### $('xxx')创建DOM元素：

![image-20200908001617746](https://i.loli.net/2020/09/08/sgez3QvP6x4brSm.png)