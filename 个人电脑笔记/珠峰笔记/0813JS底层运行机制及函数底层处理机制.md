### 目录

[TOC]



### JS是在哪运行的？

​	首先，JS是一种解释语言，需要解释器去把代码翻译成机器能读懂的代码，然后执行。

浏览器之所以能运行代码， 是因为提供了一个代码运行的环境，也可以说是一个解释器引擎；

如：浏览器（引擎/内核）、node.js、webview

### 执行上下文--EC(Execution context)

> Execution context , 执行上下文，代码执行所在的词法作用域，或者代码执行所处的范围

执行上下文（Execution Context）是ECMAScript规范中用来描述 JavaScript 代码执行的抽象概念，规定了当前代码执行的环境(当前执行代码片段中的变量、函数、作用域链等)，所有执行上下文又叫执行环境。	

<img src="https://i.loli.net/2020/08/15/thCVlEODmZrSc6b.png" alt="img" style="zoom:67%;" />

JavaScript中有三种执行上下文类型：

- **全局执行上下文(Global Execution Context)**——代码首次执行时的默认环境，任何不在函数内部的代码都在全局上下文中，，一个程序中只会有一个全局执行上下文。他会执行两件事，（在浏览器的情况下）

  1、创建一个全局的window对象

  2、将this指向window对象

  ​	全局对象window上预定义了大量的方法和属性，由于是最先入栈的执行上下文，所以在程序结束前，这个栈都不会被清空，所以我们在任意处都能直接访问到这些属性。

  ​	同时window对象还是var声明的全局变量的载体（let/const不是），我们通过var创建的全局对象都可以通过window直接访问。

  ![image-20200815155045008](https://i.loli.net/2020/08/15/fVZmNylWriDM6tz.png)

- **函数执行上下文(Functional Execution Context)**—— 每当一个函数被调用时，都会为该函数创建一个新的上下文；注意：同一个函数被多次调用，都会创建一个新的上下文。而函数的上下文是一个**私有域**，函数内部做出的所有声明都会放在这个私有域中，并且这些声明在当前函数作用域（也就是当前函数的执行上下文）以外是无法直接访问的，我们把函数执行的这种保护机制成为**“闭包”**

- **Eval函数执行上下文(Eval Function Execution Context)**—由于eval函数不常用，所以这里不细说。



### ECStack 执行上下文栈

> Execution context stack，执行环境栈|执行上下文栈，下文简称执行栈

​	浏览器中的JS解释器是单线程的，也就是说浏览器在同一时间只能做一件事，而函数每次调用都会产生新的执行上下文，那么这些执行上下文是怎么管理和按什么顺序执行的呢？这里就要引入一个执行上下文栈的概念。

​	我们都知道栈的特点是**先进后出**，JS首次运行，都会把一个全局执行上下文压入执行栈，后续按函数调用的顺序，把调用函数产生的执行上下文依次入栈，浏览器会一直执行栈顶的执行上下文，一旦这个函数执行完，该上下文就会被推出执行栈将控制流返回给它下面的执行上下文，一直到全局上下文。所以程序结束前，栈底一直会有一个全局执行上下文。

为了模拟执行上下文的行为，我们把执行上下文作为一个数组：

```
ECStack = [];
```

上面我们说到，JS代码开始执行时，就会先把一个全局执行上下文压入栈底：

```js
ECStack = [
    EC(Global)
];
```

接下来JS遇到了下面这段代码：

```js
function fun3() {
    console.log('fun3')
}

function fun2() {
    fun3();
}

function fun1() {
    fun2();
}

fun1();
```

上面说到，每一次调用函数都会创建一个新的执行上下文，当函数执行完后，会把该上下文弹出栈，所以上面的代码运行过程可以写为：

```js
//伪代码
//首次运行，把全局执行上下文压入栈底
ECStack.push(EC(Global))
//fun1执行，入栈
ECStack.push(EC(fun1))
//fun1中调用了fun2,创建一个新的执行上下文(fun2)，入栈
ECStack.push(EC(fun2))
//fun2中调用了fun3,创建一个新的执行上下文(fun3)，入栈
ECStack.push(EC(fun3))
//fun3执行完，该上下文弹出栈顶
ECStack.pop();
//fun2执行完，该上下文弹出栈顶
ECStack.pop();
//fun1执行完，该上下文弹出栈顶
ECStack.pop();
//最后只剩下一个栈底的全局执行上下文EC(Global)
```



下面的例子展示了一个递归函数以及该程序的执行栈：

```js
(function foo(i) {
  if (i === 3) {
    return;
  }
  else {
    foo(++i);//即使执行的是同一个函数也会创建新的EC
  }
}(0));
```

![img](https://i.loli.net/2020/08/15/8STa4UyWGcwK3Rt.gif)



例子二：

```js
var a = 10;
var b = 'hello';

function fun01 () {
    console.log('i am fun01...');
    fun02();
}

function fun02 () {
    console.log('i am fun02...');
}

fun01();
```

js的运行采用栈的方式对执行上下文进行管理，栈底始终是全局上下文，栈顶始终是正在被调用执行的函数的执行上下文。

![img](https://i.loli.net/2020/08/15/cOa1RFonAfgb9LX.png)

```
1.当js文件开始执行时，创建全局上下文，并push到call stack；

2.fun01()被调用时，创建fun01上下文，push到call stack；

3.fun02()被调用时，创建fun02上下文，push到call stack；

4.fun02()执行完毕，fun02上下文pop出栈，等待被回收；

5.fun01()执行完毕，fun01上下文pop出栈，等待被回收；

6.全局执行环境不会出栈；
```

关于执行栈，需要记住5点：

- 单线程
- 同步执行
- 一个全局上下文
- 无数个函数上下文
- 每次函数被调用都会创建一个新的执行上下文，调用自身也会

### 如何创建执行上下文？

​	到目前，我们已经知道JavaScript是如何管理执行上下文以及上下文的执行顺序，现在我们来了解一下JavaScript引擎是如何创建执行上下文的。下面先ES3的理解去说明。ES5的新理解下次再说。

#### 在ES3中对执行上下文的理解

​	创建执行上下文分为两个阶段：

1. 创建阶段
2. 执行阶段

##### 创建阶段[函数被调用，但还未执行任何代码之前]

1. **创建作用域链**(Scope Chain)

   为作用域链上的每一个函数、变量与外部环境建立连接，这告诉了执行上下文应该包含什么以及从哪里查找函数引用以及变量的值

   - 对于全局环境，外部环境为null。而全局环境内的所有环境都以全局环境作为其外部环境。
   - 例如：如果函数a包含在函数b中，这意味着a有一个外部环境b。

2. **创建变量、函数、参数**(variables, functions and arguments)

   在扫描完作用域链后，就创建了一个环境记录，其中全局上下文的创建和引用、变量、函数和函数参数(arguments)都在内存中完成。

3. **定义this**，在第一步中创建的每个执行上下文中定义this的值，但不会确定。

因此，我们可以将创建阶段表示为：

```js
创建阶段 = {
  scopeChain: {
        /* 作用域链解析 */ 
    },    
  variableObject: {
        /* arguments, 函数参数, 内部变量 等等*/ 
    },
  this: {},//定义，但未确定值
}
```

**scopeChain:** 在执行上下文的创建阶段，作用域会在**变量对象**创建之后创建。作用域链本身包括变量对象。作用域负责解析变量，当被要求解析变量的时候，会从代码嵌套结构的最内层开始，如果在最内层没有找到对应变量，则依次向父级作用域中进行查找，直到寻找到最外层作用域。

**variableObject:** 用当前函数的参数列表（arguments）初始化一个“**变量对象**”，并与当前执行上下文与之相关联，在函数内中声明的变量和函数讲作为属性添加到这个变量对象上（而值就是一个内存引用地址）。在这一阶段会进行变量和函数的初始化声明，**var**声明的**变量**统一定义为**undefined**，需要赋值时才会有确值，而**函数**则会在变量对象里创建一个和函数名一样的属性，该属性作为一个引用指针指向函数代码在堆内存中的地址。

​	需要注意的是，在ES6中的let，const声明的变量不会定义为undefined，而是一个`uninitialized`未初始化的状态，存在暂时性死区。

> 其实这段描述的操作就是**变量声明提升**（变量和函数声明都会提升，但函数提升更靠前，注意只是声明会提升，赋值不会提升）

**this**: 确定`this`的指向，这里需要注意的事`this`的值是在执行的时候确定的，在定义的时候并不会确定。

##### 执行阶段

​	接下来就是所有执行上下文的运行阶段

1. 逐行分配变量值。

2. 寻找执行函数的引用。如果不能在自己的作用域找到它，它将继续向上查找，直到到达全局环境。

   如果在全局环境中没有找到引用，它将返回一个错误。如果找到了一个引用并且函数执行正确，则将该函数的执行上下文从执行栈中弹出，继续运行下一个函数。

例题一：有这么一段代码：

![image-20200815214231431](https://i.loli.net/2020/08/15/hqNZL1OmcSyrR3d.png)

​				在创建阶段，全局执行上下文类似于这样：

```js
globalExecutionObj = {
    outerEnvironmentConnection: null,
    variableObjectMapping: {
        name: uninitialized,//为初始化状态
        title: undefined,//var声明
        date: uninitialized,
        func1: func,
    },
    this: window //Global Object
}
```

​	 **注意:**上面，`let (name)`和`const (date)`定义的变量在创建阶段没有任何关联的值，但是`var (title)`定义的变量会被设置为`undefined`。

这就是为什么咱们可以在声明`var`定义的变量之前访问它们**(虽然没有定义)**，但是在声明`let`和 `const`变量之前访问它们时，会得到一个引用错误。

这就是我们所说的**变量提升**，即所有使用`var`的变量声明都被提升它们的局部作用域(在函数内部声明)或者全局作用域的顶部(在函数外部声明的)。

在执行阶段，完成变量分配。全局上下文类似如下：

```js
globalExectutionObj = {
    outerEnvironmentConnection: null,
    variableObjectMapping: {
        name: "overflowjs.com",
        title: "Execution context",
        date: "5 july 2019",
        func1: pointer to function func1,
    },
    this: window //Global Object
}
```

**注意:**在执行阶段，如果JS引擎在源代码中声明位置找不到`let`变量的值，那么它将为其赋值`undefined`。

现在，当`func1`执行，就会生成一个新的函数执行上下文，其创建阶段类似如下：

```js
func1ExecutionObj = {
    outerEnvironmentConnection: Global,//外部环境为全局
    variableObjectMapping: {
       arguments: {
            0: 10,
            length: 1
        },
        num: 10,//形参会拷贝一份
        author: undefined,
        val: uninitialized,
        func2: undefined
        fixed: uninitialized
        addFive: pointer to function addFive()
    },
    this: Global Object or undefined
}
```

在执行阶段类似如下：

```js
func1ExecutionObj = {
    outerEnvironmentConnection: Global,
    variableObjectMapping: {
       arguments: {
            0: 10,
            length: 1
        },
        num: 10,
 
        author: "Deepak",
        val: 3,
        func2: pointer to function func2() 
        fixed: "Divine"
        addFive: pointer to function addFive()
    },
    this: Global Object or undefined
}
```

例二：

```js
function foo(i) {
    var a = 'hello';
  	let b = 'hi'
    const c = 'good' 
    var d = function privateD() {

    };
    function e() {

    }
}

foo(22);
```

当调用foo(22)**函数**的时候，创建阶段的函数执行上下文大致是下面这样：

```js
fooExecutionContext = {
    scopeChain: { ... },
    variableObject: {
        arguments: {  // 创建了参数对象
            0: 22,
            length: 1
        },
        i: 22,  // 检查上下文，创建形参名称，赋值/或创建引用拷贝
        e: pointer to function e()  // 检查上下文，发现内部函数声明，创建引用指向函数体,此处比变量早，也就是变量提升中函数比变量提前的原因
        a: undefined   // 检查上下文，发现内部声明变量a，初始化为undefined，此时并不赋值，右侧的函数作为赋值语句，在代码未执行前，并不存在
        b: uninitialized;//let声明的变量是未初始化状态
        c:  uninitialized;//const声明的变量是未初始化状态
    },
    this: {...}//函数上下文，执行时确定值 如果是全局上下文，则是window
}
```

###  Activation / Variable Object [AO/VO]



#### VO 变量对象

> Variable Object 变量对象，注意：是一个对象，里面可以存放很多属性。

在每一个上下文代码执行的时候，都会创建一个叫变量对象(Variable Object)的东西(无论是在全局还是函数中都会创建一个)并与之相关联。**变量对象是与执行上下文相关的数据作用域**，存储了在上下文中定义的**变量**和**函数**声明以及当前执行上下文函数的参数列表。

<img src="https://i.loli.net/2020/08/15/qg5PFAw1LbNScUD.png" alt="img" style="zoom: 50%;" />

##### 变量对象的创建过程

![image-20200815222620121](https://i.loli.net/2020/08/15/cXDmEwS24pZCYdk.png)

变量对象是在函数被调用，但是函数尚未执行之前（也就是执行函数上下文的创建阶段）被创建的，这个创建变量对象的过程实际就是函数内数据(函数参数、内部变量、内部函数)初始化的过程。

### AO

> Active Object 活动对象

未进入执行阶段之前，变量对象中的属性都不能访问！但是进入执行阶段之后，变量对象转变为了**活动对象**，里面的属性都能被访问了，然后开始进行执行阶段的操作。所以活动对象实际就是变量对象在真正执行时的另一种形式。

### GO

> Global Object 全局对象

全局对象不是全局变量对象，在浏览器最开始加载代码的时候，不仅提供了一个栈内存供代码执行，还默认开辟了一个堆内存，存储了一些内置的属性和方法，这个堆内存的指向就是window对象，

### 执行上下文的声明周期

![image-20200815223021126](https://i.loli.net/2020/08/15/Gh91om7TSVfrM8u.png)

参考引用资料：

[【JS】什么是AO-VO]([https://blog.nixiaolei.com/2019/06/10/%E3%80%90JS%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AFAO-VO-GO/](https://blog.nixiaolei.com/2019/06/10/[JS]什么是AO-VO-GO/))

[面试官：说说执行上下文吧](https://juejin.im/post/6844904158957404167)

[JS执行上下文的两个阶段做了些啥？](https://blog.csdn.net/qq449245884/article/details/106913188)

[JS预编译对象 AO对象与GO对象](https://blog.csdn.net/qq_44624386/article/details/104457880)

 [javascript 作用域链及闭包,AO,VO,执行环境](https://www.cnblogs.com/zyskr/p/10712448.html)

 [VO、AO、执行环境和作用域链](https://www.cnblogs.com/lulin1/p/9712311.html)

 [图解Javascript——变量对象和活动对象](https://www.cnblogs.com/ivehd/p/vo_ao.html)

 [图解Javascript——执行上下文](https://www.cnblogs.com/ivehd/p/executionContext.html)

[[译] 理解 JavaScript 中的执行上下文和执行栈](https://juejin.im/post/6844903682283143181#heading-1)

[Understanding Execution Context and Execution Stack in Javascript](https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0)

[Javascript Execution Context and Hoisting](https://overflowjs.com/posts/Javascript-Execution-Context-and-Hoisting.html)

 [What is the Execution Context & Stack in JavaScript?](http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/#first-article)

[JS中的执行上下文(Execution Context)和栈(stack)](https://www.jianshu.com/p/e4051933e88e)