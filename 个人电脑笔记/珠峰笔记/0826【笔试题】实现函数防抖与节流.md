### 函数防抖

> 对于频繁触发某个操作，我们只识别一次(只触发执行一次函数)

```js
 /*@params
 *      func[function]:最后要触发执行的函数
 *      wait[number]:“频繁”设定的界限
 *      immediate[boolean]:默认多次操作，我们识别的是最后一次，但是immediate=true，让其识别第一次
 *   @return
 *      可以被调用执行的函数*/
// 主体思路：在当前点击完成后，我们等wait这么长的时间，看是否还会触发第二次，如果没有触发第二次，属于非频繁操作，我们直接执行想要执行的函数func；
//如果触发了第二次，则以前的不算了，从当前这次再开始等待...
function debounce(func, wait = 300, immediate = false) {
    let timer = null; //首次执行设置timer为空
    return function anonymous(...params) { //...params是handle(ev)中的ev事件对象，也要传进去
        //这里要timer为null才返回true,!timer就为ture
        let now = immediate && !timer; //因为timer如果是null,则肯定是第一次/首次执行，如果timer不为null，则是下面的定时器设置了timer，还在等待中

        // 每次点击都把之前设置的定时器清除
        clearTimeout(timer);

        // 重新设置一个新的定时器监听wait时间内是否触发第二次
        timer = setTimeout(() => {
            // 手动让其回归到初始状态
            timer = null;
            // wait这么久的等待中，没有触发第二次
            // func.call(this),因为func()执行的this是anonymous，不是我们想要的handle(),所以把this改为传入的函数
            !immediate ? func.call(this, ...params) : null; //immediate不为真时才执行，也就是默认immediate = false，默认识别最后一次
        }, wait);

        // 如果是立即执行/识别第一次=> now=true
        now ? func.call(this, ...params) : null;
    };
}

```

**无注释版**

```js
function debounce(func, wait = 300, immediate = false) {
    let timer = null; 
    return function anonymous(...params) {
        let now = immediate && !timer; 
        clearTimeout(timer);
        timer = setTimeout(() => {
            timer = null;
            !immediate ? func.call(this, ...params) : null; 
        }, wait);
        now ? func.call(this, ...params) : null;
    };
}
```

### 函数节流

> 在一段频繁操作中，可以触发多次，但是触发的频率由自己指定

```js
/*
 * 函数节流：在一段频繁操作中，可以触发多次，但是触发的频率由自己指定
 *   @params
 *      func[function]:最后要触发执行的函数
 *      wait[number]:触发的频率
 *   @return
 *      可以被调用执行的函数
 */
function throttle(func, wait = 300) {
    let timer = null,
        previous = 0; // 记录上一次操作的时间
    return function anonymous(...params) {
        let now = new Date(),
            remaining = wait - (now - previous); //记录还差多久达到我们一次触发的频率
        if (remaining <= 0) {
            // 两次操作的间隔时间已经超过wait了
            window.clearTimeout(timer); //清除定时器
            timer = null; //初始化定时器
            previous = now; //记录当前点击的时间，把下一次点击的时间now 减去 这个previous时间，如果大于wait的时间，则是超过间隔时间，可以直接执行
            func.call(this, ...params); //间隔时间超过wait，可以直接执行

        } else if (!timer) { //如果timer是null

            // 两次操作的间隔时间还不符合触发的频率
            timer = setTimeout(() => {
                timer = null; //初始化定时器
                previous = new Date(); //记录当前时间
                func.call(this, ...params);
            }, remaining); //remaining是还差多长时间到达wait的时间间隔的时间差
        }
    };
}
```

**去注释**

```js
function throttle(func, wait = 300) {
    let timer = null,
        previous = 0; // 记录上一次操作的时间
    return function anonymous(...params) {
        let now = new Date(),
            remaining = wait - (now - previous); //记录还差多久达到我们一次触发的频率
        if (remaining <= 0) {
            window.clearTimeout(timer); 
            timer = null; 
            previous = now; 
            func.call(this, ...params); //间隔时间超过wait，可以直接执行
        } else if (!timer) { 
            timer = setTimeout(() => {
                timer = null; 
                previous = new Date(); 
                func.call(this, ...params);
            }, remaining); 
        }
    };
}
```



