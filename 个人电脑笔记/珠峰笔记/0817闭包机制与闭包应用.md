### 闭包和函数作用域练习理解

1、

```js
let x = 5;

function fn(x) {
    return function (y) {
        console.log(y + (++x));
    }
}
let f = fn(6);
f(7);
fn(8)(9);
f(10);
console.log(x);
//解题步骤
EC(G)全局执行上下文：
	VO：x:5
  		fn:0x00001
			f:0x00002
	注意：函数每次执行都会创建一个新的私有上下文
  1.let f = fn(6);-->运行fn(6)，把函数运行完返回的结果赋值给f,这里return一个函数，要开辟一个堆内存，存入代码内容，把这个内存地址给到全局的f，由于是在fn(x)里执行的，所以返回函数f的作用域链是：<EC(f,EC(fn1)>，这里是重点。
  此时f=function(y){
    console.log(y+(++6))   这里的x值是fn(x)私有的，运行完++x后，x的值会永久加1，此时x=7
  }
 2. f(7)-->作用域链：<EC(f2,EC(fn1)),运行的内容是上面fn(6)返回函数的堆内存地址的内容.把参数7传进去运行，，又会创建一个新的函数私有执行上下文
运行代码：function(7){
    console.log(7+(++x)) 这里的x是fn1的变量，值为6，++6=7
  }
所以f(7)输出14

3. fn(8)(9)==>fn(8)等于函数返回的结果:function(y){
  console.log(y+(++8))
}
4. fn(8)(9)==>function(9){
  console.log(9+(++8))
}
输出9+9=18
  
5. f(10)==>调用全局变量的f函数，function(10){
    console.log(10+(++x))   这里的x值在上次调用时已经加1，x=7，此时再次运行++x,x=8
  }
输出10+8=18

6. console.log(x)==>全局变量x没有被使用过，还是输出5


```

2、

```js
let a=0,
    b=0;
function A(a){
    A=function(b){
        alert(a+b++);
    };
    alert(a++);
}
A(1);
A(2);
//步骤
EC(G)全局上下文：
变量对象：a=0,b=0,A=0x00001(堆内存地址)
A(1)==>调用函数，会创建一个新的函数私有上下文，接着在里面给A赋值，是一个函数，会开辟一个新的堆内存存储函数(any),把内存地址赋值给A，由于A不在A(a)的函数上下文，是属于全局变量，所以会把全局变量A的内存地址覆盖，重新指向。
A(1)运行时，A还是全局变量的A，所以直接弹出alert(1),此时全局变量a变成1
A(2)运行时，此时的A已经是function(b){alert(a+b++)},所以直接弹出alert(2+2=4)
```

### 闭包应用

需求：点击4个button弹出自己的id

```
html:
<button index="0">按钮1</button>
<button index="1">按钮2</button>
<button index="2">按钮3</button>
<button index="3">按钮4</button>
<button index="4">按钮5</button>
js:
var buttonList = document.querySelectorAll('button');
```

错误示例：

```js
for (var i = 0; i < buttonList.length; i++) {
    buttonList[i].onclick = function () {
        console.log(i, `我是第${i+1}个按钮~`);
    };
}
```

上面的代码实现不了的，为啥？

+ 循环中的i是全局的，每一轮循环给对应元素的click绑定方法（创建函数 [存储代码字符串]，此时函数没有执行）

+ 循环结束的时候，全局的i=5

+ 点击某个按钮，执行之前绑定的函数：此时形成一个全新的私有上下文，它的上级上下文是全局上下文，函数代码执行的过程中，遇到变量i，但是i不是自己的私有变量，找到的是全局的i，全局的i是5

**解决问题的思路**：当点击事件触发，执行对应的函数，用到的i不要再向全局查找了；相当于形成一个自己的上下文，而自己的上下文中，存储了你需要的i，存储的值是指定的索引即可 =>闭包的保存机制

弊端：循环多少次，就产生多少个闭包，非常消耗内存



#### 方法一：

```js
for (var i = 0; i < buttonList.length; i++) {
    // 每一轮循环都会把自执行函数执行，形成一个全新的私有上下文（一共形成了5个）
    // 把当前这一轮全局i的值作为实参，传递给当前形成的私有上下文中的形参n[私有变量]
    // 第一个私有上下文中的n=0，第二个私有上下文中的n=1 ....
    // 每一个形成的上下文中，创建的函数都被外部的元素对象的onclick占用了，所以形成了5个闭包
    // 当点击按钮执行函数的时候，遇到一个变量n，不是自己私有的，则找上级上下文（闭包）中的n，而n存储的值就是它的索引
    (function (n) {
        buttonList[n].onclick = function () {
            console.log(`我是第${n+1}个按钮~`);
        };
    })(i);
}
```

#### 自执行函数

(function() {...})(i)---> function() {..} 这是创建一个函数

function() {..}()--->加括号表示把函数执行

(function() {...})(i)---->为了解决语法错误，所以给函数包了个括号，i表示传入的参数。

#### 方法二：

```js
for (var i = 0; i < buttonList.length; i++) {
    buttonList[i].onclick = (function (i) {
        // i是每一轮形成的闭包中的私有变量，五个闭包中存储的值分别是0~4[索引]
        // 每一次都是把小函数返回，赋值给元素的点击事件，当点击元素的时候，执行的是返回的小函数
        return function () {
            console.log(`我是第${i+1}个按钮~`);
        };
    })(i);
}
```

#### 方法三：

```js
 // 还是基于“闭包的机制”，但是不是自己去执行函数构建，而是利用ES6中let产生的私有上下文实现
for (let i = 0; i < buttonList.length; i++) {
    // 第一轮循环 私有块1
    //   + 私有变量 i = 0
    //   + 当前私有上下文中的创建的一个函数被全局的元素对象的onclick占用了(闭包)
    // ....
    buttonList[i].onclick = function () {
        console.log(`我是第${i+1}个按钮~`);
    };
} 
```

以上的三种闭包的方案

#### 方案二  自定义属性

```js
// 方案二：自定义属性（事先把一些信息存储到元素的身上，后期在一些其他的操作中，想要获取这些信息，直接基于元素的属性访问就可以拿到这些值） =>操作DOM的时代下，这种方案非常常用
for (var i = 0; i < buttonList.length; i++) {
    // 把当前按钮的索引存储在它的自定义属性上（每个按钮都是一个元素对象）
    buttonList[i].myIndex = i;
    buttonList[i].onclick = function () {
        // 给当前元素的某个事件绑定方法，当事件触发，方法执行的时候，方法中的this是当前点击的按钮
        console.log(`我是第${this.myIndex+1}个按钮~`);
    };
}
```

#### 方案三 事件代理

```js
// 方案三：利用事件代理的机制（性能提高>=40%）
document.body.onclick = function (ev) {
    let target = ev.target;
    // 点击的是按钮
    if (target.tagName === "BUTTON") {
        let index = target.getAttribute('index');
        console.log(`我是第${+index+1}个按钮~`);
    }
};
```

