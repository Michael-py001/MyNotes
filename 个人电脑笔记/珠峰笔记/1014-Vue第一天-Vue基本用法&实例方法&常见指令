[TOC]



# Vue第一天-Vue基本用法&实例方法&常见指令

### 引入Vue

首先初始化文件夹，再安装vue

```
npm init -y //初始化文件夹

npm install vue
```

使用script标签引入vue.js

```js
<script src="./node_modules/vue/dist/vue.js"></script>
```

### 基本使用

html:

```Html
<div id="app">
        {{msg}}
        <span v-bind:title="msg_2">
            鼠标悬停几秒钟查看此处动态绑定的提示信息！
        </span>
    </div>
```

js:

```js
  //渲染过程：按顺序查找：render -> template -> el
        let app = new Vue({  //app表示Vue的一个实例
            el: "#app",//挂载到id名为app的DOM元素上
            // data:响应式的数据，一般数据是单向数据绑定，表单元素是双向数据绑定
            data: {
                msg: "Hello Vue",
                msg_2: "页面加载于" + new Date().toLocaleString()
            }
        })
```

- `let app = new Vue()`创建Vue的一个实例
- 渲染过程：按顺序查找：render -> template -> el
- `el`:挂载到id名为app的DOM元素上
- `data`:里面的数据会放入vue的响应式系统中，数据更新，视图就更新；双向数据绑定：视图更新，数据也更新。一般的数据是单向数据绑定，表单元素是双向数据绑定。

- `data`里的每一个成员，都会被挂载到app这个实例上

  ![image-20201016164503599](https://i.loli.net/2020/10/16/WtICLGburvTHyJ1.png)

### 小胡子语法(Mustache 语法)

- 双大括号`{{}}`会将数据解释成纯文本，如果是HTML代码也一样输出纯文本。为了输出真正的 HTML，你需要使用 [`v-html` 指令](https://cn.vuejs.org/v2/api/#v-html)

- Mustache 语法不能作用在 HTML attribute 上，遇到这种情况应该使用 [`v-bind` 指令](https://cn.vuejs.org/v2/api/#v-bind)

  ```html
  <div v-bind:id="dynamicId"></div>
  ```

#### 使用JavaScript表达式

> 小胡子语法，`{{}}`里只支持JS表达式，可以有以下方式：
>
> 1.变量 (变量可以数学运算)
>
> 3.三元运算符
>
> 4.放函数的返回值，不能放一个函数 (可以是自执行函数)
>
> 5.不可以定义变量，赋值，定义函数

```js
{{ number + 1 }}

{{ ok ? 'YES' : 'NO' }}

{{ message.split('').reverse().join('') }}

{{ (function fn(){return 10})() }}

{{arr.map(n=>n*2)}}
```

## 响应式原理

### 如何追踪变化

> Vue会遍历`data`选项上的所有property，并使用`Object.defineProperty`把这些 property 全部转为 [getter/setter](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects#定义_getters_与_setters)，在 property 被访问和修改时通知变更，每个组件实例都对应一个 **watcher** 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。

![data](https://cn.vuejs.org/images/data.png)

### 检测变化的注意事项

> 由于 JavaScript 的限制，Vue **不能检测**数组和对象的变化。

#### 对于对象

Vue 无法检测 property 的添加或移除。由于 Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 `data` 对象上存在才能让 Vue 将它转换为响应式的。例如：

```js
var vm = new Vue({
  data:{
    a:1
  }
})

// `vm.a` 是响应式的

vm.b = 2
// `vm.b` 是非响应式的
```

#### `Vue.set()/vm.$set()`：向data添加新属性

​		对于已经创建的实例，Vue 不允许动态添加根级别的响应式 property。但是，可以使用 `Vue.set(object, propertyName, value)` 方法向嵌套对象添加响应式 property。例如，对于：

```js
Vue.set(vm.someObject, 'b', 2)
```

您还可以使用 `vm.$set` 实例方法，这也是全局 `Vue.set` 方法的别名：

```js
this.$set(this.someObject,'b',2)
```

有时你可能需要为已有对象赋值多个新 property，比如使用 `Object.assign()` 或 `_.extend()`。但是，这样添加到对象上的新 property 不会触发更新。在这种情况下，你应该用原对象与要混合进去的对象的 property 一起创建一个新的对象。

```js
// 代替 `Object.assign(this.someObject, { a: 1, b: 2 })`
this.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })
```

#### 对于数组

#### 数组更新检测

##### 变更方法

Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：

- `push()`
- `pop()`
- `shift()`
- `unshift()`
- `splice()`
- `sort()`
- `reverse()`

Vue 不能检测以下数组的变动(缺陷)：

1. 不可以直接通过索引更改数据，例如：`vm.items[indexOfItem] = newValue`
2. 修改数组的长度，例如：`vm.items.length = newLength`

举个例子：

```js
var vm = new Vue({
  data: {
    items: ['a', 'b', 'c']
  }
})
vm.items[1] = 'x' // 不是响应性的
vm.items.length = 2 // 不是响应性的
```

为了解决第一类问题，以下两种方式都可以实现和 `vm.items[indexOfItem] = newValue` 相同的效果，同时也将在响应式系统内触发状态更新：

- 使用`Vue.set()`

  ```js
  // Vue.set
  Vue.set(vm.items, indexOfItem, newValue)
  ```

- 使用`arr.splice()`
  在arr数组的索引1删除1个，插入99这个值，相当于把索引1的值改为99

  ![image-20201016174354250](https://i.loli.net/2020/10/16/ZLS6crzMh7DIB92.png)

  ```js
  // Array.prototype.splice
  vm.items.splice(indexOfItem, 1, newValue)
  ```

你也可以使用 [`vm.$set`](https://cn.vuejs.org/v2/api/#vm-set) 实例方法，该方法是全局方法 `Vue.set` 的一个别名：

```js
vm.$set(vm.items, indexOfItem, newValue)
```

为了解决第二类问题，你可以使用 `splice`：

```js
vm.items.splice(newLength)
```

#### `Array.prototype.splice()`

> **`splice()`** 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。

##### 语法：

`array.splice(start[, deleteCount[, item1[, item2[, ...]]]])`

##### 参数：

`start`

指定修改的开始位置（从0计数）。如果超出了数组的长度，则从数组末尾开始添加内容；如果是负值，则表示从数组末位开始的第几位;如果负数的绝对值大于数组的长度，则表示开始位置为第0位。

`deleteCount` 可选

整数，表示要移除的数组元素的个数。

- 如果 `deleteCount` 大于 `start` 之后的元素的总数，则从 `start` 后面的元素都将被删除（含第 `start` 位）。

- 如果 `deleteCount` 被省略了(为空)，或者它的值大于等于`array.length - start`(也就是说，如果它大于或者等于`start`之后的所有元素的数量)，那么`start`之后数组的所有元素都会被删除。

- 如果 `deleteCount` 是 0 或者负数，则不移除元素。这种情况下，至少应添加一个新元素。

`item1, item2, ...` 可选

要添加进数组的元素,从`start` 位置开始。如果不指定，则 `splice()` 将只删除数组元素。

##### 返回值

由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。

## vue实例上的属性和方法

### 1.vm.$set/vm.$delete 更改或删除对象或数组

#### vm.$set( target, propertyName/index, value )

- **参数**：

  - `{Object | Array} target`
  - `{string | number} propertyName/index`
  - `{any} value`

- **返回值**：设置的值。

- **用法**：

  向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新 property，因为 Vue 无法探测普通的新增 property (比如 `this.myObject.newProperty = 'hi'`)
  
  > 解决数组或对象新增数据时响应式的问题
  
  ##### 数组：
  
  由于 JavaScript 的限制，Vue 不能检测以下变动的数组：
  
  - 当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue
  
    解决：
  
    ```js
    this.$set(Array, index, newValue)
    ```
  
  - 当你修改数组的长度时，例如：vm.items.length = newLength
  
    解决:
  
    ```js
    vm.items.splice(newLength)
    ```
  
  ##### 对象：
  
  ```js
  this.$set(Object, key, value)
  ```
  
  ```dart
  有时你想向已有对象上添加一些属性，例如使用 Object.assign() 或 _.extend() 方法来添加属性。
  但是，添加到对象上的新属性不会触发更新。
  在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性：
  
  this.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })
  ```

#### Vue.delete( target, propertyName/index )

- **参数**：

  - `{Object | Array} target`
  - `{string | number} propertyName/index`
  - 仅在 2.2.0+ 版本中支持 Array + index 用法。

- **用法**：

  删除对象的 property。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到 property 被删除的限制，但是你应该很少会使用它。

  注意：目标对象不能是一个 Vue 实例或 Vue 实例的根数据对象。



### 2. vm.$mount( elementOrSelector] ) 设置vue实例挂载的DOM元素

- **参数**：

  - `{Element | string} [elementOrSelector]`
  - `{boolean} [hydrating]`

- **返回值**：`vm` - 实例自身

- **用法**：

  如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。可以使用 `vm.$mount()` 手动地挂载一个未挂载的实例。

  如果没有提供 `elementOrSelector` 参数，模板将被渲染为文档之外的的元素，并且你必须使用原生 DOM API 把它插入文档中。

  这个方法返回实例自身，因而可以链式调用其它实例方法。

- **示例**：

  ```js
  var MyComponent = Vue.extend({
    template: '<div>Hello!</div>'
  })
  
  // 创建并挂载到 #app (会替换 #app)
  new MyComponent().$mount('#app')
  
  // 同上
  new MyComponent({ el: '#app' })
  
  // 或者，在文档之外渲染并且随后挂载
  var component = new MyComponent().$mount()
  document.getElementById('app').appendChild(component.$el)
  ```

  ```js
    let vm = new Vue({  //app表示Vue的一个实例
              // el: "#app",//挂载到id名为app的DOM元素上
              data: {
                  msg: "Hello Vue",
              },
  
          })
  //在外面添加挂载的app
  vm.$mount("#app")
  ```

### 3. vm.$el

- **类型**：`Element`

- **只读**

- **详细**：

  获取Vue 实例挂载的根 DOM 元素。

### 4. vm.$options

- **类型**：`Object`

- **只读**

- **详细**：

- 用于获取Vue({ })里面所有的选项

  用于当前 Vue 实例的初始化选项。需要在选项中包含自定义 property 时会有用处：

  ```js
  new Vue({
    customOption: 'foo',
    created: function () {
      console.log(this.$options.customOption) // => 'foo'
    }
  })
  ```

### 5. vm.$data

- **类型**：`Object`

- 简略：获取设置的响应式数据

- **详细**：

  Vue 实例观察的数据对象。Vue 实例代理了对其 data 对象 property 的访问。

### 6. vm.$watch( expOrFn, callback, [options\] )](https://cn.vuejs.org/v2/api/#vm-watch)

- **参数**：

  - `{string | Function} expOrFn`
  - `{Function | Object} callback`
  - `{Object} [options]`
    - `{boolean} deep`
    - `{boolean} immediate`

- **返回值**：`{Function} unwatch`

- **用法**：

  观察 Vue 实例上的一个表达式或者一个函数计算结果的变化。回调函数得到的参数为新值和旧值。表达式只接受简单的键路径。对于更复杂的表达式，用一个函数取代。

  注意：在变更 (不是替换) 对象或数组时，旧值将与新值相同，因为它们的引用指向同一个对象/数组。Vue 不会保留变更之前值的副本。

- `vm.$watch` 返回一个取消观察函数，用来停止触发回调：

  ```
  var unwatch = vm.$watch('a', cb)
  // 之后取消观察
  unwatch()
  ```

- **选项：deep**

  为了发现对象内部值(对象内的对象值)的变化，可以在选项参数中指定 `deep: true`。注意监听数组的变更不需要这么做。

  ```js
  vm.$watch('someObject', callback, {
    deep: true
  })
  vm.someObject.nestedValue = 123
  // callback is fired
  ```

- 选项：immediate

  在选项参数中指定 `immediate: true` 将立即以表达式的当前值触发回调：

  ```js
    vm.$watch('a', callback, {
      immediate: true
    })
    // 立即以 `a` 的当前值触发回调
  ```

### 7. vm.$nextTick( [callback\] )](https://cn.vuejs.org/v2/api/#vm-nextTick)

- **参数**：

  - `{Function} [callback]`

- **用法**：

  将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 `Vue.nextTick` 一样，不同的是回调的 `this` 自动绑定到调用它的实例上。

  > 2.1.0 起新增：如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不是原生支持 Promise (IE：你们都看我干嘛)，你得自行 polyfill。

- **示例**：

    更改data中的msg，然后在下一行输出

  ```js
  vm.msg = "Hi Vue";
  console.log(vm.$el.innerHTML)
  ```

  ![image-20201016185551336](https://i.loli.net/2020/10/16/IDjWtXPOY24agKZ.png)

  会发现输出的结果并不是最新渲染到页面的数据，因为DOM的渲染是需要时间的，不可能同步更新。

  使用`vm.$nextTick`可以让回调函数在下次DOM渲染完成后才执行：

  ```js
   vm.msg = "Hi Vue";
  vm.$nextTick(function(){
    console.log(vm.$el.innerHTML)   
  })
  ```

  ![image-20201016190016660](https://i.loli.net/2020/10/16/amqEAKeD8WsbyUQ.png)

  官方例子：

  ```js
  new Vue({
    // ...
    methods: {
      // ...
      example: function () {
        // 修改数据
        this.message = 'changed'
        // DOM 还没有更新
        this.$nextTick(function () {
          // DOM 现在更新了
          // `this` 绑定到当前实例
          this.doSomethingElse()
        })
      }
    }
  })
  ```

## Vue常见指令

### v-tex

> 渲染成文本，且首次渲染不会有小胡子`{{}}`出现

```html
//这两种写法都是把msg渲染成纯文本
<div v-text="msg"></div>
<div>{{msg}}</div>
```

### v-html

> 更新元素的 `innerHTML`。

```html
<div v-html="html"></div>

//js
data:{
	html: '<p style="color: red;">my html</p>',
}
```

### v-once

> 只渲染元素和组件**一次**。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。

```html
<div v-text="msg" v-once></div>
//随后的数据更新都不会再次渲染了
```

### v-if/v-else/v-else-if

#### v-if

> 根据表达式的值的 `true/false` 来有条件地渲染元素，当条件变化时该指令触发过渡效果。
>
> v-if是会重新创建和销毁DOM元素，不适合频繁的操作DOM的显示和隐藏，如果是频繁操作的，则使用v-show。

```html
<h1 v-if="awesome">Vue is awesome!</h1>
```

#### 在`<template>`元素上使用 v-if 条件渲染分组

​		因为 `v-if` 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个 `<template>` 元素当做不可见的包裹元素，并在上面使用 `v-if`。最终的渲染结果将不包含 `<template>` 元素。

```html
<template v-if="ok">
  <h1>Title</h1>
  <p>Paragraph 1</p>
  <p>Paragraph 2</p>
</template>
```

![image-20201016211220942](https://i.loli.net/2020/10/16/opcjCZQbaRNgnS6.png)

#### v-else

```html
<h1 v-if="awesome">Vue is awesome!</h1>
<h1 v-else>Oh no 😢</h1>
```

```html
<div v-if="Math.random() > 0.5">
  Now you see me
</div>
<div v-else>
  Now you don't
</div>
```

#### v-else-if

`v-else-if`，顾名思义，充当 `v-if` 的“else-if 块”，可以连续使用：

```
<div v-if="type === 'A'">
  A
</div>
<div v-else-if="type === 'B'">
  B
</div>
<div v-else-if="type === 'C'">
  C
</div>
<div v-else>
  Not A/B/C
</div>
```

类似于 `v-else`，`v-else-if` 也必须紧跟在带 `v-if` 或者 `v-else-if` 的元素之后。

#### 用 key 管理可复用的元素

​		Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换：

```html
<template v-if="loginType === 'username'">
  <label>Username</label>
  <input placeholder="Enter your username">
</template>
<template v-else>
  <label>Email</label>
  <input placeholder="Enter your email address">
</template>
<button v-on:click="change">Toggle login type</button>
```

js:

```js
methods: {
  change: function () {
  console.log(this.loginType);
  this.loginType == "username" ? this.loginType = "email" : this.loginType = "username";
}
            }
```

这样也不总是符合实际需求，所以 Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 `key` attribute 即可：

```html
 <template v-if="loginType === 'username'">
            <label>Username</label>
            <input placeholder="Enter your username" key="user-input">
        </template>
        <template v-else>
            <label>Email</label>
            <input placeholder="Enter your email address" key="email-input">
        </template>
<button v-on:click="change">Toggle login type</button>
```

现在，每次切换时，输入框都将被重新渲染。

![image-20201016214217257](https://i.loli.net/2020/10/16/xpRIhlNAFY7qa29.png)

注意，`<label>` 元素仍然会被高效地复用，因为它们没有添加 `key` attribute。

### v-show

> 渲染样式的显示和隐藏，操作样式。

​		另一个用于根据条件展示元素的选项是 `v-show` 指令。用法大致一样：

```
<h1 v-show="ok">Hello!</h1>
```

​		不同的是带有 `v-show` 的元素始终会被渲染并保留在 DOM 中。`v-show` 只是简单地切换元素的 CSS property `display`。

![image-20201016224446896](https://i.loli.net/2020/10/16/xeNXZHFokgpCP2q.png)

### v-for

> https://cn.vuejs.org/v2/guide/list.html

- **预期**：`Array | Object | number | string | Iterable (2.6 新增)`

- **用法**：

  基于源数据多次渲染元素或模板块。`v-for` 指令需要使用 `item in items` 形式的特殊语法，其中 `items` 是源数据数组，而 `item` 则是被迭代的数组元素的**别名**。

  ```html
  <div v-for="item in items">
    {{ item.text }}
  </div>
  ```

  另外也可以为数组索引指定别名 (或者用于对象的键)：

  ```html
  <div v-for="(item, index) in items"></div>
  <div v-for="(val, key) in object"></div>
  <div v-for="(val, name, index) in object"></div>
  ```

  ```html
   <div v-for="(val,name,index) in obj">
     <div>{{val}} {{name}} {{index}}</div>
  </div>
  //js
  obj: {
    name: "li",
    age: 18,
    sex: "man"
  }
  ```

  ![image-20201016225630001](https://i.loli.net/2020/10/16/LDCrP3bRmnSBKtk.png)

  `v-for` 的默认行为会尝试原地修改元素而不是移动它们。要强制其重新排序元素，你需要用特殊 attribute `key` 来提供一个排序提示：

  ```html
  <div v-for="item in items" :key="item.id">
    {{ item.text }}
  </div>
  ```

  从 2.6 起，`v-for` 也可以在实现了[可迭代协议](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#可迭代协议)的值上使用，包括原生的 `Map` 和 `Set`。不过应该注意的是 Vue 2.x 目前并不支持可响应的 `Map` 和 `Set` 值，所以无法自动探测变更。

  当和 `v-if` 一起使用时，`v-for` 的优先级比 `v-if` 更高。详见[列表渲染教程](https://cn.vuejs.org/v2/guide/list.html#v-for-with-v-if)

  #### v-for中的key

  ​		当 Vue 正在更新使用 `v-for` 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。

  这个默认的模式是高效的，但是**只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出**。

  为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 `key` attribute：

  ```html
  <div v-for="item in items" v-bind:key="item.id">
    <!-- 内容 -->
  </div>
  ```

  ```html
  <div v-for="(item,index) in obj" :key="${index}_a"></div>
  ```

  

### v-bind

> 动态属性绑定

- **缩写**：`:`

- **预期**：`any (with argument) | Object (without argument)`

- **参数**：`attrOrProp (optional)`

- **修饰符**：

  - `.prop` - 作为一个 DOM property 绑定而不是作为 attribute 绑定。([差别在哪里？](https://stackoverflow.com/questions/6003819/properties-and-attributes-in-html#answer-6004028))

    例如：

    ```html
    <div v-bind:text-content="msg"></div>
    ```

    在页面上显示为为空内容，只给div设置了属性：
    ![image-20201016235433251](https://i.loli.net/2020/10/16/L7ZqOIu2yiHxvln.png)

    加了.prop后，变成DOM property-->text显示：

    ```html
    <div v-bind:text-content.prop="msg"></div>
    ```

    ![image-20201016235628068](https://i.loli.net/2020/10/16/j19tYKBQl2M8LAF.png)

  - `.camel` - (2.1.0+) 将 kebab-case attribute 名转换为 camelCase。(从 2.1.0 开始支持)

  - `.sync` (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 `v-on` 侦听器。

- **用法**：

  动态地绑定一个或多个 attribute，或一个组件 prop 到表达式。

  在绑定 `class` 或 `style` attribute 时，支持其它类型的值，如数组或对象。

  在绑定 prop 时，prop 必须在子组件中声明。可以用修饰符指定不同的绑定类型。

  没有参数时，可以绑定到一个包含键值对的对象。注意此时 `class` 和 `style` 绑定不支持数组和对象。

- **示例**：

  ```js
  <!-- 绑定一个 attribute -->
  <img v-bind:src="imageSrc">
  
  <!-- 动态 attribute 名 (2.6.0+) -->
  <button v-bind:[key]="value"></button>
  
  <!-- 缩写 -->
  <img :src="imageSrc">
  
  <!-- 动态 attribute 名缩写 (2.6.0+) -->
  <button :[key]="value"></button>
  
  <!-- 内联字符串拼接 -->
  <img :src="'/path/to/images/' + fileName">
  
  <!-- class 绑定 -->
  <div :class="{ red: isRed }"></div>
  <div :class="[classA, classB]"></div>
  <div :class="[classA, { classB: isB, classC: isC }]">
  
  <!-- style 绑定 -->
  <div :style="{ fontSize: size + 'px' }"></div>
  <div :style="[styleObjectA, styleObjectB]"></div>
  
  <!-- 绑定一个全是 attribute 的对象 -->
  <div v-bind="{ id: someProp, 'other-attr': otherProp }"></div>
  
  <!-- 通过 prop 修饰符绑定 DOM attribute -->
  <div v-bind:text-content.prop="text"></div>
  ```

### Class 与 Style 绑定

> 操作元素的 class 列表和内联样式是数据绑定的一个常见需求。因为它们都是 attribute，所以我们可以用 `v-bind` 处理它们：只需要通过表达式计算出字符串结果即可。不过，字符串拼接麻烦且易错。因此，在将 `v-bind` 用于 `class` 和 `style` 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。

#### 绑定 HTML Class

##### 对象语法

​		我们可以传给 `v-bind:class` 一个对象，以动态地切换 class：

```html
<div v-bind:class="{ active: isActive }">hi siri</div>
```

设置多个class，与普通class共存

```html
<div
  class="static"
  v-bind:class="{ active: isActive, 'text-danger': hasError }"
></div>
```

data：

```js
data: {
  isActive: true,
  hasError: false
}
```

css:

```css
.active {
  color: yellowgreen;
}
```

结果渲染为：

```html
<div class="static active">hi siri</div>
```

![image-20201017002603048](https://i.loli.net/2020/10/17/rIDWMqc5K1oy3GV.png)

绑定的数据对象不必内联定义在模板里：

```js
<div v-bind:class="classObject"></div>
data: {
  classObject: {
    active: true,
    'text-danger': false
  }
}
```

渲染的结果和上面一样。我们也可以在这里绑定一个返回对象的[计算属性](https://cn.vuejs.org/v2/guide/computed.html)（对于任何复杂逻辑，你都应当使用**计算属性**）。这是一个常用且强大的模式：

```html
<div v-bind:class="classObject"></div>
data: {
  isActive: true,
  error: null
},
computed: {
  classObject: function () {
    return {
      active: this.isActive && !this.error,
      'text-danger': this.error && this.error.type === 'fatal'
    }
  }
}
```

##### 数组语法

我们可以把一个数组传给 `v-bind:class`，以应用一个 class 列表：

```
<div v-bind:class="[activeClass, errorClass]"></div>
data: {
  activeClass: 'active',
  errorClass: 'text-danger'
}
```

渲染为：

```
<div class="active text-danger"></div>
```

如果你也想根据条件切换列表中的 class，可以用三元表达式：

```html
<div v-bind:class="[isActive ? activeClass : '', errorClass]"></div>
```

这样写将始终添加 `errorClass`，但是只有在 `isActive` 是 truthy[[1\]](https://cn.vuejs.org/v2/guide/class-and-style.html#footnote-1) 时才添加 `activeClass`。

不过，当有多个条件 class 时这样写有些繁琐。所以在数组语法中也可以使用对象语法：

```html
<div v-bind:class="[{ active: isActive }, errorClass]"></div>
```

#### 绑定内联样式

##### 对象语法

`v-bind:style` 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名：

```js
<div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
data: {
  activeColor: 'red',
  fontSize: 30
}
```

直接绑定到一个样式对象通常更好，这会让模板更清晰：

```js
<div v-bind:style="styleObject"></div>
data: {
  styleObject: {
    color: 'red',
    fontSize: '13px'
  }
}
```

例子：

```html
<div v-bind:style="styleObj">my style</div>
```

```js
styleObj: {
  color: "red",
    fontSize: "20px"
}
```

效果：

![image-20201017003628563](https://i.loli.net/2020/10/17/6Km7vnEXWFUq1Sp.png)

![image-20201017003643331](https://i.loli.net/2020/10/17/uosUz2a5pVcSIQj.png)

同样的，对象语法常常结合返回对象的计算属性使用。

##### 数组语法

`v-bind:style` 的数组语法可以将多个样式对象应用到同一个元素上：

```html
<div v-bind:style="[baseStyles, overridingStyles]"></div>
```

##### 自动添加前缀

当 `v-bind:style` 使用需要添加[浏览器引擎前缀](https://developer.mozilla.org/zh-CN/docs/Glossary/Vendor_Prefix)的 CSS property 时，如 `transform`，Vue.js 会自动侦测并添加相应的前缀。

### v-on

- **缩写**：`@`

- **预期**：`Function | Inline Statement | Object`

- **参数**：`event`

- **修饰符**：

  - `.stop` - 阻止冒泡。调用 `event.stopPropagation()`。

    ```html
    <div @click="parent">
                parent
                <div @click="son">
                    son
                    <div @click.stop="grandSon">
                        grandSon
                    </div>
                </div>
            </div>
    //点击grandSon时，只会触发当前的方法，不会冒泡触发往上的方法
    ```

    

  - `.prevent` - 调用 `event.preventDefault()`。

    ```html
     <a href="http://www.baidu.com" @click.prevent="link">点击跳转</a>
    //不会跳转了
    ```

    

  - `.capture` -把默认的冒泡改为捕获-->捕获是从外往里触发事件， 添加事件侦听器时使用 capture 模式。

    ```html
    <div @click="parent">
                parent
                <div @click.capture="son">
                    son
                    <div @click="grandSon">
                        grandSon
                    </div>
                </div>
            </div>
    //点击grandSon时事件的触发顺序变成了son grandSon parent
    ```

    

  - `.self` - 只当事件是从侦听器绑定的元素本身触发时才触发回调。

    ```html
      <div @click="parent">
               parent
               <div @click.self="son">
                   son
                   <div @click="grandSon">
                       grandSon
                   </div>
               </div>
           </div>
    //只有点击son时，才会触发son这个方法
    //点击grandSon时不会触发son这个方法
    ```

    

  - `.{keyCode | keyAlias}` - 只当事件是从特定键触发时才触发回调。

  - `.native` - 监听组件根元素的原生事件。

  - `.once` - 只触发一次回调。

  - `.left` - (2.2.0) 只当点击鼠标左键时触发。

  - `.right` - (2.2.0) 只当点击鼠标右键时触发。

  - `.middle` - (2.2.0) 只当点击鼠标中键时触发。

  - `.passive` - 是否阻止滚动事件，在移动端会有一个滚动事件，默认是阻止的，加上.passive后就不会阻止，滚动事件将立即触发(2.3.0) 以 `{ passive: true }` 模式添加侦听器

    Vue 还对应 [`addEventListener` 中的 `passive` 选项](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters)提供了 `.passive` 修饰符。

    ```html
    <!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 -->
    <!-- 而不会等待 `onScroll` 完成  -->
    <!-- 这其中包含 `event.preventDefault()` 的情况 -->
    <div v-on:scroll.passive="onScroll">...</div>
    ```

    这个 `.passive` 修饰符尤其能够提升移动端的性能。

    不要把 `.passive` 和 `.prevent` 一起使用，因为 `.prevent` 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，`.passive` 会告诉浏览器你*不*想阻止事件的默认行为。

- ```html
  <!-- 阻止单击事件继续传播 -->
  <a v-on:click.stop="doThis"></a>
  
  <!-- 提交事件不再重载页面 -->
  <form v-on:submit.prevent="onSubmit"></form>
  
  <!-- 修饰符可以串联 -->
  <a v-on:click.stop.prevent="doThat"></a>
  
  <!-- 只有修饰符 -->
  <form v-on:submit.prevent></form>
  
  <!-- 添加事件监听器时使用事件捕获模式 -->
  <!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 -->
  <div v-on:click.capture="doThis">...</div>
  
  <!-- 只当在 event.target 是当前元素自身时触发处理函数 -->
  <!-- 即事件不是从内部元素触发的 -->
  <div v-on:click.self="doThat">...</div>
  ```

  使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 `v-on:click.prevent.self` 会阻止**所有的点击**，而 `v-on:click.self.prevent` 只会阻止对元素自身的点击。

- **用法**：

  绑定**事件**监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。

  用在普通元素上时，只能监听[**原生 DOM 事件**](https://developer.mozilla.org/zh-CN/docs/Web/Events)。用在自定义元素组件上时，也可以监听子组件触发的**自定义事件**。

  在监听原生 DOM 事件时，方法以事件为唯一的参数。如果使用内联语句，语句可以访问一个 `$event` property：`v-on:click="handle('ok', $event)"`。

  从 `2.4.0` 开始，`v-on` 同样支持不带参数绑定一个事件/监听器键值对的对象。注意当使用对象语法时，是不支持任何修饰器的。

- **示例**：

  ```html
  <!-- 方法处理器 -->
  <button v-on:click="doThis"></button>
  
  <!-- 动态事件 (2.6.0+) -->
  <button v-on:[event]="doThis"></button>
  
  <!-- 内联语句 -->
  <button v-on:click="doThat('hello', $event)"></button>
  
  <!-- 缩写 -->
  <button @click="doThis"></button>
  
  <!-- 动态事件缩写 (2.6.0+) -->
  <button @[event]="doThis"></button>
  
  <!-- 停止冒泡 -->
  <button @click.stop="doThis"></button>
  
  <!-- 阻止默认行为 -->
  <button @click.prevent="doThis"></button>
  
  <!-- 阻止默认行为，没有表达式 -->
  <form @submit.prevent></form>
  
  <!--  串联修饰符 -->
  <button @click.stop.prevent="doThis"></button>
  
  <!-- 键修饰符，键别名 -->
  <input @keyup.enter="onEnter">
  
  <!-- 键修饰符，键代码 -->
  <input @keyup.13="onEnter">
  
  <!-- 点击回调只会触发一次 -->
  <button v-on:click.once="doThis"></button>
  
  <!-- 对象语法 (2.4.0+) -->
  <button v-on="{ mousedown: doThis, mouseup: doThat }"></button>
  ```

  在子组件上监听自定义事件 (当子组件触发“my-event”时将调用事件处理器)：

  ```html
  <my-component @my-event="handleThis"></my-component>
  
  <!-- 内联语句 -->
  <my-component @my-event="handleThis(123, $event)"></my-component>
  
  <!-- 组件中的原生事件 -->
  <my-component @click.native="onClick"></my-component>
  ```

### v-model

> 你可以用 `v-model` 指令在表单 `<input>`、`<textarea>` 及 `<select>` 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。
>
> https://cn.vuejs.org/v2/guide/forms.html

注意：`v-model` 会忽略所有表单元素的 `value`、`checked`、`selected` attribute 的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 `data` 选项中声明初始值。

`v-model` 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：

- text 和 textarea 元素使用 `value` property 和 `input` 事件；
- checkbox 和 radio 使用 `checked` property 和 `change` 事件；
- select 字段将 `value` 作为 prop 并将 `change` 作为事件。

记住：

```html
<input v-model="searchText">
```

等价于：

```html
<input
  v-bind:value="searchText"
  v-on:input="searchText = $event.target.value"
>
```

#### [文本](https://cn.vuejs.org/v2/guide/forms.html#文本)

```html
<input v-model="message" placeholder="edit me">
<p>Message is: {{ message }}</p>
```

![image-20201017023945547](https://i.loli.net/2020/10/17/4IbnfyQTV2PloGa.png)

#### [多行文本](https://cn.vuejs.org/v2/guide/forms.html#多行文本)

```html
<span>Multiline message is:</span>
<p style="white-space: pre-line;">{{ message }}</p>
<br>
<textarea v-model="message" placeholder="add multiple lines"></textarea>
```

#### [复选框](https://cn.vuejs.org/v2/guide/forms.html#复选框)

单个复选框，绑定到布尔值：默认显示true/false

```html
<input type="checkbox" id="checkbox" v-model="checked">
<label for="checkbox">{{ checked }}</label>
//js
data:{
	checked: ""
}
```

![image-20201017024330897](https://i.loli.net/2020/10/17/bLeShisOKtY27Hd.png)

多个复选框，绑定到同一个数组：

```html
<input type="checkbox" id="jack" value="Jack" v-model="checkedNames">
<label for="jack">Jack</label>
<input type="checkbox" id="john" value="John" v-model="checkedNames">
<label for="john">John</label>
<input type="checkbox" id="mike" value="Mike" v-model="checkedNames">
<label for="mike">Mike</label>
<br>
<span>Checked names: {{ checkedNames }}</span>
new Vue({
  el: '...',
  data: {
    checkedNames: []
  }
})
```

![image-20201017024520438](https://i.loli.net/2020/10/17/MoE4HG8TvkB376u.png)

#### [单选按钮](https://cn.vuejs.org/v2/guide/forms.html#单选按钮)

会把input标签的value值给到v-model的数据

```html
<div id="example-4">
  <input type="radio" id="one" value="One" v-model="picked">
  <label for="one">One</label>
  <br>
  <input type="radio" id="two" value="Two" v-model="picked">
  <label for="two">Two</label>
  <br>
  <span>Picked: {{ picked }}</span>
</div>
```

```js
new Vue({
  el: '#example-4',
  data: {
    picked: ''
  }
})
```

![image-20201017024730724](https://i.loli.net/2020/10/17/vEQhnsYWkqiBNTz.png)

#### [选择框](https://cn.vuejs.org/v2/guide/forms.html#选择框)

单选时：

选中哪个，就会把选中的值给到v-model的"selected"

```html
<div id="example-5">
  <select v-model="selected">
    <option disabled value="">请选择</option>
    <option>A</option>
    <option>B</option>
    <option>C</option>
  </select>
  <span>Selected: {{ selected }}</span>
</div>
new Vue({
  el: '...',
  data: {
    selected: ''
  }
})
```

![image-20201017024914699](https://i.loli.net/2020/10/17/PhEoUV3fN9RFMOu.png)

如果 `v-model` 表达式的初始值未能匹配任何选项，`<select>` 元素将被渲染为“未选中”状态。在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 change 事件。因此，更推荐像上面这样提供一个值为空的禁用选项。

多选时 (绑定到一个数组)：

multiple表示可以多选，会把选中的给到selected这个数组。

```html
<div id="example-6">
  <select v-model="selected" multiple style="width: 50px;">
    <option>A</option>
    <option>B</option>
    <option>C</option>
  </select>
  <br>
  <span>Selected: {{ selected }}</span>
</div>
new Vue({
  el: '#example-6',
  data: {
    selected: []
  }
})
```

![image-20201017025310391](https://i.loli.net/2020/10/17/FyIXu53cTJA4s8M.png)

用 `v-for` 渲染的动态选项：

v-model会把option选中的value给到selected，所以selected显示的是选中的值。

```html
<select v-model="selected">
  <option v-for="option in options" v-bind:value="option.value">
    {{ option.text }}
  </option>
</select>
<span>Selected: {{ selected }}</span>
new Vue({
  el: '...',
  data: {
    selected: 'A',
    options: [
      { text: 'One', value: 'A' },
      { text: 'Two', value: 'B' },
      { text: 'Three', value: 'C' }
    ]
  }
})
```

#### [值绑定](https://cn.vuejs.org/v2/guide/forms.html#值绑定)

对于单选按钮，复选框及选择框的选项，`v-model` 绑定的值通常是静态字符串 (对于复选框也可以是布尔值)：

```html
<!-- 当选中时，`picked` 为字符串 "a" -->
<input type="radio" v-model="picked" value="a">

<!-- `toggle` 为 true 或 false -->
<input type="checkbox" v-model="toggle">

<!-- 当选中第一个选项时，`selected` 为字符串 "abc" -->
<select v-model="selected">
  <option value="abc">ABC</option>
</select>
```

##### [复选框](https://cn.vuejs.org/v2/guide/forms.html#复选框-1)

```html
<input
  type="checkbox"
  v-model="toggle"
  true-value="yes"
  false-value="no"
>
// 当选中时
vm.toggle === 'yes'
// 当没有选中时
vm.toggle === 'no'
```

​		这里的 `true-value` 和 `false-value` attribute 并不会影响输入控件的 `value` attribute，因为浏览器在提交表单时并不会包含未被选中的复选框。如果要确保表单中这两个值中的一个能够被提交，(即“yes”或“no”)，请换用单选按钮。

#####[单选按钮](https://cn.vuejs.org/v2/guide/forms.html#单选按钮-1)

```html
<input type="radio" v-model="pick" v-bind:value="a">
// 当选中时
vm.pick === vm.a
```

##### [选择框的选项](https://cn.vuejs.org/v2/guide/forms.html#选择框的选项)

```html
<select v-model="selected">
    <!-- 内联对象字面量 -->
  <option v-bind:value="{ number: 123 }">123</option>
</select>
// 当选中时
typeof vm.selected // => 'object'
vm.selected.number // => 123
```

#### [修饰符](https://cn.vuejs.org/v2/guide/forms.html#修饰符)

##### [`.lazy`](https://cn.vuejs.org/v2/guide/forms.html#lazy)

在默认情况下，`v-model` 在每次 `input` 事件触发后将输入框的值与数据进行同步 (除了[上述](https://cn.vuejs.org/v2/guide/forms.html#vmodel-ime-tip)输入法组合文字时)。你可以添加 `lazy` 修饰符，从而转为在 `change` 事件_之后_进行同步：

```html
<!-- 在“change”时而非“input”时更新 -->
<input v-model.lazy="msg">
```

`change`事件

​	当用户更改`<input>`、`<select>`和`<textarea>` 元素的值并提交这个更改时，change 事件在这些元素上触发。和 input 事件不一样，change 事件并不是每次元素的 value 改变时都会触发。

- 当元素是 `:checked` 状态时（通过点击或者使用键盘），见于 `<input type="radio">` 和 `<input type="checkbox">`；
- 当用户显式提交改变时（例如：点击了 [``](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/select)中的一个选项，从 `<input type="date">` 标签选择了一个日期，通过 `<input type="file">` 标签上传了一个文件等）；
- 当标签的值被修改并且失去焦点后，但未提交时（例如：对[``](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/textarea) 或者 `<input type="text">`的值进行编辑后）。

##### [`.number`](https://cn.vuejs.org/v2/guide/forms.html#number)

如果想自动将用户的输入值转为数值类型，可以给 `v-model` 添加 `number` 修饰符：

```
<input v-model.number="age" type="number">
```

这通常很有用，因为即使在 `type="number"` 时，HTML 输入元素的值也总会返回字符串。如果这个值无法被 `parseFloat()` 解析，则会返回原始的值。

![image-20201017031618247](https://i.loli.net/2020/10/17/aG1r7Y3RC2i9lMx.png)

##### [`.trim`](https://cn.vuejs.org/v2/guide/forms.html#trim)

如果要自动过滤用户输入的首尾空白字符，可以给 `v-model` 添加 `trim` 修饰符：

```
<input v-model.trim="msg">
```