[TOC]



# Vue第三天

## Vue生命周期

![img](https://i.loli.net/2020/10/20/dRzoKZ2HlxvYO65.jpg)

- `init Events & Lifecycle`:初始化事件和生命周期函数，如`$on`、`$emit`等。

- `beforeCreate`：表示挂载前，实例初始化的一些操作，比如数据的观测以及事件的配置

- `init injections & reactivity`:初始化响应式的一些方法和属性

- `created`:表示实例已经创建完成，data中的响应式数据已经配置完成，可以拿到data中的数据了，一般会在这个阶段发起一些资源请求(`ajax & axios`)，把data中的数据发送出去。

- 渲染顺序优先级：`render` > `template` > `el`

```js
let vm = new Vue({
        el: "#app", //vm.$mount()
        data: {
            msg: 10
        },
        template: "<div>hello</div>"
       }
      )
```

- 如果没有`el`选项，则通过`vm.$mount()`挂载；
- `beforeMount`：挂载前
- `mounted`：挂载后，可以拿到DOM元素了。 
- `beforeUpdate` 数据更新前
- `updated`: 数据更新后，不要在这里更新data中的数据，不然会进入一个死循环。
- `beforeDestroy`:实例销毁前
- `destroyed`: 销毁子组件，清空定时器，解除事件绑定

## 组件

> 使用组件化开发，可以把功能规划成一个个的组件，组件最大的特点就是可复用，功能独立，可以提高开发效率。

### 全局组件

> 全局组件定义好后，可以在任意Vue实例挂载的DOM上使用，不需要在vm实例里声明。在所有子组件中也是如此，也就是说一个全局组件*在各自内部*也都可以相互使用。

 Vue 全局组件示例：

```js
// 定义一个名为 button-counter 的新组件
Vue.component('button-counter', {
  data: function () {
    return {
      count: 0
    }
  },
  template: '<button v-on:click="count++">You clicked me {{ count }} times.</button>'
})
```

#### Vue.component()接收的参数：

##### 第一个参数name: 组件的名字

定义组件名的方式有两种：

- **使用 kebab-case**

```js
Vue.component('my-component-name', { /* ... */ })
```

​         当使用 kebab-case (短横线分隔命名) 定义一个组件时，你也必须在引用这个自定义元素时使用 kebab-case，例如 `<my-component-name>`。
​		

- **使用 PascalCase**

  ```js
  Vue.component('MyComponentName', { /* ... */ })
  ```

​        当使用 PascalCase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。也就是说 `<my-component-name>` 和 `<MyComponentName>` 都是可接受的。

​		如果使用模板字符串，可以在模板中使用`PascalCase`，在html中使用`kebab-case`，都会被识别。
​	html:

```html
<blog-post v-for="post in posts" v-bind:key="post.id" v-bind:post="post"></blog-post>
```

js:

```js
 Vue.component('blogPost', {
   props: ['post'],
   template: `
   <div class="blog-post">
     <h3>{{ post.title }}</h3>
     <div v-html="post.content"></div>
   </div>
   `
 })
let vm2 = new Vue({
  el: '#blog-post-demo',
  data: {
    posts: [
      { id: 1, title: 'My journey with Vue', content: 'hello world' },
      { id: 2, title: 'Blogging with Vue', content: 'hello world' },
      { id: 3, title: 'Why Vue is so fun', content: 'hello world' }
    ]
  }
})
```

结果可以显示：

​	![image-20201020175807202](https://i.loli.net/2020/10/20/IRdTY3GCu45pZjD.png)

​		**注意**，尽管如此，直接在 DOM (即非字符串的模板) 中使用时只有 `kebab-case` 是有效的。(在`html`中写必须要使用kebab-case风格)

##### 第二个参数options: 选项参数

​          因为组件是可复用的 Vue 实例，所以它们与 `new Vue` 接收相同的选项，例如 `data`、`computed`、`watch`、`methods` 以及生命周期钩子等。仅有的例外是像 `el` 这样根实例特有的选项。

### 组件中的`data` 必须是一个函数

​		**一个组件的 `data` 选项必须是一个函数**，并且返回一个对象，保证组件内的数据都是独立的，相互不会冲突，因此每个实例可以维护一份被返回对象的独立的拷贝：

```js
data: function () {
  return {
    count: 0
  }
}
```

### 通过 Prop 向子组件传递数据

​		Prop 是你可以在组件上注册的一些自定义 attribute。例如：
​	

```html
<blog-post title="My journey with Vue"></blog-post>
```

​		如果是动态属性，则使用`v-bind`接收动态`prop`: title、content等数据。

```html
<blog-post v-bind:title="My journey with Vue"></blog-post>
```

当一个值传递给一个 prop attribute 的时候，它就变成了那个组件实例的一个 property。为了给博文组件传递一个标题，我们可以用一个 `props` 选项将其包含在该组件可接受的 prop 列表中：

```js
Vue.component('blog-post', {
  props: ['title'],
  template: '<h3>{{ title }}</h3>'
})
```

典型例子：

html:

​	需要哪个属性，则需要一个个添加后才能使用。

```html
<blog-post 
   v-for="post in posts" 
   v-bind:key="post.id" 
   v-bind:id='post.id' //需要显示哪个 就设置一下属性接收这个值
   v-bind:title="post.title" 
   v-bind:content="post.content"
 ></blog-post>
```

全局组件:

在`props`选项里，需要一个个设置上面html标签中接收的自定义属性(`key` 、`title`、`content`)，如果不设置，则在html中不能显示。

```js
 Vue.component('blog-post', {
   props: ['title', 'content', 'id'],
   template: `
    <h3>{{ title }}
    <h4>{{ content }}</h4>
    <h4>{{ id }}</h4>
    </h3>
  `
})
```

vue实例：

在data中设置posts数据，提供给`v-for`遍历。

```js
 let vm2 = new Vue({
            el: '#blog-post-demo',
            data: {
                posts: [
                    { id: 1, title: 'My journey with Vue', content: 'hello world' },
                    { id: 2, title: 'Blogging with Vue', content: 'hello world' },
                    { id: 3, title: 'Why Vue is so fun', content: 'hello world' }
                ]
            }
        })
```

#### 重构组件



看起来当组件变得越来越复杂的时候，我们的博文不只需要标题和内容，还需要发布日期、评论等等。为每个相关的信息定义一个 prop 会变得很麻烦：

```html
<blog-post
  v-for="post in posts"
  v-bind:key="post.id"
  v-bind:title="post.title"
  v-bind:content="post.content"
  v-bind:publishedAt="post.publishedAt"
  v-bind:comments="post.comments"
></blog-post>
```

所以是时候重构一下这个 `<blog-post>` 组件了，让它变成接受一个单独的 `post` prop：

 	`v-biind:post="post"`这里只需要写一个post，在组件中设置`props:['post']`，就能接收到v-for里的post，在`template`模板中可以使用post里的数据，不用在标签里设置一个个的prop。

```js
<blog-post
  v-for="post in posts"
  v-bind:key="post.id"
  v-bind:post="post" <!--这里只需要写一个post，就能接收到v-for里的post -->
></blog-post>
Vue.component('blog-post', {
  props: ['post'],
  template: `
    <div class="blog-post">
      <h3>{{ post.title }}</h3>
      <div v-html="post.content"></div>
    </div>
  `
})
```

Vue实例：

```js
let vm2 = new Vue({
            el: '#blog-post-demo',
            data: {
                posts: [
                    { id: 1, title: 'My journey with Vue', content: 'hello world' },
                    { id: 2, title: 'Blogging with Vue', content: 'hello world' },
                    { id: 3, title: 'Why Vue is so fun', content: 'hello world' }
                ]
            }
        })
```

现在，不论何时为 `post` 对象添加一个新的 property，它都会自动地在 `<blog-post>` 内可用。(在posts中的每一条数据增加新的property，都可以在组件标签`blog-post`中可用。)

### 局部组件

> 全局注册往往是不够理想的。比如，如果你使用一个像 webpack 这样的构建系统，全局注册所有的组件意味着即便你已经不再使用一个组件了，它仍然会被包含在你最终的构建结果中。这造成了用户下载的 JavaScript 的无谓的增加。

在这些情况下，你可以通过一个普通的 JavaScript 对象来定义组件：

```js
var ComponentA = { /* ... */ }
var ComponentB = { /* ... */ }
var ComponentC = { /* ... */ }
```

然后在 `components` 选项中定义你想要使用的组件：

```js
new Vue({
  el: '#app',
  components: {
    'component-a': ComponentA,
    'component-b': ComponentB
  }
})
```

#### 注册局部组件三步骤

1. ##### 定义组件

   ```js
    // 定义组件
   let btnHello = {
     template: `<button v-on:click="$emit('welcome')">
    	 	Click me to say hello
     </button>`
   }
   ```

   

2. 注册组件

   ```js
   //注册组件
   let vm = new Vue({
     el: '#app',
     components: {
       btnHello
     },
     methods: {
       sayHi: function () {
         alert("hi")
       }
     }
   })
   ```

3. 使用组件

   ```html
    <div id="app">
      <!-- 使用组件 -->
      <btn-hello v-on:welcome="sayHi"></btn-hello>
   </div>
   ```

4. 效果：点击会弹出hello。
   ![image-20201022010740507](https://i.loli.net/2020/10/22/hS2zCqvFBiuOVDR.png)
5. 注意：`$emit('hi')`里的事件名称，不能与methods里定义的事件名一样

#### 独立template模板

> 如果`template`中内容比较多的时候，如果全部都写在选项当中会显得非常累赘，这时我们可以把模板独立出来。
>
> 实际应用中，会把局部组件放在一个个的.vue文件中，引入使用。

1. 定义组件
   `template`里填写标签的id名，会根据templateID找到对应的组件内容。

   ```js
   let btnHi = {
     // 会根据templateID找到对应的组件内容
     template: "#sayHi"
   }
   ```

2. 注册组件

```js
//注册组件
let vm = new Vue({
  el: '#app',
  components: {
    btnHello,
    btnHi
  },
  methods: {
    sayHello: function () {
      alert("hello")
    },
    alertHi: function () {
      alert("hi")
    }
  }
})
```

3. 使用组件

   ```html
   <div id="app">
     <!-- 使用组件 -->
     <btn-hello v-on:welcome="sayHello"></btn-hello>
   	<btn-hi v-on:hi="alertHi"></btn-hi>
   </div>
   <template id="sayHi">
     <!-- 需要放在一个div里 -->
       <div>
         <p>独立模板</p>
       <!-- 注意：$emit('hi')里的事件名称，不能与methods里定义的事件名一样 -->
         <button v-on:click="$emit('hi')">
           Click me to say Hi!
          </button>
       </div>
   </template>
   ```

**注意**：

- `$emit('hi')`里的事件名称，不能与methods里定义的事件名一样。

**组件的标签名格式问题**

- `template`里的内容需要放在一个div里

在JS中可以使用驼峰式和短横线分隔命名方式，在html中必须要使用短横线分隔命名，都可以识别两种命名方式。

## 自定义组件的 v-model

### 在组件上使用 v-model

自定义事件也可以用于创建支持 `v-model` 的自定义输入组件。记住：

```html
<input v-model="searchText">
```

等价于：

```html
<input
  v-bind:value="searchText"
  v-on:input="searchText = $event.target.value"
>
```

当用在组件上时，`v-model` 则会这样：

```html
<custom-input
  v-bind:value="searchText"
  v-on:input="searchText = $event"
></custom-input>
```

为了让它正常工作，这个组件内的 `<input>` 必须：

- 将其 `value` attribute 绑定到一个名叫 `value` 的 prop 上
- 在其 `input` 事件被触发时，将新的值通过自定义的 `input` 事件抛出

写成代码之后是这样的：

```js
Vue.component('custom-input', {
  props: ['value'],
  template: `
    <input
      v-bind:value="value"
      v-on:input="$emit('input', $event.target.value)"
    >
  `
})
let vm = new Vue({
  el: "#app",
  data: {
    searchText: "1"
  }
})
```

现在 `v-model` 就应该可以在这个组件上完美地工作起来了：

```html
<custom-input v-model="searchText"></custom-input>
<div>{{searchText}}</div>
```

### model选项

一个组件上的 `v-model` 默认会利用名为 `value` 的 prop 和名为 `input` 的事件，但是像单选框、复选框等类型的输入控件可能会将 `value` attribute 用于[不同的目的](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value)。`model` 选项可以用来避免这样的冲突：

```js
Vue.component('base-checkbox', {
  model: {
    prop: 'checked',
    event: 'change'
  },
  props: {
    checked: Boolean
  },
  template: `
    <input
      type="checkbox"
      v-bind:checked="checked"
      v-on:change="$emit('change', $event.target.checked)"
    >
  `
})
```

现在在这个组件上使用 `v-model` 的时候：

```html
<base-checkbox v-model="lovingVue"></base-checkbox>
```

这里的 `lovingVue` 的值将会传入这个名为 `checked` 的 prop。同时当 `<base-checkbox>` 触发一个 `change` 事件并附带一个新的值的时候，这个 `lovingVue` 的 property 将会被更新。

### model API

> 2.2.0 新增

- **类型**：`{ prop?: string, event?: string }`

- **详细**：

  允许一个自定义组件在使用 `v-model` 时定制 prop 和 event。默认情况下，一个组件上的 `v-model` 会把 `value` 用作 prop 且把 `input` 用作 event，但是一些输入类型比如单选框和复选框按钮可能想使用 `value` prop 来达到不同的目的。使用 `model` 选项可以回避这些情况产生的冲突。

- **Example**：

  ```js
  Vue.component('my-checkbox', {
    model: {
      prop: 'checked',
      event: 'change'
    },
    props: {
      // this allows using the `value` prop for a different purpose
      value: String,
      // use `checked` as the prop which take the place of `value`
      checked: {
        type: Number,
        default: 0
      }
    },
    // ...
  })
  ```

  ```html
  <my-checkbox v-model="foo" value="some value"></my-checkbox>
  ```

  上述代码相当于：

  ```html
  <my-checkbox
    :checked="foo"
    @change="val => { foo = val }"
    value="some value">
  </my-checkbox>
  ```