### 在原型上扩充方法

> 把一些公共方法写到内置类的原型上，这样实例调用起来会很方便。
>
> 我们自定义的属性方法最好设置前缀，myXxx，为了防止自己的方法覆盖默认的方法。

#### 自定义一个数组去重方法

```js
Array.prototype.unique = function unique() {
    // 保证：this是当前要操作的数组
    if (!Array.isArray(this)) throw new TypeError('确保操作的是一个数组!');
    return Array.from(new Set(this));
};
let arr = [1, 3, 2, 3, 4, 4, 2, 2, 1, 2, 3, 4, 2];
console.log(arr.unique());//1234
```

**链式写法：**

> 保证上一个方法执行完，返回的结果依然是某个类的实例，这样就可以继续调用这个类原型上的方法了

```js
console.log(arr.unique().sort((a, b) => a - b));
console.log(arr.unique().sort((a, b) => a - b).push('lili').toFixed(2).split('.')...);
```

#### 面试题

实现如下需求：

```js
let n = 10;
let m = n.plus(10).minus(5);
console.log(m);//=>15（10+10-5）
```

首先，我们需要知道基本数据类型值和引用数据类型值调用方法的不同

##### JS中创建值有两种方案：

1. 字面量方式   ---> let a
2. 构造函数方式   --->new Number()

不论使用哪一种方式，创建出来的值都是所属类的实例

##### 基本数据类型值

1. 字面量方式创建出来的是基本数据类型值
2. 构造函数创建出来的是引用数据类型值
3. Symbol和BigInt不是构造函数，不能使用new创建值

**为什么基本数据类型的值也能调用类原型上的方法呢？**

> 浏览器在处理基本值调用原型上方法的时候，其实内部也是会把基本类型值变为对象实例模式，再次调用的

```js
let n = 10;
let m = new Number(10);
// m.toFixed(2);
// n.toFixed(2); 浏览器在处理基本值调用原型上方法的时候，其实内部也是会把基本类型值变为对象实例模式，再次调用的
```

##### 引用数据类型

1. 两种创建方法的结果是一样的
2. "new 类(x)"传递的参数不同，得到的结果也不同

```js
let obj1 = {};
let obj2 = new Object();
//这两种方式创建的对象是一样的
```

##### 解决方案：

`n.plus(10)`n调用时会转化成引用数据类型，所以plus函数里面的this是一个对象，

对象和数字相加大部分都会转换成字符串拼接，所以要对num转换成带有原始值的引用数据类型值，才进行相加。

> **对象+数值**：大部分情况都会变为字符串拼接，除 {}+num 及 当前对象有原始值[[PrimitiveValue]]；
>
> **相加过程**：把对象转换为数字，首先调用valueOf方法获取原始值(number/string/boolean/Date...)，如果有原始值，则直接获取到原始值的结果即可，并且可以参与到后续的运算中；
>
> 如果没有原始值，则继续调用toString先转换为字符串，后续再基于Number转换为数字

```js
//增加一个数据类型转换的方法，实现数字和对象相加
const validateNum = function validateNum(num) {
    num = Number(num);
    return isNaN(num) ? 0 : num;
};
Number.prototype.plus = function plus(num) {
    // THIS是引用数据类型值（基于call/apply/bind等改变this指向，this可以是基本数据类型的值）
    // console.log(typeof this); //=>"object"
    // 对象+数值：大部分情况都会变为字符串拼接，除 {}+num 及 当前对象有原始值[[PrimitiveValue]]
    //  + 把对象转换为数字，首先调用valueOf方法获取原始值(number/string/boolean/Date...)，如果有原始值，则直接获取到原始值的结果即可，并且可以参与到后续的运算中
    //  + 如果没有原始值，则继续调用toString先转换为字符串，后续再基于Number转换为数字
    num = validateNum(num);//把基本数据类型转换成带有原始值的引用数据类型
    return this + num;
};
Number.prototype.minus = function minus(num) {
    num = validateNum(num);
    return this - num;
};

let n = 10;
let m = n.plus(10).minus(5);
console.log(m); //=>15（10+10-5）
```

##### 哪种数据类型有原始值？valueof调用的是谁的方法？

数组没有valueof，调用的是Object上的valueof，没有自己的原始值

String/Boolean/Symbol/Number有valueof，也有自己的原始值

![image-20200831170459944](https://i.loli.net/2020/08/31/P2ZbfOKVp6hLvdN.png)

