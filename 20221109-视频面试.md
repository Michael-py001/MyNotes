## 1. JS数据类型有哪些

​	**Number,String,null,undefind,boolean,object,bigint,symbol**

## 2.如果一个对象作为函数的参数，在函数里对这个参数进行改变，会影响到外面的对象吗？

​	会，对象是作为引用类型的使用，指向的内存地址不会变，内存地址指向的内容会改变。

## 3.Vue的组件通信有哪些方式

​	1. 父子：props + emit ，$parent，$children;

2. 父孙：

   - 两次父子通信实现
   - 使用provide + inject 来通信
3. 任意组件：使用eventBus = new Vue()来通信

   - 主要API是eventBus.$on和eventBus.$emit()
   - 缺点是事件多了就难以维护
4. 任意组件：使用Vuex通信，Vue3使用Pinia代替

​	此外还可以使用localstorage。

## 4.Vue3对比Vue2有哪些改进

 - 数据响应式的方案变成了Proxy，Vue2是使用Object.defineproperty
 - template模板可以使用多个根标签
 - 使用composition API ，更好地维护代码

## 5. Vue2的响应式数据是怎么实现的，有什么缺陷？

​	使用Object.defineproperty(), 对

- 直接改变数组下标时不会被检测到改变
- 直接修改对象的属性值时不会被检测到改变

> ​	[Vue2源码解读（4） - 响应式原理及简单实现 - 石志凯 - 博客园 (cnblogs.com)](https://www.cnblogs.com/shizk/p/15456247.html)

​	实现响应式的代码：

```js
function updateView () {
  console.log('视图更新')
}

// 重新定义数组原型
const oldArrayProperty = Array.prototype
// 创建新对象原型指向 Array.prototype，在扩展新的方法不会影响原型
const arrProto = Object.create(oldArrayProperty);
['push', 'pop', 'shift', 'unshift', 'splice','sort','reverse'].forEach(methodName => {
  arrProto[methodName] = function () {
    updateView()
    oldArrayProperty[methodName].call(this, ...arguments)
  } 
});

// 监听data传入的属性
function defineReactive(target, key, value) {
  // 深度监听 多层对象嵌套
  observer(value)
  // 核心api
  Object.defineProperty(target, key, {
    get() {
      return value
    },

    set(newVal) {
      // 设置新值也要监听 比如{age:27}
      observer(newVal)
      if (newVal !== value ) {
        value = newVal
        updateView()
      }
    }
  })
}
// 监听对象属性
function observer(target) {
  if (typeof target !== 'object' || target === null) {
    // 不是对象或数组
    return target
  }
  // 监听数组 把原数组的隐式原型赋值给我们定义好的数组对象
  if (Array.isArray(target)) {
    target.__proto__ = arrProto
  }
  // 重新定义各个属性，加getter、setter属性
  for(let key in target) {
    defineReactive(target, key, target[key])
  }
}

const data = {
  name: 'zk',
  age: 26,
  info: {
    address: 'city'  // 需深度监听
  },
  nums: [1, 2, 3]
}
observer(data)
// data.info.address = 'beijing' // 需要深度监听
// data.info = {address:'beijing'} // 需要深度监听
// data.x = 666                  // 新增属性，监听不到  需要vue.set方法 
// delete data.name              // 删除属性，监听不到  需要vue.delete方法 
data.nums.push(21)

```

## 6. 为什么在Vue2中使用数组API时可以检测到变化

​	因为Vue2里对7个数组API(pop,push,shift,unshift,splice,sort,reverse)进行了一层封装，当使用这些数组方法时，会自动对里面的值进行监听。

## 7. Vue2中对数组封装达到响应式的这种方法在设计模式上叫什么？

​	从源码来看，应该是观察者模式。

## 8. 你知道的设计模式有哪些？

- 单例模式

  > [JS设计模式一：单例模式 - 走看看 (zoukankan.com)](http://t.zoukankan.com/douglasvegas-p-5853579.html)

  单例模式之所以这么叫，是因为它限制一个类只能有一个实例化对象。

  **好处：**

  (1) 由于单例模式在内存中只有一个实例，减少内存开支，特别是一个对象需要频繁地创建销毁时，而且创建或销毁时性能又无法优化，单例模式就非常明显了。

  (2) 由于单例模式只生成一个实例，所以，减少系统的性能开销，当一个对象产生需要比较多的资源时，如读取配置，产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。

  (3) 单例模式可以避免对资源的多重占用，例如一个写文件操作，由于只有一个实例存在内存中，避免对同一个资源文件的同时操作。

  (4) 单例模式可以在系统设置全局的访问点，优化和共享资源访问，例如，可以设计一个单例类，负责所有数据表的映射处理

- 发布订阅模式 

- 观察者模式 Vue2中对数组的封装

- 工厂模式  jquery

## 9. Vue2的数据双向绑定是怎么实现的？

- 使用v-model实现，v-model是`v-bind:value`和`v-on:input`的语法糖

  - `v-bind:value`实现了data=>UI的单向绑定
  - `v-on:input`实现了UI=>data的单向绑定
  - 加起来就是双向绑定了

- ### 这两个单向绑定是如何实现的？

  - 前者通过Object.defineProperty API给data创建getter和setter，用于监听data的改变，data一变就会触发视图更新

  - 后者通过template compiler给DOM添加事件监听，DOM input的值变了就会去修改data

  - 代码：

    ```html
    <div>内容：<span id="content"></span></div>
    <input id="iptName" />
    ```

    ```js
    const iptName = document.getElementById('iptName')
    const content = document.getElementById('content')
    let obj = {
      name: ''
    }
    let newObj = JSON.parse(JSON.stringify(obj))
    Object.defineProperty(obj, 'name', {
      get() {
        return newObj.name
      },
    
      set(val) {
        if (val === newObj.name) return
        newObj.name = val
        observer()
      }
    })
    function observer () {
      iptName.innerText = obj.name
      content.innerText = obj.name
    }
    iptName.oninput = function () {
      obj.name = this.value
    }
    
    ```

## 10. JS的数据类型检测有哪些？

​	建议直接回答Object.prototype.toString.call()，最完美的方法。

- ### 数组类型的检测方法有哪些？

  - Array.isArray()
  - arr1 instanceof Array
  - Object.prototype.toString.call()

## 11. Vue的生命周期

- Vue2: beforeCreate, created, beforeMount , mounted, beforeUpdata, updated, beforeDestory, destoryed;
  还有三个不常用的：activated, deactivated,errorCaptured
- vue3: setup(Compostion API)，beforeCreate,created, beforeMount , mounted, beforeUpdata, updated, beforeUnmount, unmounted,activated, deactivated, errorCaptured

## 12. 请求接口放在哪个生命周期？

​	放在mounted里面，因为放在其他地方都不合适。

- ### 为什么不放在created里面？

  因为跟SSR有关，如果放在created里面，后端会执行一次，前端也会执行一次，不符合要求，使用mounted就合适，只会在前端执行一次。

## 13. 为什么v-if和v-show不能同时使用？

​	当它们都处于同一节点时，v-for 的优先级高于 v-if。这意味着，v-if 会在循环的每个元素上进行判断一次，会造成大量的性能消耗。

## 14. v-if和v-show的区别

`v-show` 本质是 **操作css样式display属性**来控制元素 **显示和隐藏**

`v-if` 本质是 **控制页面上DOM节点**添加和删除

## 15. Vue3为什么使用Proxy?

 1. 弥补 Object.defineProperty 的两个不足 

    a. 动态创建的 data 属性需要用 Vue.set 来赋值，Vue 3 用了 Proxy 就不需要了 

    b. 基于性能考虑， [Vue 2 篡改了数组的 7 个 API](https://cn.vuejs.org/v2/guide/list.html#%E5%8F%98%E6%9B%B4%E6%96%B9%E6%B3%95)，Vue 3 用了 Proxy 就不需要了 

2. defineProperty 需要提前递归地遍历 data 做到响应式，而 Proxy 可以在真正用到 深层数据的时候再做响应式（惰性）

## 16. Vue3相比Vue2有了哪些改进？

1. 响应式系统

​		vue2中采用 defineProperty来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加getter和setter，实现响应式。vue3采用proxy重写了响应式系统，因为proxy可以对整个对象进行监听，所以不需要深度遍历

- 可以监听动态属性的添加
- 可以监听到数组的索引和数组length属性
- 可以监听删除属性

2. 源码体积

   相比Vue2，Vue3整体体积变小了，除了移除一些不常用的API，再重要的是Tree shanking。

   任何一个函数，如ref、reavtived、computed等，仅仅在用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小.

3. diff算法优化

   vue2中的虚拟dom是全量的对比，

   vue3在diff算法中相比vue2增加了`patch flag`静态标记，其作用是在发生变化的地方添加一个flag标记，下次发生变化的时候直接找该地方进行比较。

## 17. Vue 3 对比 Vue 2 做了哪些改动？

 官方文档 写了[（ 中文在这 ）](https://v3.cn.vuejs.org/guide/migration/introduction.html#%E9%9D%9E%E5%85%BC%E5%AE%B9%E7%9A%84%E5%8F%98%E6%9B%B4)，这里列出几个容易被考的： 

1. createApp() 代替了 new Vue() 
2. v-model 代替了以前的 v-model 和 .sync 
3. 根元素可以有不止一个元素了 
4. 新增 Teleport 传送门 
5. destroyed 被改名为 unmounted 了（before 当然也改了） 
6. ref 属性支持函数了 

其他建议自己看看写写。

## 18.display:inline-block幽灵节点问题

如果两个span或者img标签一起写，会有中间的缝隙

- 解决办法：改成display:block

## 19.Vue的路由模式

- hash
- histroy

## 20.Vue路由跳转的API

- route.push()
- route.replace()
- route.go() // -1可以回退
- route.back()

## 21.线上项目遇到问题处理

- 后端自动回滚上一个版本

## 22.Vue渐进式的理解

## 23.git冲突怎么处理

- 冲突后怎么处理
- 怎么避免冲突

## 24.CSS3动画的属性

