

> 精选面试资料：
>
> [前端面试宝典 (yuque.com)](https://gxaedu.yuque.com/yi2lv1/ymweyp)
>
> [BFE.dev - 前端刷题，提升前端开发实力，拿到心仪的Offer。 (bigfrontend.dev)](https://bigfrontend.dev/zh)

## 1. JS数据类型有哪些

​	**Number,String,null,undefind,boolean,object,bigint,symbol**

## 2.函数的参数是按值传递还是按引用传递?

> ​	参考：20230208-函数的参数是按值传递还是按引用传递？

在 JavaScript 中，函数的参数传递是按值传递的。这意味着，当一个函数被调用时，它的参数会被复制到函数的局部变量中，而不是直接传递引用。

需要注意的是，如果函数的参数是一个对象或数组，那么复制的**是对象或数组的引用(引用地址)**，而不是对象或数组本身。这意味着，如果在函数内部修改了对象或数组的属性(**修改的是地址指向的内容**)，那么这个修改会影响到原始对象或数组。

例如，考虑以下代码：

```js
function changeName(person) {
 person.name = 'Alice';
}

var person = { name: 'Bob' };
changeName(person);
console.log(person.name); // 输出 'Alice'
```

在这个例子中，`changeName` 函数的参数 `person` 是一个对象。当函数被调用时，`person` 的值被复制到函数的局部变量中，但是这个值是对象的引用。因此，当在函数内部修改 `person` 的属性时，这个修改会影响到原始对象 `person`。

需要注意的是，虽然函数的参数传递是按值传递的，但是如果参数是一个对象或数组，那么这个值是对象或数组的引用。因此，在处理函数的参数时，需要注意对象和数组的引用关系，以避免出现意外的副作用。

### 例子 ：一   基本类型

```js
let a = 1
function change(x) {
	x += 2
    console.log("x:",x)
    console.log("a:",a)
}
change(a)
// x: 3
// a: 1
```

### 例子 ：二  引用类型

```js
let a = {value:'1'}
function change(x) {
	x.value = 2
    console.log("x:",x)
    console.log("a:",a)
}
change(a)
// x {value: 2}
// a {value: 2}
```

### 例子 ：三  引用类型

```js
let a = {value:'1'}
function change(x) {
	x.value = 2
    x = {name:'lili'}
    console.log("x:",x)
    console.log("a:",a)
}
change(a)
// x {name: 'lili'}
// a {value: 2}
```



## 3.Vue的组件通信有哪些方式

1. **父子组件通信**：父组件可以通过 props 向子组件传递数据，子组件可以通过 $emit 触发事件向父组件传递数据。(props + emit ，$parent，$children;)
2. **兄弟组件通信**：可以通过一个共同的父组件作为中介，将数据通过 props 和 $emit 分别传递给两个兄弟组件。
3. **跨级组件通信**：可以通过 provide 和 inject 来实现跨级组件通信，provide 可以在父组件中提供数据，inject 可以在子组件中注入数据。
4. **非父子组件通信**：可以使用一个空的 Vue 实例作为中央事件总线（**Event Bus**），用它来触发事件和监听事件，从而实现任意组件之间的通信。(缺点是事件多了就难以维护)
5. **Vuex 状态管理**：Vuex 是 Vue 官方提供的状态管理库，可以将共享的状态抽离出来，以 store 的形式集中管理，从而实现组件之间的通信。

需要注意的是，不同的组件通信方式适用于不同的场景，应根据具体的业务需求选择合适的方式。同时，过多的组件通信也可能会导致代码复杂度增加，因此应尽量避免过度使用组件通信。

此外还可以使用localstorage。

### Event Bus的原理是什么

Event Bus 是一种组件通信方式，它的原理是利用 Vue 实例作为中央事件总线，用它来触发事件和监听事件，从而实现任意组件之间的通信。

具体来说，Event Bus 的原理如下：

1. 创建一个空的 Vue 实例，作为中央事件总线。

   ```js
   // event-bus.js
   import Vue from 'vue';
   export const EventBus = new Vue();
   ```

   

2. 在需要通信的组件中，通过 `$emit` 方法触发事件，并将需要传递的数据作为参数传入。

   ```js
   // componentA.vue
   import { EventBus } from './event-bus.js';
   export default {
     methods: {
       handleClick() {
         EventBus.$emit('event-name', data);
       }
     }
   }
   ```

   

3. 在需要接收数据的组件中，通过 `$on` 方法监听事件，并在回调函数中获取传递的数据。

   ```js
   // componentB.vue
   import { EventBus } from './event-bus.js';
   export default {
     created() {
       EventBus.$on('event-name', data => {
         // 处理数据
       });
     }
   }
   ```

   

4. 当事件被触发时，中央事件总线会将事件和数据广播给所有监听该事件的组件。

需要注意的是，Event Bus 的使用需要谨慎，因为它会将所有事件广播给所有组件，可能会导致性能问题和代码复杂度增加。因此，应尽量避免过度使用 Event Bus，而是根据具体的业务需求选择合适的组件通信方式。

## 5. Vue2的响应式数据是怎么实现的，有什么缺陷？

Vue2 中的响应式系统是通过 `Object.defineProperty()` 方法实现的，该方法可以将一个对象的属性定义为“响应式”，当属性值发生变化时，会自动触发相关的更新操作。虽然 `Object.defineProperty()` 方法在实现响应式系统方面具有一定的优势，但也存在一些缺点，包括：

1. **对象新增或删除属性时无法监听**：`Object.defineProperty()` 方法只能监听已经存在的属性，无法监听对象新增或删除属性的操作。这意味着，如果你需要监听对象新增或删除属性的操作，就需要使用其他的方法（如 `Vue.set()` 和 `Vue.delete()`）。
2. **对象嵌套层级过深时性能较差**：`Object.defineProperty()` 方法只能监听对象的一层属性，如果对象嵌套层级过深，就需要递归遍历对象的每一层属性，这可能会导致性能问题。
3. **无法监听数组下标的变化**：`Object.defineProperty()` 方法无法监听数组下标的变化，因为数组的下标不是一个属性，而是一个索引。因此，如果你需要监听数组下标的变化，就需要使用其他的方法（如 `Vue.set()` 和 `Vue.delete()`）。
4. **兼容性问题**：`Object.defineProperty()` 方法在 IE8 及以下版本的浏览器中不支持，因此在开发过程中需要注意兼容性问题。

为了解决以上问题，Vue3 中采用了 Proxy 对象来实现响应式系统，Proxy 对象可以监听对象的新增、删除和修改操作，而且性能也比 `Object.defineProperty()` 方法更好。

> ​	[Vue2源码解读（4） - 响应式原理及简单实现 - 石志凯 - 博客园 (cnblogs.com)](https://www.cnblogs.com/shizk/p/15456247.html)

​	实现响应式的代码：

```js
function updateView () {
  console.log('视图更新')
}

// 重新定义数组原型
const oldArrayProperty = Array.prototype
// 创建新对象原型指向 Array.prototype，在扩展新的方法不会影响原型
const arrProto = Object.create(oldArrayProperty);
['push', 'pop', 'shift', 'unshift', 'splice','sort','reverse'].forEach(methodName => {
  arrProto[methodName] = function () {
    updateView()
    oldArrayProperty[methodName].call(this, ...arguments)
  } 
});

// 监听data传入的属性
function defineReactive(target, key, value) {
  // 深度监听 多层对象嵌套
  observer(value)
  // 核心api
  Object.defineProperty(target, key, {
    get() {
      return value
    },

    set(newVal) {
      // 设置新值也要监听 比如{age:27}
      observer(newVal)
      if (newVal !== value ) {
        value = newVal
        updateView()
      }
    }
  })
}
// 监听对象属性
function observer(target) {
  if (typeof target !== 'object' || target === null) {
    // 不是对象或数组
    return target
  }
  // 监听数组 把原数组的隐式原型赋值给我们定义好的数组对象
  if (Array.isArray(target)) {
    target.__proto__ = arrProto
  }
  // 重新定义各个属性，加getter、setter属性
  for(let key in target) {
    defineReactive(target, key, target[key])
  }
}

const data = {
  name: 'zk',
  age: 26,
  info: {
    address: 'city'  // 需深度监听
  },
  nums: [1, 2, 3]
}
observer(data)
// data.info.address = 'beijing' // 需要深度监听
// data.info = {address:'beijing'} // 需要深度监听
// data.x = 666                  // 新增属性，监听不到  需要vue.set方法 
// delete data.name              // 删除属性，监听不到  需要vue.delete方法 
data.nums.push(21)

```

## 6. 为什么在Vue2中使用数组API时可以检测到变化

​	因为Vue2里对7个数组API(pop,push,shift,unshift,splice,sort,reverse)进行了一层封装，当使用这些数组方法时，会自动对里面的值进行监听。

## 7. Vue2中对数组封装达到响应式的这种方法在设计模式上叫什么？

​	从源码来看，应该是观察者模式。

## 8. 你知道的设计模式有哪些？

- **单例模式** : 确保一个类只有一个实例，并提供全局访问点。

  > [JS设计模式一：单例模式 - 走看看 (zoukankan.com)](http://t.zoukankan.com/douglasvegas-p-5853579.html)

  单例模式之所以这么叫，是因为它限制一个类只能有一个实例化对象。

  **好处：**

  1. 保证了全局只有一个实例，避免了重复创建对象的开销和资源浪费。
  2. 提供了全局访问点，方便了对象的访问和管理。
  3. 避免了多个实例之间的状态不一致问题，保证了数据的一致性。
  4. 可以控制对象的生成和销毁时机，从而更好地管理系统资源。
  
- **工厂模式**：通过一个工厂方法来创建对象，而不是通过直接调用构造函数来创建对象。

- **观察者模式**：定义了一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都会得到通知并自动更新。

- **装饰者模式**：动态地给一个对象添加一些额外的职责，而不需要修改这个对象的代码。

- **MVC 模式**：将应用程序分为三个部分：模型（Model）、视图（View）和控制器（Controller），从而实现了数据、视图和用户交互之间的分离。

- **发布订阅模式** : 用于解决对象之间的通信问题

## 9. Vue2的数据双向绑定是怎么实现的？

### 高级版

Vue2 的数据双向绑定是通过数据劫持和发布订阅模式实现的。

具体来说，Vue2 在初始化时会对**数据对象进行递归遍历**，将每个属性都**转换为 getter 和 setter**，并且在数据对象上**定义一个 `Dep` 对象**，用来收集依赖和通知更新。**当数据对象的属性被访问时**，会触发 getter 方法，此时会将当前的 `Watcher` 对象添加到 `Dep` 对象的依赖列表中。当数据对象的属性被修改时，会触发 setter 方法，此时会通知 `Dep` 对象的所有依赖进行更新。

在模板编译时，Vue2 会将模板中的指令和表达式解析成对应的 `Watcher` 对象，并将其添加到 `Dep` 对象的依赖列表中。当数据对象的属性被修改时，会触发 `Dep` 对象的更新方法，此时会通知所有依赖进行更新，从而实现了数据的双向绑定。

> #### `Watcher` 对象是什么？
>
> `Watcher` 对象是 Vue 中实现数据响应式的核心对象之一，用于监听数据的变化并触发对应的回调函数。
>
> 在 Vue 中，每个组件都会有一个 `Watcher` 对象，用于监听组件内部数据的变化。当组件内部的数据发生变化时，`Watcher` 对象会自动触发回调函数，从而更新组件的视图。
>
> 除了组件内部的数据变化，`Watcher` 对象还可以监听其他数据源的变化，例如 Vuex 中的状态变化、路由参数的变化等。通过监听这些数据源的变化，`Watcher` 对象可以及时更新组件的视图，保证视图与数据的同步。
>
> 需要注意的是，Vue3 中的 `Watcher` 对象已经被废弃，取而代之的是 `ReactiveEffect` 对象。`ReactiveEffect` 对象与 `Watcher` 对象类似，也用于监听数据的变化并触发回调函数。但是，与 `Watcher` 对象不同的是，`ReactiveEffect` 对象可以支持多个回调函数，从而提高了代码的灵活性和可维护性。

### 普通版

- 使用v-model实现，v-model是`v-bind:value`和`v-on:input`的语法糖

  - `v-bind:value`实现了data=>UI的单向绑定
  - `v-on:input`实现了UI=>data的单向绑定
  - 加起来就是双向绑定了

- ### 这两个单向绑定是如何实现的？

  - 前者通过Object.defineProperty API给data创建getter和setter，用于监听data的改变，data一变就会触发视图更新

  - 后者通过template compiler给DOM添加事件监听，DOM input的值变了就会去修改data

  - 代码：

    ```html
    <div>内容：<span id="content"></span></div>
    <input id="iptName" />
    ```

    ```js
    const iptName = document.getElementById('iptName')
    const content = document.getElementById('content')
    let obj = {
      name: ''
    }
    let newObj = JSON.parse(JSON.stringify(obj))
    Object.defineProperty(obj, 'name', {
      get() {
        return newObj.name
      },
    
      set(val) {
        if (val === newObj.name) return
        newObj.name = val
        observer()
      }
    })
    function observer () {
      iptName.innerText = obj.name
      content.innerText = obj.name
    }
    iptName.oninput = function () {
      obj.name = this.value
    }
    
    ```

## 10. JS的数据类型检测有哪些？

> ​	建议直接回答`Object.prototype.toString.call()`，最完美的方法。

1. **typeof 操作符**：可以检测基本数据类型（number、string、boolean、undefined）和函数类型，但无法检测 null 和对象类型。
2. **instanceof 操作符**：可以检测对象的具体类型，但无法检测基本数据类型和 null。
3. **Object.prototype.toString.call() 方法**：可以检测所有数据类型，包括基本数据类型、null 和对象类型。
4. **Array.isArray() 方法**：可以检测数组类型。

需要注意的是，typeof 操作符和 instanceof 操作符都存在一些局限性，不能完全准确地检测数据类型。因此，在实际开发中，应该根据具体的需求和场景选择合适的数据类型检测方式。

- ### 数组类型的检测方法有哪些？

  - Array.isArray()
  - arr1 instanceof Array
  - Object.prototype.toString.call()

## 11. Vue的生命周期

- Vue2: beforeCreate, created, beforeMount , mounted, beforeUpdata, updated, beforeDestory, destoryed;
  还有三个不常用的：activated, deactivated,errorCaptured
- vue3: setup(Compostion API)，beforeCreate,created, beforeMount , mounted, beforeUpdate, updated, beforeUnmount, unmounted,activated, deactivated, errorCaptured

## 12. 请求接口放在哪个生命周期？

在 Vue 中，通常将请求接口放在 `mounted` 生命周期中。`mounted` 生命周期是组件挂载后调用的钩子函数，此时组件已经渲染到页面上，可以访问 DOM 元素和组件实例。在 `mounted` 生命周期中发起请求，可以保证组件已经准备好了数据和 DOM，避免出现数据渲染不完整或者 DOM 元素未加载的问题。

- ### 为什么不放在created里面？

  因为跟SSR有关，如果放在created里面，后端会执行一次，前端也会执行一次，不符合要求，使用mounted就合适，只会在前端执行一次。

## 13. 为什么v-if和v-for不能同时使用？

​	**vue2中**：当它们都处于同一节点时，**v-for 的优先级高于 v-if**。这意味着，v-if 会在循环的每个元素上进行判断一次，会造成大量的性能消耗。

​    **vue3中**：当它们同时存在于一个节点上时，**`v-if` 比 `v-for` 的优先级更高**。这意味着 `v-if` 的条件将无法访问到 `v-for` 作用域内定义的变量别名：

```html
<!--
 这会抛出一个错误，因为属性 todo 此时
 没有在该实例上定义
-->
<li v-for="todo in todos" v-if="!todo.isComplete">
  {{ todo.name }}
</li>
```



## 14. v-if和v-show的区别

`v-show` 本质是 **操作css样式display属性**来控制元素 **显示和隐藏**

`v-if` 本质是 **控制页面上DOM节点**添加和删除

## 15. Vue3为什么使用Proxy?

 1. 弥补 Object.defineProperty 的两个不足 

    a. 动态创建的 data 属性需要用 Vue.set 来赋值，Vue 3 用了 Proxy 就不需要了 

    b. 基于性能考虑， [Vue 2 篡改了数组的 7 个 API](https://cn.vuejs.org/v2/guide/list.html#%E5%8F%98%E6%9B%B4%E6%96%B9%E6%B3%95)，Vue 3 用了 Proxy 就不需要了 

2. defineProperty 需要提前递归地遍历 data 做到响应式，而 Proxy 可以在真正用到 深层数据的时候再做响应式（惰性）

## 16. Vue3相比Vue2有了哪些改进？

- **更好的性能：响应式系统**

  vue2中采用 defineProperty来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加getter和setter，实现响应式。vue3采用proxy重写了响应式系统，因为proxy可以对整个对象进行监听，所以不需要深度遍历。相比 Vue2 中的 `Object.defineProperty()` 方法，Proxy 对象具有更好的性能和更广泛的兼容性

  - 可以监听动态属性的添加
  - 可以监听到数组的索引和数组length属性
  - 可以监听删除属性

- **更小的源码体积**：
  相比Vue2，Vue3整体体积变小了，除了移除一些不常用的API。

  Vue3 中采用了 Tree-shaking 技术，可以在打包时自动去除未使用的代码，从而减小项目的体积，如ref、reavtived、computed等，仅仅在用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小。

- **diff算法优化**

  vue2中的虚拟dom是全量的对比，

  vue3在diff算法中相比vue2增加了`patch flag`静态标记，其作用是在发生变化的地方添加一个flag标记，下次发生变化的时候直接找该地方进行比较。

- **更好的 TypeScript 支持**：Vue3 中对 TypeScript 的支持更加完善，包括更好的类型推断、更好的类型定义和更好的 IDE 支持。
- **更好的组合 API**：Vue3 中引入了 Composition API，可以更好地组织和复用组件逻辑，使代码更加清晰和易于维护。
- **更好的自定义指令**：Vue3 中对自定义指令的支持更加灵活，可以更方便地实现复杂的交互效果。
- **更好的性能调优工具**：Vue3 中引入了更多的性能调优工具，包括更好的 DevTools 和更好的性能分析工具，可以更方便地进行性能优化。

### vue3的diff算法对比vue2做了哪些优化

1. **静态节点提升**：Vue3 通过静态节点提升的方式，将静态节点和动态节点分离，从而减少了对动态节点的比对次数，提高了渲染性能。
2. **针对动态节点的优化**：Vue3 在比对动态节点时，采用了类似 React Fiber 的双缓存技术，将比对过程分为了两个阶段，从而减少了比对的时间和复杂度。
3. **缓存组件构造函数**：Vue3 在创建组件实例时，会缓存组件的构造函数，从而避免了重复的构造函数调用，提高了组件的创建性能。
4. **静态属性提升**：Vue3 通过静态属性提升的方式，将静态属性和动态属性分离，从而减少了对动态属性的比对次数，提高了渲染性能。
5. **模板编译优化**：Vue3 在模板编译时，采用了更加高效的编译器，从而生成更加高效的渲染函数，提高了渲染性能。

## 17. Vue 3 对比 Vue 2 做了哪些改动？

 官方文档 写了[（ 中文在这 ）](https://v3.cn.vuejs.org/guide/migration/introduction.html#%E9%9D%9E%E5%85%BC%E5%AE%B9%E7%9A%84%E5%8F%98%E6%9B%B4)，这里列出几个容易被考的： 

1. createApp() 代替了 new Vue() 
2. v-model 代替了以前的 v-model 和 .sync 
3. 根元素可以有不止一个元素了 
4. 新增 Teleport 传送门 
5. destroyed 被改名为 unmounted 了（before 当然也改了） 
6. ref 属性支持函数了 

其他建议自己看看写写。

## 18.display:inline-block幽灵节点问题

如果两个span或者img标签一起写，会有中间的缝隙

- 解决办法：改成display:block

## 19.Vue的路由模式

Vue 提供了两种路由模式：`hash` 模式和 `history` 模式。

在 `hash` 模式下，路由的路径会被格式化为 `/#/path/to/page` 的形式，其中 `#` 符号表示 URL 的锚点，后面的路径表示路由的路径。这种模式下，路由的变化不会触发浏览器的刷新，而是通过监听 `hashchange` 事件来实现路由的切换。

在 `history` 模式下，路由的路径会被格式化为 `/path/to/page` 的形式，这种模式下，路由的变化会触发浏览器的刷新，因此需要服务器端的支持。在使用 `history` 模式时，需要在服务器端配置一个 `fallback` 页面，用于处理路由的请求，从而避免出现 404 错误。

- nginx配置

  [不同的历史模式 | Vue Router (vuejs.org)](https://router.vuejs.org/zh/guide/essentials/history-mode.html#nginx)

  ```nginx
  location / {
    try_files $uri $uri/ /index.html;
  }
  ```

  

需要注意的是，无论是 `hash` 模式还是 `history` 模式，都需要在 Vue 的路由配置中进行相应的设置。在 Vue2 中，可以通过 `VueRouter` 的 `mode` 属性来设置路由模式，例如：

```js
const router = new VueRouter({
  mode: 'history',
  routes: [...]
})
```

在 Vue3 中，可以通过 `createRouter` 函数的 `history` 属性来设置路由模式，例如

```js
const router = createRouter({
  history: createWebHistory(),
  routes: [...]
})
```

需要注意的是，在使用 `history` 模式时，需要在服务器端进行相应的配置，以确保路由的正常访问。

这有一个注意事项。你的服务器将不再报告 404 错误，因为现在所有未找到的路径都会显示你的 `index.html` 文件。为了解决这个问题，你应该在你的 Vue 应用程序中实现一个万能的路由来显示 404 页面。

```js
const router = createRouter({
  history: createWebHistory(),
  routes: [{ path: '/:pathMatch(.*)', component: NotFoundComponent }],
})
```

## 20.Vue路由跳转的API

- route.push()
- route.replace()
- route.go() // -1可以回退
- route.back()

## 21.线上项目遇到问题处理

- 后端自动回滚上一个版本

## 22.Vue渐进式的理解

Vue 是一种渐进式 JavaScript 框架，渐进式意味着 Vue 可以根据项目的需求进行逐步引入和使用，而不需要一次性引入所有功能和特性。

Vue 的核心库只关注视图层，提供了一些基本的功能，如模板语法、组件系统、响应式数据绑定等。同时，Vue 还提供了一些插件和工具，如 Vue Router、Vuex、Vue CLI 等，用于处理路由、状态管理、构建工具等方面的问题。

Vue 的渐进式设计使得开发者可以根据项目的需求选择使用不同的功能和工具，而不需要承担额外的负担。

## 23.git冲突怎么处理

- 冲突后怎么处理
  - 打开冲突文件，查看冲突的部分，找到冲突的原因。
  - 手动修改冲突的部分，保留需要的代码，删除不需要的代码，或者根据需要进行合并。
  - 保存修改后的文件，然后使用 `git add` 命令将修改后的文件添加到暂存区。
  - 使用 `git commit` 命令提交修改，添加一条有意义的提交信息。

- 怎么避免冲突
  - 避免同时修改同一个文件的同一部分，可以在团队协作时分工明确，或者使用分支进行开发，避免多人同时修改同一个文件。
  - 在修改代码之前，先拉取最新的代码，避免修改过时的代码，导致冲突。
  - 在提交代码之前，先使用 `git diff` 命令查看修改的内容，确保没有修改不需要修改的部分。
  - 在提交代码之前，先使用 `git pull` 命令拉取最新的代码，避免其他人已经修改了相同的文件。


## css3新增属性有哪些？

1. `box-shadow`：用于添加元素的阴影效果。
2. `text-shadow`：用于添加文本的阴影效果。
3. `border-radius`：用于设置元素的圆角。
4. `background-size`：用于设置背景图片的大小。
5. `background-clip`：用于设置背景图片的裁剪方式。
6. `background-origin`：用于设置背景图片的起始位置。
7. `background-image`：用于设置元素的背景图片。
8. `transition`：用于设置元素的过渡效果。
9. `transform`：用于设置元素的变换效果，如旋转、缩放、平移等。
10. `animation`：用于设置元素的动画效果。

## 24.CSS3动画的属性

1. `animation-name`：指定动画的名称。
2. `animation-duration`：指定动画的持续时间。
3. `animation-timing-function`：指定动画的时间函数，用于控制动画的速度变化。
4. `animation-delay`：指定动画的延迟时间。
5. `animation-iteration-count`：指定动画的循环次数。
6. `animation-direction`：指定动画的播放方向。
7. `animation-fill-mode`：指定动画结束后元素的样式。
8. `animation-play-state`：指定动画的播放状态，用于控制动画的暂停和继续。



## 25. 手写深拷贝

```js
function deepCopy(obj, hash = new WeakMap()) {
  if (Object(obj) !== obj) return obj; // 基本类型直接返回
  if (hash.has(obj)) return hash.get(obj); // 避免循环引用
  let result;
  if (obj instanceof RegExp) {
    result = new RegExp(obj);
  } else if (obj instanceof Date) {
    result = new Date(obj);
  } else if (obj instanceof Function) {
    result = function () {
      return obj.apply(this, arguments);
    };
  } else if (obj instanceof Object) {
    result = new obj.constructor();//根据constructor创建一个新对象
    hash.set(obj, result);
    for (let key in obj) {
      if (obj.hasOwnProperty(key)) {
        result[key] = deepCopy(obj[key], hash);
      }
    }
  }
  return result;
}
```

## 手写浅拷贝

当我们需要对一个对象进行拷贝时，可以使用浅拷贝来复制对象的属性。浅拷贝只会复制对象的第一层属性，而不会递归地复制对象的子属性。

```Js
function shallowCopy(obj) {
  //如果传入的不是对象或者是null，直接返回
  if (typeof obj !== 'object' || obj === null) {
    return obj;
  }
  //根据对象类型创建新的对象
  const result = Array.isArray(obj) ? [] : {};
  //遍历原对象的属性并将其复制到新对象中。
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      result[key] = obj[key];//只会复制对象的第一层属性
    }
  }
  return result;
}
```

在上面的代码中，我们首先判断传入的参数是否为对象，如果不是对象则直接返回。然后根据对象的类型创建一个新的对象，遍历原对象的属性并将其复制到新对象中，最后返回新对象。

需要注意的是，浅拷贝只会复制对象的第一层属性，如果对象的属性值是一个对象或数组，则只会复制其引用，而不会复制其内容。如果需要递归地复制对象的子属性，可以使用深拷贝函数。

## 简单介绍下发布订阅模式

> 发布订阅模式是一种常用的设计模式，用于解决对象之间的通信问题。在发布订阅模式中，发布者对象和订阅者对象之间通过一个消息队列进行通信。发布者对象将消息发布到消息队列中，订阅者对象从消息队列中订阅消息。
>
> 发布订阅模式中，发布者对象和订阅者对象之间是一对多的关系，一个发布者对象可以有多个订阅者对象，而且订阅者对象之间也可以相互订阅。当发布者对象发布消息时，所有订阅者对象都会收到这个消息，并进行相应的处理。
>
> 发布订阅模式的优点是，可以实现对象之间的松耦合，从而提高系统的可扩展性和可维护性。同时，发布订阅模式也可以实现异步通信，从而提高系统的性能和响应速度。
>
> 需要注意的是，发布订阅模式也有一些缺点，如可能会导致代码的复杂度增加，因为需要考虑消息队列的管理和维护等问题。同时，发布订阅模式也可能会导致系统的可靠性降低，因为消息可能会丢失或重复发送。因此，在使用发布订阅模式时，需要根据具体的业务需求和场景进行权衡和选择。

### 前端的发布订阅模式用在哪？

> 前端的发布订阅模式可以用在以下场景：
>
> 1. **事件系统**：浏览器中的事件系统就是一种发布订阅模式，当事件触发时，所有订阅该事件的回调函数都会被执行。
> 2. **组件通信**：在组件化开发中，可以使用发布订阅模式来实现组件之间的通信，当一个组件的状态发生变化时，可以发布一个事件，其他组件可以订阅该事件并进行相应的处理。
> 3. **模块化开发**：在模块化开发中，可以使用发布订阅模式来实现模块之间的通信，当一个模块的状态发生变化时，可以发布一个事件，其他模块可以订阅该事件并进行相应的处理。
> 4. **异步编程**：在异步编程中，可以使用发布订阅模式来实现异步任务的回调函数管理，当异步任务完成时，可以发布一个事件，所有订阅该事件的回调函数都会被执行。

### 手写发布订阅模式

```js
class EventEmitter {
  constructor() {
    this.events = {};
  }

  on(eventName, listener) {
    if (!this.events[eventName]) {
      this.events[eventName] = [];
    }
    this.events[eventName].push(listener);
  }

  emit(eventName, ...args) {
    if (this.events[eventName]) {
      this.events[eventName].forEach(listener => {
        listener.apply(this, args);
      });
    }
  }

  off(eventName, listener) {
    if (this.events[eventName]) {
      this.events[eventName] = this.events[eventName].filter(l => l !== listener);
    }
  }
}

// 使用示例
const eventEmitter = new EventEmitter();

// 订阅事件
eventEmitter.on('click', () => {
  console.log('click event triggered');
});

// 发布事件
eventEmitter.emit('click');

// 取消订阅事件
const listener = () => {
  console.log('custom listener');
};
eventEmitter.on('custom', listener);
eventEmitter.off('custom', listener);
```

## 说说你对“高内聚，低耦合"的理解

高内聚和低耦合是软件设计中的两个重要概念。

**高内聚**指的是模块内部的各个元素之间的**联系紧密程度**，即一个模块内部的各个元素应该紧密相关，共同完成一个特定的功能。**高内聚的模块具有较强的独立性和可重用性，易于维护和扩展**。

**低耦合**指的是模块之间的依赖关系简单、松散，即**模块之间的相互影响程度较小**。低耦合的模块具有较强的独立性和可移植性，易于维护和扩展。

在软件设计中，高内聚和低耦合是两个**相互矛盾**的概念，但是它们又是**相互依存**的。**高内聚**可以**降低模块之间的耦合度**，从而提高系统的**可维护性**和**可扩展性**；而**低耦合**可以促进模块之间的**独立性**，从而提高系统的**可移植性**和可重用性。

因此，在软件设计中，应该尽量追求高内聚和低耦合的**平衡**，既要保证模块内部的紧密联系，又要保证模块之间的松散耦合。

### 在vue组件的设计上，怎么应用高内聚和低耦合的理念？

在 Vue 组件的设计中，可以通过以下方式应用高内聚和低耦合的理念：使用插槽可以使组件更加灵活和可配置

属性和数据传递：通过属性的方式进行、功能设计：尽量只实现一个功能、避免在组件内部调用其他组件的方法，而是通过事件的方式通信；组件拆分：复杂组件拆分成多个子组件，每个子组件实现一个功能。插槽和作用域插槽

1. **属性和数据传递**：组件之间的数据传递应该尽量通过属性的方式进行，而不是直接访问其他组件的数据。同时，应该尽量避免使用全局变量和单例模式等方式共享数据，以降低组件之间的耦合度。
2. **功能设计**：组件应该尽量只实现一个功能，而不是将多个功能混合在一起。这样可以提高组件的内聚性，使其更加独立和可重用。同时，应该尽量避免在组件内部直接调用其他组件的方法，而是通过事件的方式进行通信。
3. **组件拆分**：对于复杂的组件，可以将其拆分成多个子组件，每个子组件只实现一个功能。这样可以提高组件的内聚性和可重用性，同时也可以降低组件之间的耦合度。
4. **插槽和作用域插槽**：使用插槽和作用域插槽可以使组件更加灵活和可配置，同时也可以降低组件之间的耦合度。通过插槽和作用域插槽，可以将组件的样式和行为与具体的数据分离开来，使其更加独立和可重用。

总之，在 Vue 组件的设计中，应该尽量追求高内聚和低耦合的平衡，既要保证组件内部的紧密联系，又要保证组件之间的松散耦合。这样可以提高组件的可维护性、可扩展性和可重用性。

## vue3面试题

1. Vue3 与 Vue2 有哪些不同之处？
2. Vue3 中的 Composition API 是什么？它有什么优点？
3. Vue3 中的数据双向绑定是如何实现的？
4. Vue3 中的响应式系统是如何工作的？
5. Vue3 中的 Teleport 组件是什么？它有什么作用？
6. Vue3 中的 Suspense 组件是什么？它有什么作用？
7. Vue3 中的 Fragments 是什么？它有什么作用？
8. Vue3 中的 v-model 指令与 Vue2 有何不同？
9. Vue3 中的 setup 函数是什么？它有什么作用？
10. Vue3 中的 provide 和 inject API 是什么？它们有什么作用？

1. 什么是闭包？它有什么作用？
2. 什么是原型链？它有什么作用？
3. 什么是事件冒泡和事件捕获？它们有什么区别？
4. 什么是跨域？如何解决跨域问题？
5. 什么是异步编程？如何实现异步编程？
6. 什么是 Promise？它有什么作用？
7. 什么是 async/await？它们有什么作用？
8. 什么是 MVC、MVP 和 MVVM？它们有什么区别？
9. 什么是单向数据流？它有什么作用？
10. 什么是 Virtual DOM？它有什么作用？

## 面试自我介绍

大家好，我是 [你的名字]，很高兴来参加这次面试。我是一名前端工程师，有 [你的工作经验] 年的前端开发经验。我熟练掌握 HTML、CSS 和 JavaScript，并且熟悉常用的前端框架和库，如 Vue、React、jQuery 等。

在我的工作中，我主要负责 [你的工作职责]，并且积累了一定的项目经验。我喜欢学习新技术和解决问题，对前端开发有着浓厚的兴趣。我也喜欢和团队成员合作，共同完成项目并取得成功。

除了技术方面，我还注重自己的软实力，如沟通能力、团队协作能力和学习能力等。我相信这些能力对于一个前端工程师来说同样重要。

感谢您的时间，我期待能够加入贵公司并为其做出贡献。谢谢！

## 你上一家的薪资是多少？

关于上一家公司的薪资，我认为这并不是一个很好的参考，因为每个公司的薪资结构和福利待遇都不同。我更希望能够根据我的技能和经验来确定薪资水平。

## 你的期望薪资是多少？

关于期望薪资，我希望能够得到一个公平合理的薪资待遇，同时也考虑到公司的薪资结构和市场行情。我相信在我们进一步了解彼此之后，我们可以达成一个满意的协议。

> 需要注意的是，面试中的薪资问题可能比较敏感，你可以尽量避免直接回答具体的数字，而是强调你更关注于公平合理的薪资待遇，并且愿意在双方了解清楚情况后进行商讨。

## 说说你的优点和缺点

关于我的**优点**，我认为我有以下几个方面的优势：

1. [优点1]：例如，我有很强的学习能力和自我驱动力，能够快速适应新的技术和工作环境。
2. [优点2]：例如，我注重细节和质量，能够保证工作的准确性和高效性。
3. [优点3]：例如，我善于沟通和协作，能够与团队成员和客户保持良好的关系。

关于我的**缺点**，我也意识到自己有一些需要改进的地方：

1. [缺点1]：例如，我有时候会过于追求完美，导致工作进度有些缓慢。
2. [缺点2]：例如，我有时候会过于紧张和焦虑，需要更好地控制情绪。
3. [缺点3]：例如，我有时候会过于独立思考，需要更好地倾听他人的意见和建议。

需要注意的是，回答这个问题时，要注意**突出自己的优点**，同时也要坦诚地承认自己的缺点，并且表现出改进的意愿。同时，也要注意不要说出过于严重或者与工作无关的缺点，以免给 HR 留下不好的印象。

## 开放性问题

1. **你在前端项目中遇到最大的难题是什么，你是怎么解决的？**

   1. 后台页面中很多涉及到表单提交和表单展示，涉及到常用的一些表单控件，比如input输入框、下拉选择、日期选择等，页面做起来需要写的标签很多都是重复的，而且表单内容一旦多了，标签代码写起来就很多且很容易乱，这些重复的代码严重降低了开发效率，所以我针对这个情况封装了**配置式表单组件**，就是在JS中定义需要渲染的表单组件列表，每个组件用一个对象进行描述，比如组件的类型`type:'input'`，`label`,`name`,`rules`，等属性，组件内部自动会生成校验规则，数据双向绑定等。

      最后组件做完后，还遇到一个代码提示的问题，想要的效果是参照antd Vue组件，在鼠标放到组件属性上会显示可选值，在输入属性后也会有可选的代码提示。本来以为这个功能只要用ts定义了属性接口就能自动会有提示，但是实际发现并不行。为了实现这个代码提示功能，我去翻了好几遍的antd Vue的组件源码，终于发现了一些蛛丝马迹：原来vue提供了一个定义组件的ts泛型：**`DefineComponent`**，如果要实现属性的代码提示，就要在第11个参数写入组件的props定义。

   2. 项目最初是使用Vite2.6版本，这个Vite在开发环境的项目启动是很快，但是在开发环境下页面切换时需要几秒钟甚至10秒的时间，原因是因为使用了import动态导入组件，当页面切换时浏览器会请求这个组件，等待组件加载完后才会页面切换成功。这个等待的过程过长导致开发体验很不好，针对这个问题，我编写了一个**页面预加载的Vite插件**，这个插件的主要功能是解析在使用import 引入组件时加了`proload`关键字的组件，会添加到预加载队列，在项目首次启动时，会提前把这些组件加载，等用户切换页面时如果这个组件加载过，浏览器就会使用缓存加载，只需要十几毫秒，页面加载的速度也就实现秒加载了。
   3. **实现多账号管理功能**。需求是这样的：需要在客户端中同时登录和管理某个平台的多个账号，正常的浏览器登录一个网站后，再打开多个页面，都是同一个登录的用户。但是这个需求要求可以同时登录多个账号，刚开始听着这个需求挺难实现的，后面我就到处搜相关的文档和文章，也有在知乎、掘金上咨询过别人，最终总结出有两种方法可以实现，第一种是使用electron的新建BrowserView，但是这个方法会有层级问题，而且比较笨重，最终选了第二种，使用`webview`标签，每个标签加载一个网页，同时我翻阅了官方文档，找到了可以对webview进行环境隔离的方法，结合之前调研的平台都是使用cookies保存登录用户信息的，最终实现了webview之间cookies独立管理，这样每个页面相当于一个独立的浏览器，自然可以登录不同账户，实现多账号管理的功能了。

2. **你在前端开发中遵循哪些最佳实践和规范？你是如何确保代码的质量和可维护性的？**

   1. 使用模块化的开发方式，将代码分解为小的、可重用的模块，方便维护和测试。
   2. 遵循单一职责原则，确保每个组件和函数只负责一项功能，避免代码耦合和混乱。
   3. 使用代码格式化工具和代码风格规范，确保代码的一致性和可读性。
   4. 使用版本控制工具，如 Git，管理代码的版本和变更历史，方便团队协作和代码回滚。
   5. 使用代码分析工具，如 ESLint 或 TSLint，检查代码的质量和规范性，避免常见的错误和漏洞。

3. **你在前端开发中遇到过哪些性能问题？你是如何优化的？**

   在前端开发中，我遇到过的一个性能问题是页面加载速度过慢。当页面中包含大量的图片、视频或者其他资源时，会导致页面加载时间过长，影响用户的体验。

   为了解决这个问题，我采取了以下优化措施：

   1. 压缩和优化图片、视频等资源，减小文件大小，提高加载速度。
   2. 使用懒加载技术，将页面中的图片、视频等资源延迟加载，减少页面的初始加载时间。
   3. 使用 CDN 加速服务，将静态资源缓存到 CDN 中，提高资源的访问速度。
   4. 使用浏览器缓存，将静态资源缓存到浏览器中，减少重复加载的次数。

## 移动端适配问题你是怎么处理的?

在移动端适配方面，我采用了以下方法：

1. 使用flex弹性盒子布局。
2. 使用 rem 或者 vw/vh 等单位，避免使用固定的像素值。

1. 使用响应式布局，根据不同的屏幕尺寸和设备类型，自适应调整页面的布局和样式。
2. 使用 viewport 和媒体查询等技术，适配不同的屏幕尺寸和设备像素密度，确保页面在不同设备上的显示效果一致。

