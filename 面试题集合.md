

> 精选面试资料：
>
> [前端面试宝典 (yuque.com)](https://gxaedu.yuque.com/yi2lv1/ymweyp)
>
> [BFE.dev - 前端刷题，提升前端开发实力，拿到心仪的Offer。 (bigfrontend.dev)](https://bigfrontend.dev/zh)

## 1. JS数据类型有哪些

​	**Number,String,null,undefind,boolean,object,bigint,symbol**

## 2.函数的参数是按值传递还是按引用传递?

> ​	参考：20230208-函数的参数是按值传递还是按引用传递？

在 JavaScript 中，函数的参数传递方式取决于参数的类型：

1. **基本类型（按值传递）**：

   - 基本类型包括：`number`、`string`、`boolean`、`null`、`undefined`、`symbol`、`bigint`。
   - 当你将基本类型作为参数传递给函数时，传递的是值的副本(函数内部会把值复制一份供内部使用)。对参数的修改不会影响到原始变量。

   ```js
   function modifyValue(value) {
       value = 10;
   }
   
   let num = 5;
   modifyValue(num);
   console.log(num); // 输出: 5
   ```

2. **引用类型（按引用传递）**：

- 引用类型包括：`object`、`array`、`function`。

- 当你将引用类型作为参数传递给函数时，传递的是对象的引用。对参数的修改会影响到原始对象(**修改的是地址指向的内容**)。

  ```js
  function modifyObject(obj) {
      obj.name = 'Alice';
  }
  
  let person = { name: 'Bob' };
  modifyObject(person);
  console.log(person.name); // 输出: Alice
  ```

### 例子 ：一   基本类型

```js
let a = 1
function change(x) {
	x += 2
    console.log("x:",x)
    console.log("a:",a)
}
change(a)
// x: 3
// a: 1
```

### 例子 ：二  引用类型

```js
let a = {value:'1'}
function change(x) {
	x.value = 2
    console.log("x:",x)
    console.log("a:",a)
}
change(a)
// x {value: 2}
// a {value: 2}
```

### 例子 ：三  引用类型

```js
let a = {value:'1'}
function change(x) {
	x.value = 2
    x = {name:'lili'}
    console.log("x:",x)
    console.log("a:",a)
}
change(a)
// x {name: 'lili'}
// a {value: 2}
```

## 3.Vue的组件通信有哪些方式

1. **父子组件通信**：父组件可以通过 props 向子组件传递数据，子组件可以通过 $emit 触发事件向父组件传递数据。(props + emit ，$parent，$children;)
2. **兄弟组件通信**：可以通过一个共同的父组件作为中介，将数据通过 props 和 $emit 分别传递给两个兄弟组件。
3. **跨级组件通信**：可以通过 provide 和 inject 来实现跨级组件通信，provide 可以在父组件中提供数据，inject 可以在子组件中注入数据。
4. **事件总线**：可以使用一个空的 Vue 实例作为中央事件总线（**Event Bus**），用它来触发事件和监听事件，从而实现任意组件之间的通信。(缺点是事件多了就难以维护)

   ```js
   // eventBus.js
   import { createApp } from 'vue';
   export const eventBus = createApp({});
   ```

   ```vue
   <!-- 组件A -->
   <template>
     <button @click="sendMessage">Send Message</button>
   </template>
   
   <script>
   import { eventBus } from './eventBus';
   
   export default {
     methods: {
       sendMessage() {
         eventBus.config.globalProperties.$emit('message', 'Hello from Component A');
       }
     }
   };
   </script>
   ```

   ```vue
   <!-- 组件B -->
   <template>
     <div>{{ message }}</div>
   </template>
   
   <script>
   import { eventBus } from './eventBus';
   
   export default {
     data() {
       return {
         message: ''
       };
     },
     created() {
       eventBus.config.globalProperties.$on('message', (msg) => {
         this.message = msg;
       });
     }
   };
   </script>
   ```

5. **Vuex 全局状态管理**：Vuex 是 Vue 官方提供的状态管理库，可以将共享的状态抽离出来，以 store 的形式集中管理，从而实现组件之间的通信。

需要注意的是，不同的组件通信方式适用于不同的场景，应根据具体的业务需求选择合适的方式。同时，过多的组件通信也可能会导致代码复杂度增加，因此应尽量避免过度使用组件通信。

此外还可以使用localstorage。

### Event Bus的原理是什么

Event Bus 是一种组件通信方式，它的原理是利用 Vue 实例作为中央事件总线，用它来触发事件和监听事件，从而实现任意组件之间的通信。

具体来说，Event Bus 的原理如下：

1. 创建一个空的 Vue 实例，作为中央事件总线。

   ```js
   // event-bus.js
   import Vue from 'vue';
   export const EventBus = new Vue();
   ```

   

2. 在需要通信的组件中，通过 `$emit` 方法触发事件，并将需要传递的数据作为参数传入。

   ```js
   // componentA.vue
   import { EventBus } from './event-bus.js';
   export default {
     methods: {
       handleClick() {
         EventBus.$emit('event-name', data);
       }
     }
   }
   ```

3. 在需要接收数据的组件中，通过 `$on` 方法监听事件，并在回调函数中获取传递的数据。

   ```js
   // componentB.vue
   import { EventBus } from './event-bus.js';
   export default {
     created() {
       EventBus.$on('event-name', data => {
         // 处理数据
       });
     }
   }
   ```

4. 当事件被触发时，中央事件总线会将事件和数据广播给所有监听该事件的组件。

需要注意的是，Event Bus 的使用需要谨慎，因为它会将所有事件广播给所有组件，可能会导致性能问题和代码复杂度增加。因此，应尽量避免过度使用 Event Bus，而是根据具体的业务需求选择合适的组件通信方式。

## 5. Vue2的响应式数据是怎么实现的，有什么缺陷？

Vue2 中的响应式系统是通过 `Object.defineProperty()` 方法实现的，该方法可以将一个对象的属性定义为“响应式”，当属性值发生变化时，会自动触发相关的更新操作。虽然 `Object.defineProperty()` 方法在实现响应式系统方面具有一定的优势，但也存在一些缺点，包括：

1. **对象新增或删除属性时无法监听**：`Object.defineProperty()` 方法只能监听已经存在的属性，无法监听对象新增或删除属性的操作。这意味着，如果你需要监听对象新增或删除属性的操作，就需要使用其他的方法（如 `Vue.set()` 和 `Vue.delete()`）。
2. **对象嵌套层级过深时性能较差**：`Object.defineProperty()` 方法只能监听对象的一层属性，如果对象嵌套层级过深，就需要递归遍历对象的每一层属性，这可能会导致性能问题。
3. **无法监听数组下标的变化**：`Object.defineProperty()` 方法无法监听数组下标的变化，因为数组的下标不是一个属性，而是一个索引。因此，如果你需要监听数组下标的变化，就需要使用其他的方法（如 `Vue.set()` 和 `Vue.delete()`）。
4. **兼容性问题**：`Object.defineProperty()` 方法在 IE8 及以下版本的浏览器中不支持，因此在开发过程中需要注意兼容性问题。

为了解决以上问题，Vue3 中采用了 Proxy 对象来实现响应式系统，Proxy 对象可以监听对象的新增、删除和修改操作，而且性能也比 `Object.defineProperty()` 方法更好。

> ​	[Vue2源码解读（4） - 响应式原理及简单实现 - 石志凯 - 博客园 (cnblogs.com)](https://www.cnblogs.com/shizk/p/15456247.html)

​	实现响应式的代码：

```js
function updateView () {
  console.log('视图更新')
}

// 重新定义数组原型
const oldArrayProperty = Array.prototype
// 创建新对象原型指向 Array.prototype，在扩展新的方法不会影响原型
const arrProto = Object.create(oldArrayProperty);
['push', 'pop', 'shift', 'unshift', 'splice','sort','reverse'].forEach(methodName => {
  arrProto[methodName] = function () {
    updateView()
    oldArrayProperty[methodName].call(this, ...arguments)
  } 
});

// 监听data传入的属性
function defineReactive(target, key, value) {
  // 深度监听 多层对象嵌套
  observer(value)
  // 核心api
  Object.defineProperty(target, key, {
    get() {
      return value
    },

    set(newVal) {
      // 设置新值也要监听 比如{age:27}
      observer(newVal)
      if (newVal !== value ) {
        value = newVal
        updateView()
      }
    }
  })
}
// 监听对象属性
function observer(target) {
  if (typeof target !== 'object' || target === null) {
    // 不是对象或数组
    return target
  }
  // 监听数组 把原数组的隐式原型赋值给我们定义好的数组对象
  if (Array.isArray(target)) {
    target.__proto__ = arrProto
  }
  // 重新定义各个属性，加getter、setter属性
  for(let key in target) {
    defineReactive(target, key, target[key])
  }
}

const data = {
  name: 'zk',
  age: 26,
  info: {
    address: 'city'  // 需深度监听
  },
  nums: [1, 2, 3]
}
observer(data)
// data.info.address = 'beijing' // 需要深度监听
// data.info = {address:'beijing'} // 需要深度监听
// data.x = 666                  // 新增属性，监听不到  需要vue.set方法 
// delete data.name              // 删除属性，监听不到  需要vue.delete方法 
data.nums.push(21)

```

## 6. 为什么在Vue2中使用数组API时可以检测到变化

​	因为Vue2里对7个数组API(pop,push,shift,unshift,splice,sort,reverse)进行了一层封装，当使用这些数组方法时，会自动对里面的值进行监听。

## 7. Vue2中对数组封装达到响应式的这种方法在设计模式上叫什么？

​	在 Vue 2 中，对数组和对象进行响应式封装的机制被称为 **观察者模式（Observer Pattern）**。观察者模式是一种设计模式，它定义了对象间的一对多依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会收到通知并自动更新。

### 观察者模式的实现

在 Vue 2 中，响应式系统的核心是一个观察者（Observer）对象。这个对象会递归地遍历数据对象的所有属性，并使用 `Object.defineProperty` 将这些属性转换为 getter 和 setter，从而实现数据的响应式。

### Vue 2 中的响应式系统

1. **数据劫持**：
   - Vue 2 使用 `Object.defineProperty` 劫持对象的属性，给每个属性添加 getter 和 setter。
   - 当属性被访问时，getter 会被触发；当属性被修改时，setter 会被触发。
2. **依赖收集**：
   - 当组件渲染时，getter 会被触发，Vue 会收集依赖（即哪些组件依赖于这个属性）。
   - 这些依赖会被添加到一个依赖管理器（Dep）中。
3. **派发更新**：
   - 当属性的值发生变化时，setter 会被触发，Vue 会通知所有依赖于这个属性的组件进行更新。

### 设计模式

- **观察者模式（Observer Pattern）**：Vue 的响应式系统通过观察者模式实现，当数据变化时，自动通知并更新依赖于这些数据的视图。
- **发布-订阅模式（Publish-Subscribe Pattern）**：在某种程度上，Vue 的响应式系统也类似于发布-订阅模式，数据变化时发布通知，订阅者（组件）接收通知并更新。

## 8. 你知道的设计模式有哪些？

1. 单例模式（Singleton Pattern）

​	**定义**：确保一个类只有一个实例，并提供一个全局访问点。 **应用**：全局状态管理（如 Vuex、Redux）、配置管理、服务类（如 API 请求类）。

2. 工厂模式（Factory Pattern）

​	**定义**：定义一个创建对象的接口，但让子类决定实例化哪个类。 **应用**：组件创建、对象创建逻辑复杂时使用。
​	假设我们有一个表单组件，需要根据不同的表单类型生成不同的表单字段组件。我们可以使用工厂模式来简化这个过程。

1. 假设已有三个表单组件，现在创建表单字段工厂，根据传入的类型生成相应的表单字段组件。

```js
// formFieldFactory.js
import TextField from './TextField.vue';
import SelectField from './SelectField.vue';
import DateField from './DateField.vue';

export function createFormField(type) {
    const components = {
        text: TextField,
        select: SelectField,
        date: DateField
    };

    return components[type] || null;
}
```

2. 使用工厂函数生成表单字段：

```vue
<template>
    <div>
        <component
            v-for="(field, index) in formFields"
            :key="index"
            :is="field.component"
            v-model="field.value"
            v-bind="field.props"
        />
    </div>
</template>

<script>
import { createFormField } from './formFieldFactory';

export default {
    data() {
        return {
            formFields: [
                { type: 'text', value: '', props: {} },
                { type: 'select', value: '', props: { options: [{ value: '1', label: 'Option 1' }, { value: '2', label: 'Option 2' }] } },
                { type: 'date', value: '', props: {} }
            ]
        };
    },
    computed: {
        formFieldsWithComponents() {
            return this.formFields.map(field => ({
                ...field,
                component: createFormField(field.type)
            }));
        }
    }
};
</script>
```

3. 观察者模式（Observer Pattern）

​	**定义**：定义对象间的一对多依赖关系，当一个对象改变状态时，所有依赖于它的对象都会得到通知并自动更新。 **应用**：Vue 和 React 的响应式系统、事件监听机制。

4. 发布-订阅模式（Publish-Subscribe Pattern）

​	**定义**：通过一个事件通道，发布者发布事件，订阅者订阅事件。 **应用**：事件总线（Event Bus）、消息队列。

5.  装饰器模式（Decorator Pattern）

​	**定义**：动态地给对象添加新的功能。 **应用**：React 的高阶组件（HOC）、Vue 的指令。

### 示例回答

```
在前端开发中，我了解并使用过多种设计模式，包括：

1. **单例模式**：用于全局状态管理，例如 Vuex 或 Redux 确保全局状态对象只有一个实例。
2. **工厂模式**：用于组件创建，特别是在对象创建逻辑复杂时，通过工厂模式简化对象的创建过程。
3. **观察者模式**：Vue 和 React 的响应式系统就是基于观察者模式实现的，当数据变化时，自动通知并更新视图。
4. **发布-订阅模式**：通过事件总线实现组件之间的通信，例如在 Vue 中使用 Event Bus。
5. **装饰器模式**：在 React 中使用高阶组件（HOC）来动态地给组件添加新的功能。
6. **策略模式**：在表单验证中，根据不同的验证规则选择不同的策略进行验证。
7. **代理模式**：实现图片懒加载，通过虚拟代理控制图片的加载。
8. **适配器模式**：封装旧的接口，使其兼容新的系统或 API。
9. **组合模式**：用于树形结构的数据展示，例如文件系统或菜单。
10. **命令模式**：用于实现撤销操作或事务管理，将请求封装成对象进行处理。

这些设计模式帮助我在开发过程中解决了许多常见问题，提高了代码的可维护性和可扩展性。
```

## 9. Vue2的数据双向绑定是怎么实现的？

在 Vue 2 中，数据双向绑定是通过 **数据劫持（Data Hijacking）** 和 **发布-订阅模式（Publish-Subscribe Pattern）** 实现的。核心机制是使用 `Object.defineProperty` 方法将数据对象的属性转换为 getter 和 setter，从而实现数据的响应式。

### 实现原理

1. **数据劫持**：
   - Vue 2 使用 `Object.defineProperty` 劫持对象的属性，给每个属性添加 getter 和 setter。
   - 当属性被访问时，getter 会被触发；当属性被修改时，setter 会被触发。
2. **依赖收集**：
   - 当组件渲染时，getter 会被触发，Vue 会收集依赖（即哪些组件依赖于这个属性）。
   - 这些依赖会被添加到一个依赖管理器（Dep）中。
3. **派发更新**：
   - 当属性的值发生变化时，setter 会被触发，Vue 会通知所有依赖于这个属性的组件进行更新。

### 具体实现

以下是一个简化的实现示例，展示了 Vue 2 如何通过 `Object.defineProperty` 实现数据双向绑定：

```js
class Dep {
    constructor() {
        this.subscribers = [];
    }

    addSub(sub) {
        this.subscribers.push(sub);
    }

    notify() {
        this.subscribers.forEach(sub => sub.update());
    }
}

class Watcher {
    constructor(obj, key, cb) {
        Dep.target = this;
        this.cb = cb;
        this.obj = obj;
        this.key = key;
        this.value = obj[key]; // 触发 getter，添加依赖
        Dep.target = null;
    }

    update() {
        const newValue = this.obj[this.key];
        const oldValue = this.value;
        if (newValue !== oldValue) {
            this.value = newValue;
            this.cb(newValue, oldValue);
        }
    }
}

function defineReactive(obj, key, val) {
    const dep = new Dep();

    Object.defineProperty(obj, key, {
        get() {
            if (Dep.target) {
                dep.addSub(Dep.target);
            }
            return val;
        },
        set(newVal) {
            if (newVal !== val) {
                val = newVal;
                dep.notify();
            }
        }
    });
}

function observe(obj) {
    Object.keys(obj).forEach(key => defineReactive(obj, key, obj[key]));
}

// 使用示例
const data = { message: 'Hello, Vue!' };
observe(data);

new Watcher(data, 'message', (newVal, oldVal) => {
    console.log(`message changed from ${oldVal} to ${newVal}`);
});

data.message = 'Hello, World!'; // 输出: message changed from Hello, Vue! to Hello, World!
```



## 10. JS的数据类型检测有哪些？

> ​	建议直接回答`Object.prototype.toString.call()`，最完美的方法。

1. **typeof 操作符**：可以检测基本数据类型（number、string、boolean、undefined）和函数类型，但无法检测 null 和对象类型。

2. **instanceof 操作符**：可以检测**对象**的具体类型，但**无法检测基本数据类型和 null**。
   `instanceof` 是 JavaScript 中用于检测对象类型的运算符。它可以用来判断一个对象是否是某个构造函数的实例。

   - 用法

     ```js
     obj instanceof Constructor
     ```

     - `obj`：要检测的对象。
     - `Constructor`：构造函数。

   - 原理
     `instanceof` 运算符的原理是通过原型链来判断的。具体来说，它会检查对象的原型链中是否存在构造函数的 `prototype` 属性。

     - 检查对象的原型链：
       - `instanceof` 会沿着对象的原型链向上查找，直到找到与构造函数的 `prototype` 属性相同的原型对象。
       - 如果找到，则返回 [`true`](vscode-file://vscode-app/c:/Users/WuShiLi/AppData/Local/Programs/Microsoft VS Code Insiders/resources/app/out/vs/code/electron-sandbox/workbench/workbench.esm.html)；否则，返回 [`false`](vscode-file://vscode-app/c:/Users/WuShiLi/AppData/Local/Programs/Microsoft VS Code Insiders/resources/app/out/vs/code/electron-sandbox/workbench/workbench.esm.html)。

   - 具体步骤

     - 获取对象的原型（`obj.__proto__` 或 `Object.getPrototypeOf(obj)`）。
     - 获取构造函数的 `prototype` 属性。
     - 沿着对象的原型链向上查找，直到找到与构造函数的 `prototype` 属性相同的原型对象。
     - 如果找到，则返回 [`true`](vscode-file://vscode-app/c:/Users/WuShiLi/AppData/Local/Programs/Microsoft VS Code Insiders/resources/app/out/vs/code/electron-sandbox/workbench/workbench.esm.html)；否则，返回 [`false`](vscode-file://vscode-app/c:/Users/WuShiLi/AppData/Local/Programs/Microsoft VS Code Insiders/resources/app/out/vs/code/electron-sandbox/workbench/workbench.esm.html)。

3. **Object.prototype.toString.call() 方法**：可以检测所有数据类型，包括基本数据类型、null 和对象类型。

4. **Array.isArray() 方法**：可以检测数组类型。

- ### 数组类型的检测方法有哪些？

  - Array.isArray()
  - arr1 instanceof Array
  - Object.prototype.toString.call()
  - **constructor** 属性：每个对象都有一个 `constructor` 属性，指向创建该对象的构造函数。
  
    ```js
    const arr = [1, 2, 3];
    console.log(arr.constructor === Array); // 输出: true
    
    const notArr = 'hello';
    console.log(notArr.constructor === Array); // 输出: false
    ```

## 11. Vue的生命周期

### Vue 2 的生命周期钩子

1. **beforeCreate**：实例初始化之后，数据观测和事件配置之前调用。
2. **created**：实例创建完成，数据观测和事件配置之后调用，但尚未挂载 DOM。
3. **beforeMount**：在挂载开始之前调用，相关的 render 函数首次被调用。
4. **mounted**：实例被挂载后调用，DOM 已经渲染完成。
5. **beforeUpdate**：数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。
6. **updated**：由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用。
7. **beforeDestroy**：实例销毁之前调用，实例仍然完全可用。
8. **destroyed**：实例销毁后调用，所有的事件监听器被移除，所有的子实例也被销毁。

还有三个不常用的：activated, deactivated,errorCaptured

### Vue 3 的生命周期钩子

1. **beforeCreate**：等同于 `setup` 函数的开始。
2. **created**：等同于 `setup` 函数的结束。
3. **beforeMount**：在挂载开始之前调用。
4. **mounted**：实例被挂载后调用。
5. **beforeUpdate**：数据更新时调用。
6. **updated**：由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用。
7. **beforeUnmount**：实例卸载之前调用。
8. **unmounted**：实例卸载后调用。

#### Vue 3 组合式 API 中的生命周期钩子

在 Vue 3 中，组合式 API 提供了一组新的生命周期钩子函数，这些函数可以在 `setup` 函数中使用：

- `onBeforeMount`
- `onMounted`
- `onBeforeUpdate`
- `onUpdated`
- `onBeforeUnmount`
- `onUnmounted`

## 12. 请求接口放在哪个生命周期？

在 Vue 组件中，请求接口通常放在 `mounted` 生命周期钩子中。

这是因为 `mounted` 钩子在组件挂载到 DOM 后立即调用，此时可以安全地进行 DOM 操作和数据请求。

### 为什么选择 `mounted` 生命周期钩子？

1. **DOM 已经准备好**：在 `mounted` 钩子中，组件已经被挂载到 DOM 上，可以进行 DOM 操作。
2. **适合进行数据请求**：在组件挂载后立即请求数据，可以确保数据在组件渲染时已经准备好，从而避免空白或不完整的渲染。

### 其他生命周期钩子

虽然 `mounted` 是最常用的生命周期钩子来请求接口，但在某些情况下，你可能需要在其他生命周期钩子中进行请求：

- **`created`**：如果不需要等待组件挂载完成即可进行数据请求，可以在 `created` 钩子中进行请求。此时组件实例已经创建，但尚未挂载到 DOM。
- **`beforeMount`**：在组件挂载之前进行请求，但此时 DOM 还未准备好，通常不推荐。

### 为什么不放在created里面？

主要有以下几个原因：

#### 1. DOM 已经准备好

- **`mounted`**：在 `mounted` 钩子中，组件已经被挂载到 DOM 上，可以安全地进行 DOM 操作。如果接口请求返回的数据需要操作 DOM 或者依赖于 DOM 的存在，那么在 `mounted` 中进行请求是更安全的选择。
- **`created`**：在 `created` 钩子中，组件实例已经创建，但尚未挂载到 DOM 上。如果接口请求返回的数据需要操作 DOM，此时 DOM 还未准备好，可能会导致错误。

#### 2. 避免不必要的请求

- **`mounted`**：在某些情况下，组件可能会在创建后立即被销毁（例如在路由切换时）。如果接口请求放在 `created` 中，可能会导致不必要的请求。而在 `mounted` 中进行请求，可以确保组件已经挂载并且需要这些数据。

#### 3. 数据与视图的同步

- **`mounted`**：在 `mounted` 钩子中进行数据请求，可以确保数据在组件渲染时已经准备好，从而避免空白或不完整的渲染。
- **`created`**：虽然在 `created` 中进行数据请求也可以，但由于此时组件尚未挂载，可能会导致数据与视图不同步的问题。

## 13. 为什么v-if和v-for不能同时使用？

​	**vue2中**：当它们都处于同一节点时，**v-for 的优先级高于 v-if**。这意味着，v-if 会在循环的每个元素上进行判断一次，会造成大量的性能消耗。

​    **vue3中**：当它们同时存在于一个节点上时，**`v-if` 比 `v-for` 的优先级更高**。这意味着 `v-if` 的条件将无法访问到 `v-for` 作用域内定义的变量别名：

```html
<!--
 这会抛出一个错误，因为属性 todo 此时
 没有在该实例上定义
-->
<li v-for="todo in todos" v-if="!todo.isComplete">
  {{ todo.name }}
</li>
```



## 14. v-if和v-show的区别

`v-show` 本质是 **操作css样式display属性**来控制元素 **显示和隐藏**

`v-if` 本质是 **控制页面上DOM节点**添加和删除

## 15. Vue3为什么使用Proxy?

 1. 弥补 Object.defineProperty 的两个不足 

    a. 动态创建的 data 属性需要用 Vue.set 来赋值，Vue 3 用了 Proxy 就不需要了 

    b. 基于性能考虑， [Vue 2 篡改了数组的 7 个 API](https://cn.vuejs.org/v2/guide/list.html#%E5%8F%98%E6%9B%B4%E6%96%B9%E6%B3%95)，Vue 3 用了 Proxy 就不需要了 

2. defineProperty 需要提前递归地遍历 data 做到响应式，而 Proxy 可以在真正用到 深层数据的时候再做响应式（惰性）

## 16. Vue3相比Vue2有了哪些改进？

### 性能提升

- **编译器优化**：Vue 3 的编译器进行了优化，生成的代码更高效，减少了运行时的开销。
- **虚拟 DOM**：新的虚拟 DOM 实现更加高效，减少了不必要的重新渲染。
- **Tree-shaking**：Vue 3 支持 Tree-shaking，可以只打包实际使用的代码，减少了打包体积。

- **更好的性能：响应式系统**

  Vue 3 使用 Proxy 代替 Vue 2 中的 `Object.defineProperty` 实现响应式系统，解决了 Vue 2 中的一些限制，如无法检测数组索引和对象属性的添加和删除。

  vue2中采用 defineProperty来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加getter和setter，实现响应式。vue3采用proxy重写了响应式系统，因为proxy可以对整个对象进行监听，所以不需要深度遍历。相比 Vue2 中的 `Object.defineProperty()` 方法，Proxy 对象具有更好的性能和更广泛的兼容性

  - 可以监听动态属性的添加
  - 可以监听到数组的索引和数组length属性
  - 可以监听删除属性

- **更好的 Tree-shaking 支持**：

  - **模块化设计**：Vue 3 的模块化设计使得 Tree-shaking 更加高效，只打包实际使用的代码，减少了打包体积。

- **diff算法优化**

  vue2中的虚拟dom是全量的对比，

  vue3在diff算法中相比vue2增加了`patch flag`静态标记，其作用是在发生变化的地方添加一个flag标记，下次发生变化的时候直接找该地方进行比较。

- **更好的 TypeScript 支持**：Vue3 中对 TypeScript 的支持更加完善，包括更好的类型推断、更好的类型定义和更好的 IDE 支持。
- **组合式 API（Composition API）**：Vue3 中引入了 Composition API，可以更好地组织和复用组件逻辑，使代码更加清晰和易于维护。
- **更好的自定义指令**：Vue3 中对自定义指令的支持更加灵活，可以更方便地实现复杂的交互效果。
- **更好的性能调优工具**：Vue3 中引入了更多的性能调优工具，包括更好的 DevTools 和更好的性能分析工具，可以更方便地进行性能优化。

## vue3的diff算法对比vue2做了哪些优化

#### 1. 静态提升（Static Hoisting）

- **Vue 3**：在编译阶段，Vue 3 会将静态节点提升到渲染函数之外，从而避免每次渲染时重新创建这些节点。这减少了不必要的计算和内存分配。
- **Vue 2**：每次渲染都会重新创建所有节点，即使这些节点是静态的。

#### 2. Patch Flag

- **Vue 3**：引入了 Patch Flag，用于标记动态节点和静态节点。这样在更新时，Vue 3 可以快速跳过静态节点，只处理动态节点，从而提高更新效率。
- **Vue 2**：没有 Patch Flag，每次更新都需要遍历所有节点，效率较低。

#### 3. Block Tree

- **Vue 3**：引入了 Block Tree 概念，将动态节点分组为 Block。在更新时，只需要遍历这些 Block，而不是整个虚拟 DOM 树。这进一步减少了遍历的范围，提高了性能。
- **Vue 2**：没有 Block Tree 概念，每次更新都需要遍历整个虚拟 DOM 树。

#### 4. 更高效的事件处理

- **Vue 3**：在事件处理上进行了优化，减少了事件绑定和解绑的开销。
- **Vue 2**：事件处理相对较为简单，没有进行特别的优化。

#### 5. 更智能的子组件更新

- **Vue 3**：通过优化子组件的更新策略，Vue 3 可以更智能地判断哪些子组件需要更新，哪些不需要，从而减少不必要的更新。
- **Vue 2**：子组件更新策略相对简单，可能会导致一些不必要的更新。

#### 6. Fragment 支持

- **Vue 3**：支持 Fragment，可以返回多个根节点，减少了不必要的包裹元素，从而减少了 DOM 操作。
- **Vue 2**：不支持 Fragment，必须有一个单一的根节点。

#### 7. 更高效的 Diff 算法

- **Vue 3**：在 Diff 算法上进行了多项优化，包括更高效的节点比较和更智能的节点复用策略。
- **Vue 2**：Diff 算法相对简单，性能不如 Vue 3。

## 17. Vue 3 对比 Vue 2 做了哪些改动？

 官方文档 写了[（ 中文在这 ）](https://v3.cn.vuejs.org/guide/migration/introduction.html#%E9%9D%9E%E5%85%BC%E5%AE%B9%E7%9A%84%E5%8F%98%E6%9B%B4)，这里列出几个容易被考的： 

1. createApp() 代替了 new Vue() 
2. v-model 代替了以前的 v-model 和 .sync 
3. 根元素可以有不止一个元素了 
4. 新增 Teleport 传送门 
5. destroyed 被改名为 unmounted 了（before 当然也改了） 
6. ref 属性支持函数了 

其他建议自己看看写写。

## 18.display:inline-block幽灵节点问题

如果两个span或者img标签一起写，会有中间的缝隙

`display: inline-block` 会有幽灵节点（ghost node）问题。幽灵节点问题是指在使用 `inline-block` 布局时，元素之间会出现额外的空白间隙。这是因为 `inline-block` 元素之间的空白字符（如空格、换行符）会被渲染为一个空白节点。

解决方法：

### 移除空白字符

将 `inline-block` 元素之间的空白字符移除，可以通过将元素放在同一行来实现。

```html
<div style="display: inline-block;">Item 1</div><div style="display: inline-block;">Item 2</div>
```

### 使用注释移除空白字符

在 `inline-block` 元素之间使用注释来移除空白字符。

```html
<div style="display: inline-block;">Item 1</div><!--
--><div style="display: inline-block;">Item 2</div>
```

### 设置父元素的字体大小为 0

将父元素的字体大小设置为 0，这样空白字符就不会被渲染为可见的空白节点。然后再将子元素的字体大小恢复为正常值。

```html
<div style="font-size: 0;">
    <div style="display: inline-block; font-size: 16px;">Item 1</div>
    <div style="display: inline-block; font-size: 16px;">Item 2</div>
</div>
```

### 使用浮动（float）

使用 `float` 属性代替 `inline-block`，这样可以避免空白字符的问题。

```html
<div style="float: left;">Item 1</div>
<div style="float: left;">Item 2</div>
```

### 使用 Flexbox 或 Grid 布局

使用现代的布局方式如 Flexbox 或 Grid，可以避免 `inline-block` 布局带来的空白字符问题。

```html
<div style="display: flex;">
    <div>Item 1</div>
    <div>Item 2</div>
</div>
```

## 19.Vue的路由模式

Vue Router 提供了两种主要的路由模式：**哈希模式（Hash Mode）** 和 **历史模式（History Mode）**。每种模式都有其特点和适用场景。

### 哈希模式（Hash Mode）

#### 特点

- **URL 格式**：使用 `#` 符号作为路由的分隔符，例如 `http://example.com/#/home`。
- **浏览器支持**：兼容性好，支持所有现代浏览器和一些老旧浏览器。
- **无需服务器配置**：因为哈希部分不会被发送到服务器，所以不需要额外的服务器配置。

#### 工作原理

哈希模式利用了浏览器的 `hashchange` 事件，当 URL 中的哈希部分发生变化时，页面不会重新加载，Vue Router 会监听这个变化并更新视图。

```js
const router = new VueRouter({
    mode: 'hash',
    routes: [
        { path: '/home', component: Home },
        { path: '/about', component: About }
    ]
});
```

### 历史模式（History Mode）

#### 特点

- **URL 格式**：使用正常的 URL 格式，例如 `http://example.com/home`。

- **浏览器支持**：需要现代浏览器支持 HTML5 History API，不支持一些老旧浏览器。

- 需要服务器配置

  ：因为 URL 是正常格式，刷新页面时会向服务器发送请求，需要服务器配置将所有路由指向同一个入口文件（通常是`index.html`）。

#### 工作原理

历史模式利用了 HTML5 的 History API，包括 `pushState`、`replaceState` 和 `popstate` 事件。当 URL 发生变化时，页面不会重新加载，Vue Router 会监听这个变化并更新视图。

```js
const router = new VueRouter({
    mode: 'history',
    routes: [
        { path: '/home', component: Home },
        { path: '/about', component: About }
    ]
});
```

### 对比与选择

- **哈希模式**：
  - 优点：兼容性好，无需服务器配置。
  - 缺点：URL 中包含 `#` 符号，不够美观。
- **历史模式**：
  - 优点：URL 美观，符合常规 URL 格式。
  - 缺点：需要服务器配置，不支持一些老旧浏览器。

### nginx配置

[不同的历史模式 | Vue Router (vuejs.org)](https://router.vuejs.org/zh/guide/essentials/history-mode.html#nginx)

```nginx
location / {
  try_files $uri $uri/ /index.html;
}
```

需要注意的是，无论是 `hash` 模式还是 `history` 模式，都需要在 Vue 的路由配置中进行相应的设置。在 Vue2 中，可以通过 `VueRouter` 的 `mode` 属性来设置路由模式，例如：

```js
const router = new VueRouter({
  mode: 'history',
  routes: [...]
})
```

在 Vue3 中，可以通过 `createRouter` 函数的 `history` 属性来设置路由模式，例如

```js
const router = createRouter({
  history: createWebHistory(),
  routes: [...]
})
```

需要注意的是，在使用 `history` 模式时，需要在服务器端进行相应的配置，以确保路由的正常访问。

这有一个注意事项。你的服务器将不再报告 404 错误，因为现在所有未找到的路径都会显示你的 `index.html` 文件。为了解决这个问题，你应该在你的 Vue 应用程序中实现一个万能的路由来显示 404 页面。

```js
const router = createRouter({
  history: createWebHistory(),
  routes: [{ path: '/:pathMatch(.*)', component: NotFoundComponent }],
})
```

## 20.Vue路由跳转的API

- route.push()
- route.replace()
- route.go() // -1可以回退
- route.back()

## 21.线上项目遇到问题处理

- 后端自动回滚上一个版本

## 22.Vue渐进式的理解

Vue.js 被称为渐进式框架，这意味着你可以根据项目的需求逐步引入 Vue 的功能，而不需要一次性使用所有特性。这种设计使得 Vue 非常灵活，可以适应从简单的单个页面应用到复杂的大型应用的各种需求。

### 渐进式的核心理念

1. **按需引入**：你可以根据需要逐步引入 Vue 的功能。例如，你可以先在一个简单的页面中使用 Vue，然后逐步扩展到整个项目。
2. **易于集成**：Vue 可以很容易地集成到现有项目中，无论是单个页面还是大型应用。
3. **模块化**：Vue 的生态系统是模块化的，你可以根据需要选择使用 Vue Router、Vuex 等库。

### 渐进式的具体表现

#### 1. 单个页面中的 Vue 实例

你可以在一个简单的 HTML 页面中引入 Vue，并创建一个 Vue 实例来管理页面的一部分。这是最基本的使用方式，适合小型项目或渐进式引入 Vue。

#### 2. 组件化开发

随着项目的复杂度增加，你可以开始使用 Vue 的组件系统，将页面拆分为多个可复用的组件。这使得代码更加模块化和可维护。

#### 3. 使用 Vue Router 和 Vuex

对于更复杂的应用，你可以引入 Vue Router 进行路由管理，使用 Vuex 进行状态管理。这些库都是独立的模块，你可以根据需要选择使用。

## 23.git冲突怎么处理

- 冲突后怎么处理
  - 打开冲突文件，查看冲突的部分，找到冲突的原因。
  - 手动修改冲突的部分，保留需要的代码，删除不需要的代码，或者根据需要进行合并。
  - 保存修改后的文件，然后使用 `git add` 命令将修改后的文件添加到暂存区。
  - 使用 `git commit` 命令提交修改，添加一条有意义的提交信息。

- 怎么避免冲突
  - 避免同时修改同一个文件的同一部分，可以在团队协作时分工明确，或者使用分支进行开发，避免多人同时修改同一个文件。
  - 在修改代码之前，先拉取最新的代码，避免修改过时的代码，导致冲突。
  - 在提交代码之前，先使用 `git diff` 命令查看修改的内容，确保没有修改不需要修改的部分。
  - 在提交代码之前，先使用 `git pull` 命令拉取最新的代码，避免其他人已经修改了相同的文件。


## css3新增属性有哪些？

1. `box-shadow`：用于添加元素的阴影效果。
2. `text-shadow`：用于添加文本的阴影效果。
3. `border-radius`：用于设置元素的圆角。
4. `background-size`：用于设置背景图片的大小。
5. `background-clip`：用于设置背景图片的裁剪方式。
6. `background-origin`：用于设置背景图片的起始位置。
7. `background-image`：用于设置元素的背景图片。
8. `transition`：用于设置元素的过渡效果。
9. `transform`：用于设置元素的变换效果，如旋转、缩放、平移等。
10. `animation`：用于设置元素的动画效果。

## 24.CSS3动画的属性

1. `animation-name`：指定动画的名称。
2. `animation-duration`：指定动画的持续时间。
3. `animation-timing-function`：指定动画的时间函数，用于控制动画的速度变化。
4. `animation-delay`：指定动画的延迟时间。
5. `animation-iteration-count`：指定动画的循环次数。
6. `animation-direction`：指定动画的播放方向。
7. `animation-fill-mode`：指定动画结束后元素的样式。
8. `animation-play-state`：指定动画的播放状态，用于控制动画的暂停和继续。



## 25. 手写深拷贝

```js
function deepCopy(obj, hash = new WeakMap()) {
  if (Object(obj) !== obj) return obj; // 基本类型直接返回
  if (hash.has(obj)) return hash.get(obj); // 避免循环引用
  let result;
  if (obj instanceof RegExp) {
    result = new RegExp(obj);
  } else if (obj instanceof Date) {
    result = new Date(obj);
  } else if (obj instanceof Function) {
    result = function () {
      return obj.apply(this, arguments);
    };
  } else if (obj instanceof Object) {
    result = new obj.constructor();//根据constructor创建一个新对象
    hash.set(obj, result);
    for (let key in obj) {
      if (obj.hasOwnProperty(key)) {
        result[key] = deepCopy(obj[key], hash);
      }
    }
  }
  return result;
}
```

## 手写浅拷贝

当我们需要对一个对象进行拷贝时，可以使用浅拷贝来复制对象的属性。浅拷贝只会复制对象的第一层属性，而不会递归地复制对象的子属性。

```Js
function shallowCopy(obj) {
  //如果传入的不是对象或者是null，直接返回
  if (typeof obj !== 'object' || obj === null) {
    return obj;
  }
  //根据对象类型创建新的对象
  const result = Array.isArray(obj) ? [] : {};
  //遍历原对象的属性并将其复制到新对象中。
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      result[key] = obj[key];//只会复制对象的第一层属性
    }
  }
  return result;
}
```

在上面的代码中，我们首先判断传入的参数是否为对象，如果不是对象则直接返回。然后根据对象的类型创建一个新的对象，遍历原对象的属性并将其复制到新对象中，最后返回新对象。

需要注意的是，浅拷贝只会复制对象的第一层属性，如果对象的属性值是一个对象或数组，则只会复制其引用，而不会复制其内容。如果需要递归地复制对象的子属性，可以使用深拷贝函数。

## 简单介绍下发布订阅模式

> 发布订阅模式是一种常用的设计模式，用于解决对象之间的通信问题。在发布订阅模式中，发布者对象和订阅者对象之间通过一个消息队列进行通信。发布者对象将消息发布到消息队列中，订阅者对象从消息队列中订阅消息。
>
> 发布订阅模式中，发布者对象和订阅者对象之间是一对多的关系，一个发布者对象可以有多个订阅者对象，而且订阅者对象之间也可以相互订阅。当发布者对象发布消息时，所有订阅者对象都会收到这个消息，并进行相应的处理。
>
> 发布订阅模式的优点是，可以实现对象之间的松耦合，从而提高系统的可扩展性和可维护性。同时，发布订阅模式也可以实现异步通信，从而提高系统的性能和响应速度。
>
> 需要注意的是，发布订阅模式也有一些缺点，如可能会导致代码的复杂度增加，因为需要考虑消息队列的管理和维护等问题。同时，发布订阅模式也可能会导致系统的可靠性降低，因为消息可能会丢失或重复发送。因此，在使用发布订阅模式时，需要根据具体的业务需求和场景进行权衡和选择。

### 前端的发布订阅模式用在哪？

> 前端的发布订阅模式可以用在以下场景：
>
> 1. **事件系统**：浏览器中的事件系统就是一种发布订阅模式，当事件触发时，所有订阅该事件的回调函数都会被执行。
> 2. **组件通信**：在组件化开发中，可以使用发布订阅模式来实现组件之间的通信，当一个组件的状态发生变化时，可以发布一个事件，其他组件可以订阅该事件并进行相应的处理。
> 3. **模块化开发**：在模块化开发中，可以使用发布订阅模式来实现模块之间的通信，当一个模块的状态发生变化时，可以发布一个事件，其他模块可以订阅该事件并进行相应的处理。
> 4. **异步编程**：在异步编程中，可以使用发布订阅模式来实现异步任务的回调函数管理，当异步任务完成时，可以发布一个事件，所有订阅该事件的回调函数都会被执行。

### 手写发布订阅模式

```js
class EventEmitter {
  constructor() {
    this.events = {};
  }

  on(eventName, listener) {
    if (!this.events[eventName]) {
      this.events[eventName] = [];
    }
    this.events[eventName].push(listener);
  }

  emit(eventName, ...args) {
    if (this.events[eventName]) {
      this.events[eventName].forEach(listener => {
        listener.apply(this, args);
      });
    }
  }

  off(eventName, listener) {
    if (this.events[eventName]) {
      this.events[eventName] = this.events[eventName].filter(l => l !== listener);
    }
  }
}

// 使用示例
const eventEmitter = new EventEmitter();

// 订阅事件
eventEmitter.on('click', () => {
  console.log('click event triggered');
});

// 发布事件
eventEmitter.emit('click');

// 取消订阅事件
const listener = () => {
  console.log('custom listener');
};
eventEmitter.on('custom', listener);
eventEmitter.off('custom', listener);
```

## 说说你对“高内聚，低耦合"的理解

“高内聚，低耦合”是一种软件设计原则，它的核心思想是将系统分解成多个独立的模块，每个模块都应该具有高内聚性和低耦合性。

高内聚性指的是模块内部的各个元素之间紧密相关，共同完成一个特定的功能。一个具有高内聚性的模块应该尽可能地将相关的元素放在一起，以便于维护和修改。例如，在一个负责处理用户登录的模块中，应该只包含与用户登录相关的代码，而不应该包含其他无关的代码。

低耦合性指的是模块之间的依赖关系尽可能地少，每个模块都应该尽可能地独立。一个具有低耦合性的模块应该只依赖于必要的其他模块，而不应该依赖于不必要的模块。例如，在一个负责处理用户登录的模块中，应该只依赖于与用户登录相关的模块，而不应该依赖于其他无关的模块。

**高内聚和低耦合是相辅相成的，它们可以互相促进**。如果一个模块具有高内聚性，那么它的各个元素之间紧密相关，共同完成一个特定的功能，这样可以减少模块之间的依赖关系，从而实现低耦合性。如果一个模块具有低耦合性，那么它的依赖关系尽可能地少，每个模块都应该尽可能地独立，这样可以使模块更加易于理解、修改和维护，从而实现高内聚性。

在软件设计和开发过程中，遵循“高内聚，低耦合”原则可以提高软件系统的可维护性、可扩展性和可重用性。同时，也可以使系统更加灵活、可靠和易于维护。

### 在vue组件的设计上，怎么应用高内聚和低耦合的理念？

在 Vue 组件的设计中，可以通过以下方式应用高内聚和低耦合的理念：使用插槽可以使组件更加灵活和可配置

属性和数据传递：通过属性的方式进行、功能设计：尽量只实现一个功能、避免在组件内部调用其他组件的方法，而是通过事件的方式通信；组件拆分：复杂组件拆分成多个子组件，每个子组件实现一个功能。插槽和作用域插槽

1. **属性和数据传递**：组件之间的数据传递应该尽量通过属性的方式进行，而不是直接访问其他组件的数据。同时，应该尽量避免使用全局变量和单例模式等方式共享数据，以降低组件之间的耦合度。
2. **功能设计**：组件应该尽量只实现一个功能，而不是将多个功能混合在一起。这样可以提高组件的内聚性，使其更加独立和可重用。同时，应该尽量避免在组件内部直接调用其他组件的方法，而是通过事件的方式进行通信。
3. **组件拆分**：对于复杂的组件，可以将其拆分成多个子组件，每个子组件只实现一个功能。这样可以提高组件的内聚性和可重用性，同时也可以降低组件之间的耦合度。
4. **插槽和作用域插槽**：使用插槽和作用域插槽可以使组件更加灵活和可配置，同时也可以降低组件之间的耦合度。通过插槽和作用域插槽，可以将组件的样式和行为与具体的数据分离开来，使其更加独立和可重用。

总之，在 Vue 组件的设计中，应该尽量追求高内聚和低耦合的平衡，既要保证组件内部的紧密联系，又要保证组件之间的松散耦合。这样可以提高组件的可维护性、可扩展性和可重用性。

## vue3面试题

1. Vue3 与 Vue2 有哪些不同之处？
2. Vue3 中的 Composition API 是什么？它有什么优点？
3. Vue3 中的数据双向绑定是如何实现的？
4. Vue3 中的响应式系统是如何工作的？
5. Vue3 中的 Teleport 组件是什么？它有什么作用？
6. Vue3 中的 Suspense 组件是什么？它有什么作用？
7. Vue3 中的 Fragments 是什么？它有什么作用？
8. Vue3 中的 v-model 指令与 Vue2 有何不同？
9. Vue3 中的 setup 函数是什么？它有什么作用？
10. Vue3 中的 provide 和 inject API 是什么？它们有什么作用？

1. 什么是闭包？它有什么作用？
2. 什么是原型链？它有什么作用？
3. 什么是事件冒泡和事件捕获？它们有什么区别？
4. 什么是跨域？如何解决跨域问题？
5. 什么是异步编程？如何实现异步编程？
6. 什么是 Promise？它有什么作用？
7. 什么是 async/await？它们有什么作用？
8. 什么是 MVC、MVP 和 MVVM？它们有什么区别？
9. 什么是单向数据流？它有什么作用？
10. 什么是 Virtual DOM？它有什么作用？

## 面试自我介绍

大家好，我是 [你的名字]，很高兴来参加这次面试。我是一名前端工程师，有 [你的工作经验] 年的前端开发经验。我熟练掌握 HTML、CSS 和 JavaScript，并且熟悉常用的前端框架和库，如 Vue、React、jQuery 等。

在我的工作中，我主要负责 [你的工作职责]，并且积累了一定的项目经验。我喜欢学习新技术和解决问题，对前端开发有着浓厚的兴趣。我也喜欢和团队成员合作，共同完成项目并取得成功。

除了技术方面，我还注重自己的软实力，如沟通能力、团队协作能力和学习能力等。我相信这些能力对于一个前端工程师来说同样重要。

感谢您的时间，我期待能够加入贵公司并为其做出贡献。谢谢！

## 为什么从上一家离职？

请根据你的实际情况进行调整：

1. **寻求更大的挑战**：你可以说你在上一家公司已经达到了一个平台期，你希望在新的环境中寻找更大的挑战和学习新的技能。
2. **职业发展**：你可以说你希望找一个更符合你职业发展规划的位置，或者你希望在某个特定领域（例如前端开发）有更深入的发展。
3. 公司文化：如果你觉得上一家公司的文化不适合你，你可以说你在寻找一个更符合你价值观的公司。
4. 工作/生活平衡：如果你离职的原因是工作时间太长或者工作压力太大，你可以说你在寻找一个能够更好地平衡工作和生活的工作。
5. 避免负面评论：尽管你可能对上一家公司有不满，但在面试中发表负面评论通常不是一个好主意。你应该尽量以积极的方式表述你的离职原因。

记住，每个人的情况都是独特的，所以你应该根据你的实际情况来回答这个问题。

## 你上一家的薪资是多少？

关于上一家公司的薪资，我认为这并不是一个很好的参考，因为每个公司的薪资结构和福利待遇都不同。我更希望能够根据我的技能和经验来确定薪资水平。

## 你的期望薪资是多少？

关于期望薪资，我希望能够得到一个公平合理的薪资待遇，同时也考虑到公司的薪资结构和市场行情。我相信在我们进一步了解彼此之后，我们可以达成一个满意的协议。

> 需要注意的是，面试中的薪资问题可能比较敏感，你可以尽量避免直接回答具体的数字，而是强调你更关注于公平合理的薪资待遇，并且愿意在双方了解清楚情况后进行商讨。

## 说说你的优点和缺点

关于我的**优点**，我认为我有以下几个方面的优势：

1. [优点1]：例如，我有很强的学习能力和自我驱动力，能够快速适应新的技术和工作环境。
2. [优点2]：例如，我注重细节和质量，能够保证工作的准确性和高效性。
3. [优点3]：例如，我善于沟通和协作，能够与团队成员和客户保持良好的关系。

关于我的**缺点**，我也意识到自己有一些需要改进的地方：

1. [缺点1]：例如，我有时候会过于追求完美，导致工作进度有些缓慢。
2. [缺点2]：例如，我有时候会过于紧张和焦虑，需要更好地控制情绪。
3. [缺点3]：例如，我有时候会过于独立思考，需要更好地倾听他人的意见和建议。

需要注意的是，回答这个问题时，要注意**突出自己的优点**，同时也要坦诚地承认自己的缺点，并且表现出改进的意愿。同时，也要注意不要说出过于严重或者与工作无关的缺点，以免给 HR 留下不好的印象。

## 开放性问题

1. **你在前端项目中遇到最大的难题是什么，你是怎么解决的？**

   1. 后台页面中很多涉及到表单提交和表单展示，涉及到常用的一些表单控件，比如input输入框、下拉选择、日期选择等，页面做起来需要写的标签很多都是重复的，而且表单内容一旦多了，标签代码写起来就很多且很容易乱，这些重复的代码严重降低了开发效率，所以我针对这个情况封装了**配置式表单组件**，就是在JS中定义需要渲染的表单组件列表，每个组件用一个对象进行描述，比如组件的类型`type:'input'`，`label`,`name`,`rules`，等属性，组件内部自动会生成校验规则，数据双向绑定等。

      最后组件做完后，还遇到一个代码提示的问题，想要的效果是参照antd Vue组件，在鼠标放到组件属性上会显示可选值，在输入属性后也会有可选的代码提示。本来以为这个功能只要用ts定义了属性接口就能自动会有提示，但是实际发现并不行。为了实现这个代码提示功能，我去翻了好几遍的antd Vue的组件源码，终于发现了一些蛛丝马迹：原来vue提供了一个定义组件的ts泛型：**`DefineComponent`**，如果要实现属性的代码提示，就要在第11个参数写入组件的props定义。

   2. 项目最初是使用Vite2.6版本，这个Vite在开发环境的项目启动是很快，但是在开发环境下页面切换时需要几秒钟甚至10秒的时间，原因是因为使用了import动态导入组件，当页面切换时浏览器会请求这个组件，等待组件加载完后才会页面切换成功。这个等待的过程过长导致开发体验很不好，针对这个问题，我编写了一个**页面预加载的Vite插件**，这个插件的主要功能是解析在使用import 引入组件时加了`proload`关键字的组件，会添加到预加载队列，在项目首次启动时，会提前把这些组件加载，等用户切换页面时如果这个组件加载过，浏览器就会使用缓存加载，只需要十几毫秒，页面加载的速度也就实现秒加载了。
   3. **实现多账号管理功能**。需求是这样的：需要在客户端中同时登录和管理某个平台的多个账号，正常的浏览器登录一个网站后，再打开多个页面，都是同一个登录的用户。但是这个需求要求可以同时登录多个账号，刚开始听着这个需求挺难实现的，后面我就到处搜相关的文档和文章，也有在知乎、掘金上咨询过别人，最终总结出有两种方法可以实现，第一种是使用electron的新建BrowserView，但是这个方法会有层级问题，而且比较笨重，最终选了第二种，使用`webview`标签，每个标签加载一个网页，同时我翻阅了官方文档，找到了可以对webview进行环境隔离的方法，结合之前调研的平台都是使用cookies保存登录用户信息的，最终实现了webview之间cookies独立管理，这样每个页面相当于一个独立的浏览器，自然可以登录不同账户，实现多账号管理的功能了。

2. **你在前端开发中遵循哪些最佳实践和规范？你是如何确保代码的质量和可维护性的？**

   1. 使用模块化的开发方式，将代码分解为小的、可重用的模块，方便维护和测试。
   2. 遵循单一职责原则，确保每个组件和函数只负责一项功能，避免代码耦合和混乱。
   3. 使用代码格式化工具和代码风格规范，确保代码的一致性和可读性。
   4. 使用版本控制工具，如 Git，管理代码的版本和变更历史，方便团队协作和代码回滚。
   5. 使用代码分析工具，如 ESLint 或 TSLint，检查代码的质量和规范性，避免常见的错误和漏洞。

3. **你在前端开发中遇到过哪些性能问题？你是如何优化的？**

   在前端开发中，我遇到过的一个性能问题是页面加载速度过慢。当页面中包含大量的图片、视频或者其他资源时，会导致页面加载时间过长，影响用户的体验。

   为了解决这个问题，我采取了以下优化措施：

   1. 压缩和优化图片、视频等资源，减小文件大小，提高加载速度。
   2. 使用懒加载技术，将页面中的图片、视频等资源延迟加载，减少页面的初始加载时间。
   3. 使用 CDN 加速服务，将静态资源缓存到 CDN 中，提高资源的访问速度。
   4. 使用浏览器缓存，将静态资源缓存到浏览器中，减少重复加载的次数。

## 移动端适配问题你是怎么处理的?

在移动端适配方面，我采用了以下方法：

1. 使用flex弹性盒子布局。
2. 使用 rem 或者 vw/vh 等单位，避免使用固定的像素值。

3. 使用响应式布局，根据不同的屏幕尺寸和设备类型，自适应调整页面的布局和样式。
4. 使用 viewport 和媒体查询等技术，适配不同的屏幕尺寸和设备像素密度，确保页面在不同设备上的显示效果一致。

## rem + vh适配方案

> 参考资料：https://blog.csdn.net/zshake/article/details/111385716
>
> [大厂是怎么做移动端适配的](https://mp.weixin.qq.com/s/Pzm1ZM6jgJEcGwWVVRYuIg)
>
> [为什么说移动端该放弃rem适配方案了？](https://www.toutiao.com/article/7251157789862052408/?app=news_article&timestamp=1688384209&use_new_style=1&req_id=202307031936482B508CC45213B2271A33&group_id=7251157789862052408&wxshare_count=1&tt_from=weixin&utm_source=weixin&utm_medium=toutiao_android&utm_campaign=client_share&share_token=9f34c445-065b-432e-8759-b7fc3bb5e0b2&source=m_redirect&wid=1688440029944)
>
> [移动端适配(转载) - 掘金 (juejin.cn)](https://juejin.cn/post/7248249730479456313)

第一步：元素大小单位选用rem。

第二步：根据设计稿的屏幕宽度设置html的font-size大小，且单位用vw。

第三步：通过media query设置html根font-size的最大最小px值。

**例**：假设设计稿是1200px的屏幕，第一二步的效果将是：

1200px宽度的屏幕，html的font-size设为1vw，p标签设为1rem，则为***12px\***实际大小；

1800px宽度的屏幕，html的font-size设为1vw，p标签设为1rem，则为***18px***实际大小；

如果IPhone6屏幕宽度是**375px**(独立像素)，p标签1rem的话，实际大小就只有3.75px了。虽然谷歌浏览器做了最小字号限制（12px)

下面开始根据设计稿进行代码适配：

1. **px与vw换算**:  因为设计稿是**750px**，IPhone6是2DPR，独立像素只有一半：**375px**，把html的font-size设为1vw，得到1rem = 3.75px，把浏览器最小字号12px进行比较得出: **12 / 3.75 = 3.2vw**，也就是说在最小字号情况下:**12px = 3.2vw**

2. **与设计稿的字号进行放大换算vw** : 查看设计稿中普通文字字号是多少，比如设计稿上大部分文字都是用20px，那么就以20px为基准。用20px和最小字号12px对比，看放大的倍数是多少：20/12 = 1.66666667

3. 用放大的倍数 1.666667 * 3.2 = 5.3333333vw

> 以上就是我分析京东移动端得出的分析计算过程

```css
html {
    font-size: 20px;
    font-size: 5.33333vw
}

@media screen and (max-width: 320px) {
    html {
        font-size:17.06667px
    }
}

@media screen and (min-width: 540px) {
    html {
        font-size:28.8px
    }
}

 @media screen and (min-width: 1080px) {
    html {
        font-size:57.6px
    }
}
```



## 手写防抖函数

```js
const Debounce = (fn, delay = 300) => {
  let timer = null // 存储唯一setTimeout状态
  return args => {
    const self = this // 事件源this
    clearTimeout(timer) 
      timer = setTimeout(() => {
        fn.apply(self, [args])
      }, delay)
  }
}

export default Debounce
```

使用方法：

```js
function handleInput() {
  console.log('输入事件被触发');
}

const debouncedInput = debounce(handleInput, 300);

document.getElementById('inputField').addEventListener('input', debouncedInput);
```

## 手写节流函数

```js
let timer, flag;
/**
 * 节流原理：在一定时间内，只能触发一次
 * 
 * @param {Function} func 要执行的回调函数 
 * @param {Number} delay 延时的时间
 * @return function
 */
function throttle(func, delay) {
  let isThrottled = false;
  
  return function() {
    const context = this;
    const args = arguments;
    
    if (!isThrottled) {
      func.apply(context, args);
      isThrottled = true;
      
      setTimeout(function() {
        isThrottled = false;
      }, delay);
    }
  }
}

```

使用示例：

```js
function handleScroll() {
  console.log('滚动事件被触发');
}

const throttledScroll = throttle(handleScroll, 300);

window.addEventListener('scroll', throttledScroll);

```

## 谈谈你对闭包的理解

![image-20230627020236671](https://s2.loli.net/2023/06/27/zswl1UkPbxNEfD5.png)

闭包是指函数内部的一个函数可以访问到外部函数的变量和参数，即使外部函数已经执行完毕。闭包形成了一个包含函数和其引用环境的闭包（closure）。

闭包的特点和作用如下：

1. 保护变量：闭包可以创建私有变量，在外部无法访问。这样可以避免全局变量污染和命名冲突。
2. 延长变量的生命周期：当外部函数执行完毕后，其内部函数仍然可以访问外部函数的变量。这样可以实现在外部函数执行完毕后，仍然可以操作外部函数的变量。
3. 实现模块化：闭包可以创建私有方法和属性，模拟类和对象的概念，实现封装和继承等面向对象的特性。
4. 在异步编程中的应用：通过闭包可以保存异步操作过程中的上下文信息，避免回调函数丢失上下文。
5. 优化性能：闭包可以避免重复创建函数，提高代码的执行效率。

需要注意的是，闭包会占用内存，如果闭包过多或者闭包中包含大量的变量和对象，则可能会导致内存泄漏。因此，在使用闭包时，需要注意及时释放不再使用的闭包，避免造成性能问题。

> 答案二：
> 		闭包是指一个函数可以访问并操作其外部函数作用域中的变量，即使外部函数已经返回并且其作用域已经销毁。闭包可以用于创建私有变量和方法，以及实现模块化的代码结构。在JavaScript中，每个函数都是一个闭包，因为它们都可以访问其外部作用域中的变量。闭包的使用需要注意内存泄漏的问题，因为闭包会一直持有其外部作用域中的变量，导致这些变量无法被垃圾回收。

> 答案三：
>
> 闭包是指在一个函数内部定义的函数，可以访问该函数的局部变量和参数，即使该函数已经返回，闭包仍然可以访问这些变量和参数。闭包可以用来实现数据的私有化、函数的柯里化、模块化等功能。
>
> 在 JavaScript 中，每个函数都是一个闭包，因为它们都可以访问自己的局部变量和参数。当一个函数返回时，它的局部变量和参数通常会被销毁，但是如果该函数返回了一个内部函数，那么这个内部函数就可以访问该函数的局部变量和参数，形成了一个闭包。
>
> 闭包的作用域链是由内向外查找的，即先在自己的作用域中查找变量，如果没有找到，就会向上一级作用域中查找，直到找到为止。因此，闭包可以访问外部函数的变量和参数，但是外部函数不能访问内部函数的变量和参数。
>
> 需要注意的是，闭包会占用内存，因为它会保留外部函数的作用域链，如果闭包过多或者不合理使用，会导致内存泄漏和性能问题。因此，在使用闭包时，需要注意内存管理和性能优化。

## 闭包的应用-函数柯里化

> 函数柯里化是指将一个接受多个参数的函数转化为一系列只接受单个参数的函数的过程。柯里化可以使函数更加灵活和可复用，可以用来实现函数的复合、延迟执行等功能。
>
> 在 JavaScript 中，函数柯里化通常使用闭包来实现。具体来说，柯里化函数会返回一个新的函数，这个新函数会接受第一个参数，并返回一个新的函数，这个新函数会接受第二个参数，以此类推，直到所有参数都被接受完毕，最后返回最终的结果。

### 参数复用

下面是一个简单的柯里化示例，实现了一个加法函数的柯里化：

```js
function add(x) {
  return function(y) { 
    return x + y;
  };
}

// 使用柯里化的加法函数
const add5 = add(5);
console.log(add5(3)); // 输出 8
console.log(add5(7)); // 输出 12
```

在上面的示例中，我们定义了一个 `add` 函数，它接受一个参数 `x`，返回一个函数，这个函数接受一个参数 `y`，返回 `x + y` 的结果。然后，我们使用 `add(5)` 得到一个新的函数 `add5`，它只需要一个参数 `y`，返回 `5 + y` 的结果。这样，我们就可以通过 `add5` 来实现多次加 5 的操作。

需要注意的是，柯里化可以使函数更加灵活和可复用，但是也会增加代码的复杂度和理解难度。因此，在使用柯里化时，需要根据实际情况来决定是否使用，避免过度使用导致代码难以维护。

### 防抖

```js
function debounce(fn, delay) {
  let timer = null;
  return function(...args) {
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}

function handleClick() {
  console.log('click');
}

const debounceClick = debounce(handleClick, 1000);
document.addEventListener('click', debounceClick);
```

### 函数复合

```js
function compose(...fns) {
  return function(x) {
    return fns.reduceRight((acc, fn) => {
      return fn(acc);
    }, x);
  };
}

function add1(x) {
  return x + 1;
}

function double(x) {
  return x * 2;
}

const add1AndDouble = compose(double, add1);
console.log(add1AndDouble(5)); // 输出 12
```

在上面的示例中，我们定义了一个 `compose` 函数，它接受多个函数，返回一个新的函数，这个新函数会将多个函数组合起来，形成一个函数管道。然后，我们定义了两个函数 `add1` 和 `double`，分别实现加 1 和乘 2 的功能。最后，我们使用 `compose` 函数将 `add1` 和 `double` 函数组合成一个新的函数 `add1AndDouble`，它会先将输入加 1，再将结果乘 2，最终返回结果。

## TypeScript面试题

1. TypeScript是什么？它和JavaScript有什么区别？

   > TypeScript是一种开源的编程语言，它是JavaScript的超集，通过添加静态类型检查等功能来增强JavaScript。与JavaScript相比，TypeScript具有更严格的类型系统、更好的IDE支持和更多的工具。

2. 在TypeScript中，什么是类型注解？

   > 类型注解是在变量、函数参数、函数返回值等位置给出类型信息的一种方式。通过类型注解，可以明确指定变量的类型，从而提高代码的可读性和安全性。

3. TypeScript中的接口（interface）和抽象类（abstract class）有什么区别？

   > 接口是一种约束对象结构的方式，它定义了对象应该包含的属性和方法。抽象类是一种抽象的类，它可以包含抽象方法和具体方法。一个类可以实现多个接口，但只能继承一个抽象类。

4. 什么是泛型（Generics）？它在TypeScript中的作用是什么？

   > 泛型是一种在定义函数、类或接口时使用类型变量的方式。它可以增加代码的可重用性和灵活性，使代码可以处理多种类型的数据。

5. 请解释TypeScript中的模块（module）和命名空间（namespace）的概念。

   > 模块是一种组织和封装代码的方式，它可以将相关的代码和类型定义放在一起。命名空间是一种防止全局命名冲突的方式，它将相关的代码封装在一个独立的命名空间中。

6. TypeScript中的装饰器（decorators）是什么？它有什么作用？

   > 装饰器是一种特殊类型的声明，它可以附加到类声明、方法、属性或参数上，用于修改它们的行为。装饰器可以用于实现元编程和实现一些横切关注点，例如日志记录和性能监控。

7. 请解释TypeScript中的声明文件（declaration files）是什么，如何使用它们？

   > 声明文件是一种描述JavaScript库或模块的类型信息的文件，它用于在TypeScript中使用这些库或模块时进行类型检查和代码提示。声明文件的文件名通常以".d.ts"为后缀，可以手动编写或通过工具自动生成。

8. 什么是类型推断（type inference）？在什么情况下可以使用类型推断？

   > 类型推断是TypeScript编译器根据上下文推断出变量或表达式的类型的过程。在没有明确指定类型的情况下，编译器会根据赋值的表达式或函数返回值的类型推断出变量的类型。

9. TypeScript中的可选属性（optional property）和只读属性（readonly property）有什么区别？

   > 可选属性是指在接口或类型中定义的属性，可以有或没有。只读属性是指只能在对象初始化或构造函数中设置值的属性，之后不能修改。

10. 如何在TypeScript中定义一个枚举（enum）类型？

    > 枚举是一种有限集合的值的数据类型。在TypeScript中，可以使用关键字"enum"来定义枚举类型，并通过枚举成员来表示具体的值。

11. TypeScript中的命名空间（namespace）如何使用和组织代码？

    > 命名空间是一种将相关的代码组织在一起的方式，它可以避免全局命名冲突。可以使用"namespace"关键字定义命名空间，在命名空间中可以定义类、函数、变量等。

12. 请解释TypeScript中的交叉类型（intersection types）和联合类型（union types）。

    > 交叉类型表示同时具备多种类型的值，可以使用"&"运算符进行类型合并。联合类型表示一个值可以是多种类型之一，可以使用"|"运算符进行类型合并。

13. 什么是类型保护（type guards）？在什么情况下可以使用类型保护？

    > 类型保护是一种在特定条件下判断变量的类型的方式，以便在代码中使用该类型的特定功能。可以使用"typeof"、"instanceof"、"in"等方式进行类型保护。

14. TypeScript中的异步编程如何处理？请解释async/await的使用。

    > TypeScript中的异步编程可以使用Promise、async/await等方式处理。async/await是一种基于Promise的语法糖，可以使异步代码的编写和理解更加简洁。

15. 请解释TypeScript中的声明合并（declaration merging）是什么，如何使用它？

    > 声明合并是指当声明多个相同名字的接口、函数或类时，它们会合并为一个声明。这种合并可以用于扩展现有的类型定义，或者将多个声明组合成一个更完整的声明。

# 公司1笔试题

## x.y.z版本新旧对比

有一个函数`compareVersion(newV,oldV)`，传入新旧两个版本号进行对比，返回新的版本号，版本号格式固定为：x.y.z。

```js
function compareVersion(newV, oldV) {
  const newVersion = newV.split('.').map(Number);
  const oldVersion = oldV.split('.').map(Number);
  for (let i = 0; i < 3; i++) {
    if (newVersion[i] > oldVersion[i]) {
      return newV;
    } else if (newVersion[i] < oldVersion[i]) {
      return oldV;
    }
  }
  return newV;
}
compareVersion('1.2.3', '1.2.4')
```

> 由于 `map()` 方法会对数组中的每个元素都执行一次回调函数，因此我们可以直接将 `Number` 函数作为回调函数传入 `map()` 方法中，这样可以更加简洁和方便。因此，我们可以使用 `map(Number)` 来将字符串类型的版本号数组转化为数字类型的版本号数组。
>
> - 只判断大于或小于的情况，相等时不作判断，默认返回newV

## this指向相关问题

建议把下面每一道题都运行看一遍

```js
var myname = 'lili'
const obj = {
  myname: 'Alice',
  sayName() {
    myname = 'Bob';
    console.log(this.myname);
  }
};
const sayName = obj.sayName;
console.log(myname);//lili
sayName(); // Bob
```

```js
var myname = 'lili'
const obj = {
  myname: 'Alice',
  sayName() {
    console.log(this.myname);
  }
};
const sayName = obj.sayName;
sayName(); // lili
obj.sayName(); // Alice
```

```js
var myname = 'lili'
const obj = {
  name: 'Alice',
  sayName() {
    console.log(this.name);
  }
};
const sayName = obj.sayName;
console.log(window.myname); // lili
sayName(); // undefined 空
```

```js
const obj = {
  name: 'Alice',
  sayName() {
    console.log(this.name);
  }
};
const sayName = obj.sayName.bind(obj);
sayName(); // Alice
```

```js
const obj1 = {
  name: 'Alice',
  sayName() {
    console.log(this.name);
  }
};
const obj2 = {
  name: 'Bob'
};
obj1.sayName.call(obj2);// Bob
```

难度升级：

```js
const obj = {
  name: 'Alice',
  friends: ['Bob', 'Charlie'],
  sayName() {
    console.log(this.name);
  },
  sayFriends() {
    this.friends.forEach(function(friend) {
      console.log(this.name + ' knows ' + friend);
    });
  }
};
obj.sayFriends();// undefined knows Bob undefined knows Charlie
```

> 输出的结果是 `undefined knows Bob` 和 `undefined knows Charlie`。这是因为在 `sayFriends()` 方法中，我们使用了一个匿名函数作为 `forEach()` 方法的回调函数，而这个匿名函数中的 `this` 指向了全局对象（在浏览器中是 `window` 对象，在 Node.js 中是 `global` 对象），因此在输出字符串时，`this.name` 的值为 `undefined`。为了解决这个问题，我们可以使用箭头函数来替代匿名函数，因为箭头函数中的 `this` 指向的是定义时所在的对象，而不是运行时所在的对象。因此，我们可以将 `sayFriends()` 方法中的匿名函数改写为箭头函数，这样在输出字符串时，`this.name` 的值就会指向 `obj` 对象的 `name` 属性，输出的结果就是我们期望的结果。

变形题：

```js
const obj = {
  name: 'Alice',
  friends: ['Bob', 'Charlie'],
  sayName() {
    console.log(this.name);
  },
  sayFriends() {
    this.friends.forEach(function(friend) {
      console.log(this.name + ' knows ' + friend);
    }.bind(this));
  }
};
obj.sayFriends(); // Alice knows Bob Alice knows Charlie
```

难度继续升级：

```js
var myname = 'lili'
function Person(name) {
  this.myname = name;
  this.sayName = function() {
    console.log(this.myname);
  };
}
const person1 = new Person('Alice');
const person2 = Person('Bob');
console.log(myname);// Bob
person1.sayName();// Alice
```

> 在创建 `person1` 对象时，我们使用了 `new` 关键字，这样 `Person` 构造函数中的 `this` 指向了新创建的对象，因此在调用 `sayName()` 方法时，函数内部的 `this` 指向了 `person1` 对象，输出了 `Alice`。
>
> 而在运行`Person('Bob')`时，Person内部的this指向全局，也就是window，同时函数外部一开始就定义了`var myname = 'lili'`，这个属性会挂载在window上，所以`this.myname= name`会把window上的`myname`覆盖，得出`console.log(myname) -> Bob`。

# 关于数据结构的问题

1. 什么是数组？

数组是一种数据结构，用于存储一组有序的数据。数组中的每个元素都有一个唯一的索引，可以通过索引来访问数组中的元素。数组可以存储任何类型的数据，包括数字、字符串、对象等。

2. 什么是栈？

栈是一种数据结构，它具有后进先出（LIFO）的特点。栈可以用数组或链表来实现，它支持两个基本操作：压入（push）和弹出（pop）。压入操作将一个元素添加到栈的顶部，弹出操作将栈顶的元素移除并返回。

3. 什么是队列？

队列是一种数据结构，它具有先进先出（FIFO）的特点。队列可以用数组或链表来实现，它支持两个基本操作：入队（enqueue）和出队（dequeue）。入队操作将一个元素添加到队列的尾部，出队操作将队列头部的元素移除并返回。

4. 什么是链表？

链表是一种数据结构，它由一系列节点组成，每个节点包含一个数据元素和一个指向下一个节点的指针。链表可以用来实现栈和队列等数据结构，它支持插入和删除操作的时间复杂度为 O(1)。

5. 什么是哈希表？

哈希表是一种数据结构，它通过哈希函数将键映射到值。哈希表可以用数组来实现，它支持常数时间的插入、删除和查找操作。哈希表的性能取决于哈希函数的质量和数组的大小，通常需要进行调整以避免哈希冲突。

# H5是指什么？

H5 是 HTML5 的简称，是 HTML 的第五个版本。HTML5 是一种用于构建 Web 内容的标准，包括 HTML、CSS 和 JavaScript 等技术。HTML5 的出现使得 Web 应用程序可以更加丰富和交互，同时也提高了 Web 应用程序的性能和可访问性。

HTML5 引入了许多新的特性和 API，包括**语义化标签、音视频标签、Canvas、Web Storage、Web Workers、Web Sockets** 等。这些新特性和 API 使得开发者可以更加方便地构建 Web 应用程序，同时也提高了 Web 应用程序的性能和可访问性。

需要注意的是，HTML5 并不是一个完整的技术栈，而是一个**包含多种技术的标准**。除了 HTML、CSS 和 JavaScript 之外，**HTML5 还包括 SVG、WebGL、WebRTC、Web Components 等技术**。这些技术共同构成了 HTML5 技术栈，使得 Web 应用程序可以更加丰富和交互。

# 如何实现Promise

实现一个基本的 Promise 需要考虑到 Promise 的三种状态（pending、fulfilled、rejected）以及状态转换，同时还需要实现 `then` 和 `catch` 方法。以下是一个简单的 Promise 实现：

```js
class MyPromise {
  constructor(executor) {
    this.status = 'pending'; // 初始状态
    this.value = undefined; // fulfilled 状态时 返回的信息
    this.reason = undefined; // rejected 状态时 拒绝的原因
    this.onResolvedCallbacks = []; // 存储 fulfilled 状态对应的 onFulfilled 函数
    this.onRejectedCallbacks = []; // 存储 rejected 状态对应的 onRejected 函数

    // value 是 fulfilled 状态时接收的终值
    const resolve = (value) => {
      if (this.status === 'pending') {
        this.status = 'fulfilled';
        this.value = value;
        this.onResolvedCallbacks.forEach(fn => fn(this.value));
      }
    };

    // reason 是 rejected 状态时接收的原因
    const reject = (reason) => {
      if (this.status === 'pending') {
        this.status = 'rejected';
        this.reason = reason;
        this.onRejectedCallbacks.forEach(fn => fn(this.reason));
      }
    };

    // 捕获在 executor 执行器中抛出的异常
    try {
      // 立即执行 executor
      executor(resolve, reject);
    } catch (e) {
      // 如果有错误，就直接执行 reject
      reject(e);
    }
  }

  // 包含一个参数 reason，且必须总是返回一个 promise
  catch(onRejected) {
    return this.then(null, onRejected);
  }

  // 包含两个参数 onFulfilled 和 onRejected，它们都是可选的
  // 如果 onFulfilled 或 onRejected 不是函数，其必须被忽略
  // 如果 onFulfilled 是函数，它必须在 promise fulfilled 后被调用，第一个参数为 promise 的值
  // 如果 onRejected 是函数，它必须在 promise rejected 后被调用，第一个参数为 promise 的原因
  then(onFulfilled, onRejected) {
    if (this.status === 'fulfilled') {
      if (typeof onFulfilled === 'function') {
        onFulfilled(this.value);
      }
    }
    if (this.status === 'rejected') {
      if (typeof onRejected === 'function') {
        onRejected(this.reason);
      }
    }
    if (this.status === 'pending') {
      if (typeof onFulfilled === 'function') {
        this.onResolvedCallbacks.push(onFulfilled);
      }
      if (typeof onRejected === 'function') {
        this.onRejectedCallbacks.push(onRejected);
      }
    }
  }
}
```

这个简单的 Promise 实现只包含了 Promise 的基本功能。在实际的 Promise 中，还包含了很多其他的功能，例如错误处理、链式调用等。如果你想要一个完整的 Promise 实现，你可能需要查看 Promise 的 polyfill。

## 实例方法finally

`finally` 是 Promise 的一个实例方法，不论 Promise 对象最后状态如何，都会执行的操作。它的回调函数不接受任何参数，意味着无法知道前面的 Promise 结果。

以下是 `finally` 方法的简单实现：

```js
class MyPromise {
  // ... 其他代码

  finally(callback) {
    return this.then(
      value => MyPromise.resolve(callback()).then(() => value),
      reason => MyPromise.resolve(callback()).then(() => { throw reason })
    );
  }
}
```

在这个实现中，无论 Promise 的状态是 fulfilled 还是 rejected，我们都会调用 `callback` 函数，并等待它完成。如果 Promise 的状态是 fulfilled，我们会返回原始的值；如果 Promise 的状态是 rejected，我们会抛出原始的原因。

注意，我们使用 `MyPromise.resolve(callback()).then(...)` 来确保 `callback` 函数返回的值是一个 Promise。如果 `callback` 函数返回的不是一个 Promise，`MyPromise.resolve` 会将它转换为一个 Promise。

## Promise.all实现

`Promise.all` 是一个静态方法，接收一个 Promise 实例的数组作为参数，包装成一个新的 Promise 实例。只有所有的 Promise 实例状态都变成 fulfilled，新的 Promise 实例的状态才会变成 fulfilled；只要其中有一个被 rejected，新的 Promise 实例的状态就变成 rejected。

以下是一个简单的 `Promise.all` 的实现：

```js
class MyPromise {
  // ... 其他代码

  static all(promiseArr) {
    let result = [];
    let count = 0;

    return new MyPromise((resolve, reject) => {
      promiseArr.forEach((p, i) => {
        MyPromise.resolve(p).then(
          val => {
            count++;
            result[i] = val;
            if (count === promiseArr.length) {
              resolve(result);
            }
          },
          err => {
            reject(err);
          }
        );
      });
    });
  }
}
```

在这个实现中，我们首先创建一个空的结果数组 `result` 和一个计数器 `count`。然后，我们遍历 `promiseArr`，对每个 Promise 调用 `MyPromise.resolve` 方法，然后在 `then` 方法中处理结果。

如果 Promise 成功，我们将结果添加到 `result` 数组中，并增加 `count`。如果 `count` 等于 `promiseArr` 的长度，这意味着所有的 Promise 都成功了，我们就可以解决整个 `Promise.all`。

## Promise.resolve & Promise.reject & Promise.race实现

```js
class MyPromise {
  // ... 其他代码

  static resolve(value) {
    if (value instanceof MyPromise) {
      // 如果 value 是 Promise 实例，直接返回它
      return value;
    } else {
      // 否则，返回一个新的 Promise 实例，状态为 fulfilled
      return new MyPromise(resolve => resolve(value));
    }
  }

  static reject(reason) {
    // 返回一个新的 Promise 实例，状态为 rejected
    return new MyPromise((_, reject) => reject(reason));
  }

  static race(promiseArr) {
    return new MyPromise((resolve, reject) => {
      promiseArr.forEach(p => {
        // 只要有一个 Promise 实例状态变为 fulfilled 或 rejected，新的 Promise 实例的状态就会跟着改变
        MyPromise.resolve(p).then(resolve, reject);
      });
    });
  }
}
```

在这个实现中，`MyPromise.resolve` 方法接受一个值作为参数，如果这个值是一个 Promise 实例，就直接返回它；否则，返回一个新的 Promise 实例，状态为 fulfilled。

`MyPromise.reject` 方法接受一个原因作为参数，返回一个新的 Promise 实例，状态为 rejected。

`MyPromise.race` 方法接受一个 Promise 实例的数组作为参数，返回一个新的 Promise 实例。只要数组中有一个 Promise 实例的状态变为 fulfilled 或 rejected，新的 Promise 实例的状态就会跟着改变。

## Promise.allSettled 实现

`Promise.allSettled` 方法接收一个 Promise 实例的数组作为参数，返回一个新的 Promise 实例。只有等到所有的 Promise 实例都返回结果（无论 fulfilled 还是 rejected），新的 Promise 实例的状态才会变成 fulfilled。

以下是 `Promise.allSettled` 的简单实现：

```js
class MyPromise {
  // ... 其他代码

  static allSettled(promiseArr) {
    let result = [];
    let count = 0;

    return new MyPromise((resolve, _) => {
      promiseArr.forEach((p, i) => {
        MyPromise.resolve(p).then(
          val => {
            count++;
            result[i] = { status: 'fulfilled', value: val };
            if (count === promiseArr.length) {
              resolve(result);
            }
          },
          err => {
            count++;
            result[i] = { status: 'rejected', reason: err };
            if (count === promiseArr.length) {
              resolve(result);
            }
          }
        );
      });
    });
  }
}
```

在这个实现中，我们首先创建一个空的结果数组 `result` 和一个计数器 `count`。然后，我们遍历 `promiseArr`，对每个 Promise 调用 `MyPromise.resolve` 方法，然后在 `then` 方法中处理结果。

无论 Promise 成功还是失败，我们都将结果添加到 `result` 数组中，并增加 `count`。如果 `count` 等于 `promiseArr` 的长度，这意味着所有的 Promise 都返回了结果，我们就可以解决整个 `Promise.allSettled`。

## 简要理解Promise源码

理解并手写 Promise 源码需要对 Promise 的工作原理有深入的理解。以下是一些关键点：

1. **Promise 的三种状态**：Promise 有三种状态：pending（等待）、fulfilled（完成）、rejected（拒绝）。Promise 创建后默认为 pending 状态，可以转换为 fulfilled 或 rejected 状态，一旦状态改变，就不能再次改变。
2. **then 方法**：then 方法可以接收两个参数，分别是 Promise 成功和失败的回调。then 方法也会返回一个新的 Promise。
3. **catch 方法**：catch 方法其实是 then 方法的语法糖，只接收 Promise 失败的情况。
4. **finally 方法**：finally 方法不管 Promise 最后的状态如何，都会执行的操作。
5. **Promise.resolve 和 Promise.reject**：这两个方法分别用于创建一个立即 resolve 或 reject 的 Promise。
6. **Promise.all 和 Promise.race**：这两个方法用于处理多个 Promise。Promise.all 会等待所有 Promise 都完成，Promise.race 则是只要有一个 Promise 完成就会结束。
7. **Promise.allSettled**：这个方法用于处理多个 Promise，只有等到所有的 Promise 实例都返回结果（无论 fulfilled 还是 rejected），新的 Promise 实例的状态才会变成 fulfilled。

理解了这些关键点后，你可以尝试自己实现一个简单的 Promise，然后逐步增加更多的功能，例如链式调用、错误处理等。在实现过程中，你可能会遇到一些问题，但这也是理解 Promise 的好机会。你可以查阅相关的资料，或者查看 Promise 的 polyfill 来获取帮助。

## Promise.allSettled和Promise.all的区别是什么？

`Promise.all` 和 `Promise.allSettled` 都是用于处理多个 Promise 的静态方法，但它们的行为有所不同：

1. `Promise.all`：这个方法接收一个 Promise 实例的数组作为参数，返回一个新的 Promise 实例。只有当所有的 Promise 实例状态都变成 fulfilled，新的 Promise 实例的状态才会变成 fulfilled。只要数组中有一个 Promise 实例的状态变为 rejected，新的 Promise 实例的状态就会变成 rejected。
2. `Promise.allSettled`：这个方法也接收一个 Promise 实例的数组作为参数，返回一个新的 Promise 实例。但是，只有等到所有的 Promise 实例都返回结果（无论是 fulfilled 还是 rejected），新的 Promise 实例的状态才会变成 fulfilled。

简单来说，`Promise.all` 是“所有 Promise 都成功才算成功，有一个失败就算失败”，而 `Promise.allSettled` 是“无论成功失败，只要所有 Promise 都有结果就算成功”。

# 简历技巧

> 我的简历是有个顺序 [Summary -> Work Experience -> Project -> Education -> Additional Info]，比如我是前端选手，首先放个个人博客，里面有每个折腾做的小东西的具体信息， 然后我把所有我折腾过有经历的 经验和用过的技术都加到了简介和补充信息里面，比如自学 rust ，svelte ，expressjs ，做了个小模拟器，画 ui 设计图，移动端开发，维护一个游戏服务器和脚本啥的。正文的工作经历和项目就不带这些了

# 阿里面试题

![0869f476fc958f2c8c0d369cf396bcd](https://s2.loli.net/2024/02/21/RQ47ymjXVkAZwTY.png)


# watch 和 compted 哪个内部可以用异步?

## computed 属性

- **用途**：[`computed`](vscode-file://vscode-app/c:/Users/WuShiLi/AppData/Local/Programs/Microsoft VS Code Insiders/resources/app/out/vs/code/electron-sandbox/workbench/workbench.esm.html) 属性用于声明计算属性，这些属性会基于其他响应式数据进行计算，并且会缓存计算结果，直到依赖的数据发生变化。
- **异步操作**：[`computed`](vscode-file://vscode-app/c:/Users/WuShiLi/AppData/Local/Programs/Microsoft VS Code Insiders/resources/app/out/vs/code/electron-sandbox/workbench/workbench.esm.html) 属性不适合处理异步操作，因为它们期望同步返回一个值。如果在 [`computed`](vscode-file://vscode-app/c:/Users/WuShiLi/AppData/Local/Programs/Microsoft VS Code Insiders/resources/app/out/vs/code/electron-sandbox/workbench/workbench.esm.html) 属性中使用异步操作，可能会导致不可预测的行为和性能问题。

## `watch` 侦听器

- **用途**：`watch` 侦听器用于观察和响应数据的变化，适合处理需要在数据变化时执行的副作用操作，例如异步请求。
- **异步操作**：`watch` 侦听器可以很好地处理异步操作。你可以在 `watch` 回调函数中使用异步函数或 `Promise` 来处理异步任务。

## 总结

- **`computed` 属性**：适用于同步计算，不适合处理异步操作。
- **`watch` 侦听器**：适用于处理副作用操作，包括异步操作。

# HTML5是指什么

HTML5 是 HTML（超文本标记语言）的第五个主要版本。它是由万维网联盟（W3C）和 Web 超文本应用技术工作组（WHATWG）共同开发的标准，旨在改进和增强 Web 开发的功能和体验。HTML5 引入了许多新特性和改进，以下是一些主要内容：

## 1. 新的语义元素

HTML5 引入了许多新的语义元素，使得文档结构更加清晰和有意义：

- `<header>`：定义文档或部分的头部。
- `<footer>`：定义文档或部分的底部。
- `<article>`：定义独立的内容块。
- `<section>`：定义文档中的节。
- `<nav>`：定义导航链接的部分。
- `<aside>`：定义侧边栏内容。

## 2. 新的表单控件

HTML5 增加了许多新的表单控件和属性，增强了表单的功能和用户体验：

- `<input type="email">`：用于输入电子邮件地址。
- `<input type="url">`：用于输入 URL。
- `<input type="date">`：用于选择日期。
- `<input type="range">`：用于选择范围值。
- `<input type="color">`：用于选择颜色。
- 新的属性如 `placeholder`、`required`、`pattern` 等。

## 3. 多媒体元素

HTML5 引入了新的多媒体元素，使得在网页中嵌入音频和视频更加简单和标准化：

- `<audio>`：用于嵌入音频内容。
- `<video>`：用于嵌入视频内容。

## 4. 图形和绘图

HTML5 增加了用于绘图和图形处理的新元素和 API：

- `<canvas>`：用于绘制图形，通过 JavaScript 操作。
- SVG（可缩放矢量图形）：用于定义矢量图形。

## 5. 本地存储

HTML5 提供了新的本地存储机制，使得在客户端存储数据更加方便和持久：

- `localStorage`：用于存储持久化数据，数据不会随浏览器关闭而消失。
- `sessionStorage`：用于存储会话数据，数据会在浏览器关闭时消失。

## 6. 离线和缓存

HTML5 引入了应用缓存（AppCache）和服务工作者（Service Workers），使得 Web 应用可以在离线状态下运行：

- 应用缓存：允许开发者指定哪些资源可以被缓存，以便在离线时使用。
- 服务工作者：提供更强大的离线支持和后台任务处理能力。

## 7. 新的 API

HTML5 提供了许多新的 API，增强了 Web 应用的功能：

- 地理定位 API：允许获取用户的地理位置。
  - **获取当前位置**：
    - `navigator.geolocation.getCurrentPosition(successCallback, errorCallback, options)`
  - **持续监控位置变化**：
    - `navigator.geolocation.watchPosition(successCallback, errorCallback, options)`
  - **停止监控位置变化**：
    - `navigator.geolocation.clearWatch(watchId)`
- 拖放 API：允许在网页中实现拖放功能。
  - **设置可拖动元素**：
    - 使用 `draggable="true"` 属性。
    - 监听 `dragstart` 事件。
  - **设置放置目标**：
    - 监听 `dragover` 和 `drop` 事件。
- WebSocket API：提供全双工通信协议，用于实时通信。
- Web Workers API：允许在后台线程中运行 JavaScript，提升性能。

# 浏览器中输入地址后发生了什么事

当你在浏览器中输入一个 URL 并按下回车键后，会发生一系列的步骤来加载和显示网页。以下是这些步骤的详细描述：

1. **DNS 解析**：
   - 浏览器首先检查缓存（浏览器缓存、操作系统缓存、路由器缓存等）中是否有该域名的 IP 地址。
   - 如果缓存中没有找到，浏览器会向 DNS 服务器发送请求，将域名解析为 IP 地址。
2. **建立 TCP 连接**：
   - 浏览器使用解析得到的 IP 地址，通过三次握手与服务器建立 TCP 连接。
3. **发送 HTTP 请求**：
   - 浏览器向服务器发送 HTTP 请求。请求包括请求行（如 GET [index.html](vscode-file://vscode-app/c:/Users/96914/AppData/Local/Programs/Microsoft VS Code Insiders/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html) HTTP/1.1）、请求头（如 User-Agent、Accept 等）和可选的请求体（如 POST 请求的数据）。
4. **服务器处理请求**：
   - 服务器接收到请求后，处理请求并生成响应。服务器可能需要查询数据库、调用其他服务或执行其他逻辑来生成响应内容。
5. **服务器发送 HTTP 响应**：
   - 服务器将生成的响应发送回浏览器。响应包括状态行（如 HTTP/1.1 200 OK）、响应头（如 Content-Type、Content-Length 等）和响应体（如 HTML 文档、图片、JSON 数据等）。
6. **浏览器接收响应**：
   - 浏览器接收到服务器的响应后，检查响应状态码。如果状态码是 200（OK），则继续处理响应内容；如果是 301、302（重定向），则重新发送请求到新的 URL；如果是 404（Not Found）或 500（服务器错误），则显示相应的错误页面。
7. **解析 HTML**：
   - 浏览器开始解析 HTML 文档，构建 DOM 树。
   - 在解析 HTML 的过程中，浏览器会发现外部资源（如 CSS、JavaScript、图片等）的引用，并发送请求获取这些资源。
8. **解析 CSS**：
   - 浏览器解析 CSS 文件，生成 CSSOM（CSS 对象模型）树。
9. **构建渲染树**：
   - 浏览器将 DOM 树和 CSSOM 树结合，生成渲染树。
10. **布局（Layout）**：
    - 浏览器根据渲染树计算每个节点的几何位置（布局）。
11. **绘制（Painting）**：
    - 浏览器将渲染树的每个节点绘制到屏幕上。
12. **执行 JavaScript**：
    - 浏览器解析并执行 JavaScript 文件。JavaScript 可能会修改 DOM 树和 CSSOM 树，从而触发重新布局和重新绘制。
13. **事件处理**：
    - 浏览器处理用户交互事件（如点击、输入等），并根据事件处理程序更新页面。

# GET和POST请求在TCP层面发送的内容有什么区别？

在 TCP 层面，GET 和 POST 请求的主要区别在于它们的 HTTP 请求报文内容不同。以下是详细的区别：

### GET 请求

GET 请求通常用于请求服务器上的资源。它的请求报文包含请求行、请求头和空的请求体。以下是一个典型的 GET 请求的示例：

```
GET /path/to/resource HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
```

在 TCP 层面，GET 请求的内容如下：

1. **请求行**：包含请求方法（GET）、请求路径和 HTTP 版本。
2. **请求头**：包含各种头部字段，如 Host、User-Agent、Accept 等。
3. **请求体**：通常为空。

### POST 请求

POST 请求通常用于向服务器发送数据。它的请求报文包含请求行、请求头和请求体。以下是一个典型的 POST 请求的示例：

```
POST /path/to/resource HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 27
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive

field1=value1&field2=value2
```

在 TCP 层面，POST 请求的内容如下：

1. **请求行**：包含请求方法（POST）、请求路径和 HTTP 版本。
2. **请求头**：包含各种头部字段，如 Host、User-Agent、Content-Type、Content-Length 等。
3. **请求体**：包含实际发送的数据，如表单数据、JSON 数据等。

### 总结

在 TCP 层面，GET 和 POST 请求的主要区别在于：

1. **请求行**：GET 请求使用 `GET` 方法，而 POST 请求使用 `POST` 方法。
2. **请求头**：POST 请求通常包含 `Content-Type` 和 `Content-Length` 头部字段，以指示请求体的数据类型和长度。
3. **请求体**：GET 请求的请求体通常为空，而 POST 请求的请求体包含实际发送的数据。

尽管在 TCP 层面上，GET 和 POST 请求都是通过 TCP 数据包发送的，但它们的 HTTP 请求报文内容不同，从而导致它们在应用层的行为和用途有所不同。



# 前端有哪些性能优化手段？

前端性能优化是提升用户体验和网站响应速度的重要手段。以下是一些常见的前端性能优化手段：

### 1. 资源优化

- **压缩和合并文件**：使用工具如 Webpack、Gulp 等将多个 CSS 和 JavaScript 文件合并，并进行压缩，减少文件大小和 HTTP 请求数量。
- **使用 CDN**：将静态资源（如图片、CSS、JavaScript 文件）托管到内容分发网络（CDN），加快资源加载速度。
- **图片优化**：使用合适的图片格式（如 WebP），并进行压缩和裁剪，减少图片文件大小。
- **懒加载**：对于图片和其他资源，使用懒加载技术，只有在需要时才加载，减少初始加载时间。

### 2. 网络优化

- **减少 HTTP 请求**：合并 CSS 和 JavaScript 文件，使用 CSS Sprites 技术合并小图标，减少 HTTP 请求数量。
- **使用 HTTP/2**：HTTP/2 支持多路复用，可以在一个连接中并行加载多个资源，减少延迟。
- **启用 Gzip 压缩**：在服务器端启用 Gzip 压缩，减少传输数据量。

### 3. 缓存优化

- **浏览器缓存**：设置合适的缓存头（如 Cache-Control、Expires），让浏览器缓存静态资源，减少重复请求。
- **服务端缓存**：使用服务端缓存（如 Redis、Memcached）缓存动态内容，减少服务器负载和响应时间。

### 4. 渲染优化

- **减少重排和重绘**：避免频繁操作 DOM，使用文档片段（Document Fragment）批量更新 DOM，减少重排和重绘次数。
- **使用 CSS 动画**：尽量使用 CSS 动画而不是 JavaScript 动画，因为 CSS 动画通常由 GPU 加速，性能更好。
- **异步加载资源**：使用 `async` 和 `defer` 属性异步加载 JavaScript 文件，避免阻塞页面渲染。

### 5. 代码优化

- **代码分割**：使用 Webpack 等工具进行代码分割，按需加载模块，减少初始加载时间。
- **Tree Shaking**：使用工具如 Webpack、Rollup 等进行 Tree Shaking，移除未使用的代码，减少打包文件大小。
- **减少内存泄漏**：避免内存泄漏，确保及时清理不再使用的对象和事件监听器。

### 6. 其他优化

- **使用 Service Worker**：使用 Service Worker 实现离线缓存和后台同步，提高应用的可靠性和性能。
- **预加载和预获取**：使用 `<link rel="preload">` 和 `<link rel="prefetch">` 标签预加载和预获取资源，减少关键资源的加载时间。
- **优化首屏加载时间**：优先加载首屏内容，延迟加载非关键资源，提升用户的首屏体验。

这些优化手段可以结合使用，根据具体项目的需求和瓶颈进行针对性的优化，以达到最佳的性能效果。



## null和undefined的区别

`null` 和 `undefined` 是 JavaScript 中的两种不同的原始类型，它们在含义和使用场景上有所不同。以下是它们的主要区别：

### 含义

- **`undefined`**：
  - 表示变量已声明但尚未赋值。
  - 表示对象属性不存在。
  - 表示函数没有返回值。
  - 表示函数参数未传递。
- **`null`**：
  - 表示变量已声明并赋值为空值。
  - 表示对象不存在或空对象。
  - 通常用于显式地表示“没有值”或“空值”。

### 类型

- **`undefined`**：

  - 类型是 `undefined`。

  ```js
  typeof undefined; // "undefined"
  ```

- **`null`**：

  - 类型是 `object`（这是一个历史遗留问题）。

    ```js
    typeof null; // "object"
    ```

### 使用场景

- **`undefined`**：

  - 变量声明但未赋值时：

    ```js
    let a;
    console.log(a); // undefined
    ```

  - 访问对象不存在的属性时：

    ```js
    let obj = {};
    console.log(obj.nonExistentProperty); // undefined
    ```

  - 函数没有返回值时：

    ```js
    function doNothing() {}
    console.log(doNothing()); // undefined
    ```

  - 函数参数未传递时：

    ```js
    function logParam(param) {
      console.log(param);
    }
    logParam(); // undefined
    ```

- **`null`**：

  - 显式赋值为空值时：

    ```js
    let b = null;
    console.log(b); // null
    ```

  - 表示对象不存在时：

    ```js
    let person = {
      name: "Alice",
      spouse: null // 表示没有配偶
    };
    ```

    

### 比较

- **相等比较（==）**：

  - `null` 和 `undefined` 在相等比较中被认为是相等的。

  ```js
  console.log(null == undefined); // true
  ```

**严格相等比较（===）**：

- `null` 和 `undefined` 在严格相等比较中被认为是不相等的。

  ```js
  console.log(null === undefined); // false
  ```

### 总结

- `undefined` 通常表示变量尚未赋值、对象属性不存在、函数没有返回值或函数参数未传递。
- `null` 通常用于显式地表示“没有值”或“空值”。

# 使用Number时有什么需要注意事项

在 JavaScript 中使用 `Number` 类型时，有一些需要注意的事项，以避免潜在的错误和意外行为。以下是一些关键点：

### 1. 数值范围

JavaScript 中的 `Number` 类型是基于 IEEE 754 双精度浮点数格式的，这意味着它有一定的数值范围：

- 最大安全整数：`Number.MAX_SAFE_INTEGER`（2^53 - 1）
- 最小安全整数：`Number.MIN_SAFE_INTEGER`（-(2^53 - 1)）
- 最大值：`Number.MAX_VALUE`（1.7976931348623157e+308）
- 最小值：`Number.MIN_VALUE`（5e-324）

超出这些范围的数值可能会导致精度丢失或溢出。

### 2.精度问题

由于浮点数的表示方式，JavaScript 中的 `Number` 类型在处理小数时可能会出现精度问题。例如：

```js
console.log(0.1 + 0.2); // 0.30000000000000004
```

解决方法：

- 使用 `toFixed` 方法来限制小数位数。
- 使用 `BigInt` 类型处理大整数。
- 使用专门的库（如 `decimal.js`）来处理高精度计算。

### 3. 类型转换

使用 `Number` 构造函数或 `parseInt`、`parseFloat` 函数进行类型转换时需要注意：

- `Number` 构造函数：

  ```js
  console.log(Number("123")); // 123
  console.log(Number("123abc")); // NaN
  ```

- `parseInt` 和 `parseFloat`：

  ```js
  console.log(parseInt("123")); // 123
  console.log(parseInt("123abc")); // 123
  console.log(parseFloat("123.45")); // 123.45
  console.log(parseFloat("123.45abc")); // 123.45
  ```

注意：`parseInt` 和 `parseFloat` 会忽略字符串中的非数值字符，而 `Number` 构造函数则会返回 `NaN`。

### 4. NaN（Not-a-Number）

`NaN` 是一个特殊的 `Number` 值，表示不是一个有效的数值。需要注意：

- `NaN` 与任何值都不相等，包括它自己：

  ```js
  console.log(NaN === NaN); // false
  ```

- 使用 `isNaN` 函数检查是否为 `NaN`：

  ```js
  console.log(isNaN(NaN)); // true
  console.log(isNaN("abc")); // true
  ```

  注意：`isNaN` 会将非数值类型转换为数值再进行检查，因此可能会产生误导。可以使用 `Number.isNaN` 进行更严格的检查：

  ```js
  console.log(Number.isNaN(NaN)); // true
  console.log(Number.isNaN("abc")); // false
  ```

4.  Infinity 和 -Infinity

`Infinity` 和 `-Infinity` 是两个特殊的 `Number` 值，表示正无穷大和负无穷大：

- 任何数值除以 0 会得到 `Infinity` 或 `-Infinity`：

  ```js
  console.log(1 / 0); // Infinity
  console.log(-1 / 0); // -Infinity
  ```

- 可以使用 `isFinite` 函数检查是否为有限数值：

  ```js
  console.log(isFinite(123)); // true
  console.log(isFinite(Infinity)); // false
  console.log(isFinite(NaN)); // false
  ```

###  6.数值比较

在进行数值比较时需要注意浮点数的精度问题：

```js
console.log(0.1 + 0.2 === 0.3); // false
```

# 0.1 + 0.2 为什么不=== 0.3

`0.1 + 0.2` 不等于 `0.3` 的原因是由于浮点数表示的精度问题。JavaScript 使用 IEEE 754 双精度浮点数格式来表示数字，这种格式在表示十进制小数时会出现精度丢失。

### 详细解释

在 IEEE 754 双精度浮点数格式中，数字是以二进制形式存储的。某些十进制小数（如 0.1 和 0.2）在二进制中无法精确表示，会导致精度丢失。

#### 0.1 和 0.2 的二进制表示

- 0.1 的二进制表示是一个无限循环小数：

  ```
  0.1 = 0.0001100110011001100110011001100110011001100110011001101... (无限循环)
  ```

- 0.2 的二进制表示也是一个无限循环小数：

  ```
  0.2 = 0.001100110011001100110011001100110011001100110011001101... (无限循环)
  ```

  由于计算机只能存储有限位数的二进制数，这些无限循环小数会被截断，从而导致精度丢失。

#### 0.1 + 0.2 的计算过程

当你在 JavaScript 中计算 `0.1 + 0.2` 时，实际的计算结果是一个接近但不完全等于 0.3 的值：

```js
console.log(0.1 + 0.2); // 0.30000000000000004
```

由于这个结果与 0.3 不完全相等，所以 `0.1 + 0.2 === 0.3` 返回 `false`。

### 解决方法

为了避免浮点数精度问题，可以使用以下方法：

#### 1. 使用一个小的容差值进行比较

可以使用 `Number.EPSILON` 作为容差值来比较两个浮点数是否接近：

```js
const epsilon = Number.EPSILON;
console.log(Math.abs(0.1 + 0.2 - 0.3) < epsilon); // true
```

#### 2.使用整数进行计算

如果可以，将浮点数转换为整数进行计算，然后再转换回浮点数：

```js
const result = (0.1 * 10 + 0.2 * 10) / 10;
console.log(result === 0.3); // true
```

#### 3.使用专门的库

可以使用专门处理高精度计算的库，如 `decimal.js` 或 `big.js`：

```js
const Decimal = require('decimal.js');
const result = new Decimal(0.1).plus(0.2);
console.log(result.equals(0.3)); // true
```

### 总结

`0.1 + 0.2` 不等于 `0.3` 是由于浮点数表示的精度问题。通过使用容差值、整数计算或专门的高精度计算库，可以避免这种问题。了解这些细节有助于编写更可靠的数值计算代码。

# TCP三次握手过程

TCP 三次握手是建立 TCP 连接的过程，确保客户端和服务器之间能够可靠地传输数据。以下是三次握手的详细步骤：

1. **第一次握手（SYN）**：
   - 客户端向服务器发送一个 SYN（synchronize）报文段，请求建立连接。报文段中包含一个初始序列号（Sequence Number）。
   - 客户端进入 SYN_SENT 状态。

```
客户端 -> 服务器: SYN, Seq = x
```

2.**第二次握手（SYN-ACK）**：

- 服务器收到 SYN 报文段后，向客户端发送一个 SYN-ACK（synchronize-acknowledge）报文段，表示同意建立连接。报文段中包含服务器的初始序列号（Sequence Number）和对客户端 SYN 报文段的确认序列号（Acknowledgment Number = x + 1）。
- 服务器进入 SYN_RECEIVED 状态。

```
服务器 -> 客户端: SYN, Seq = y, ACK, Ack = x + 1
```

3.**第三次握手（ACK）**：

- 客户端收到 SYN-ACK 报文段后，向服务器发送一个 ACK（acknowledge）报文段，确认连接建立。报文段中包含对服务器 SYN 报文段的确认序列号（Acknowledgment Number = y + 1）。
- 客户端进入 ESTABLISHED 状态，服务器收到 ACK 报文段后也进入 ESTABLISHED 状态。

```
客户端 -> 服务器: ACK, Seq = x + 1, Ack = y + 1
```

经过这三次握手，客户端和服务器都进入 ESTABLISHED 状态，连接建立完成，双方可以开始传输数据。

### 三次握手的目的

1. **确认双方的接收能力和发送能力**：确保客户端和服务器都能接收和发送数据。
2. **同步序列号**：确保双方的序列号同步，保证数据传输的可靠性。
3. **防止重复的连接初始化**：避免旧的重复连接请求对当前连接产生干扰。
