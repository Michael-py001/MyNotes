

> 精选面试资料：
>
> [前端面试宝典 (yuque.com)](https://gxaedu.yuque.com/yi2lv1/ymweyp)
>
> [BFE.dev - 前端刷题，提升前端开发实力，拿到心仪的Offer。 (bigfrontend.dev)](https://bigfrontend.dev/zh)

## 1. JS数据类型有哪些

​	**Number,String,null,undefind,boolean,object,bigint,symbol**

## 2.函数的参数是按值传递还是按引用传递?

> ​	参考：20230208-函数的参数是按值传递还是按引用传递？

在 JavaScript 中，函数的参数传递是按值传递的。这意味着，当一个函数被调用时，它的参数会被复制到函数的局部变量中，而不是直接传递引用。

需要注意的是，如果函数的参数是一个对象或数组，那么复制的**是对象或数组的引用(引用地址)**，而不是对象或数组本身。这意味着，如果在函数内部修改了对象或数组的属性(**修改的是地址指向的内容**)，那么这个修改会影响到原始对象或数组。

例如，考虑以下代码：

```js
function changeName(person) {
 person.name = 'Alice';
}

var person = { name: 'Bob' };
changeName(person);
console.log(person.name); // 输出 'Alice'
```

在这个例子中，`changeName` 函数的参数 `person` 是一个对象。当函数被调用时，`person` 的值被复制到函数的局部变量中，但是这个值是对象的引用。因此，当在函数内部修改 `person` 的属性时，这个修改会影响到原始对象 `person`。

需要注意的是，虽然函数的参数传递是按值传递的，但是如果参数是一个对象或数组，那么这个值是对象或数组的引用。因此，在处理函数的参数时，需要注意对象和数组的引用关系，以避免出现意外的副作用。

### 例子 ：一   基本类型

```js
let a = 1
function change(x) {
	x += 2
    console.log("x:",x)
    console.log("a:",a)
}
change(a)
// x: 3
// a: 1
```

### 例子 ：二  引用类型

```js
let a = {value:'1'}
function change(x) {
	x.value = 2
    console.log("x:",x)
    console.log("a:",a)
}
change(a)
// x {value: 2}
// a {value: 2}
```

### 例子 ：三  引用类型

```js
let a = {value:'1'}
function change(x) {
	x.value = 2
    x = {name:'lili'}
    console.log("x:",x)
    console.log("a:",a)
}
change(a)
// x {name: 'lili'}
// a {value: 2}
```



## 3.Vue的组件通信有哪些方式

1. **父子组件通信**：父组件可以通过 props 向子组件传递数据，子组件可以通过 $emit 触发事件向父组件传递数据。(props + emit ，$parent，$children;)
2. **兄弟组件通信**：可以通过一个共同的父组件作为中介，将数据通过 props 和 $emit 分别传递给两个兄弟组件。
3. **跨级组件通信**：可以通过 provide 和 inject 来实现跨级组件通信，provide 可以在父组件中提供数据，inject 可以在子组件中注入数据。
4. **非父子组件通信**：可以使用一个空的 Vue 实例作为中央事件总线（**Event Bus**），用它来触发事件和监听事件，从而实现任意组件之间的通信。(缺点是事件多了就难以维护)
5. **Vuex 状态管理**：Vuex 是 Vue 官方提供的状态管理库，可以将共享的状态抽离出来，以 store 的形式集中管理，从而实现组件之间的通信。

需要注意的是，不同的组件通信方式适用于不同的场景，应根据具体的业务需求选择合适的方式。同时，过多的组件通信也可能会导致代码复杂度增加，因此应尽量避免过度使用组件通信。

此外还可以使用localstorage。

### Event Bus的原理是什么

Event Bus 是一种组件通信方式，它的原理是利用 Vue 实例作为中央事件总线，用它来触发事件和监听事件，从而实现任意组件之间的通信。

具体来说，Event Bus 的原理如下：

1. 创建一个空的 Vue 实例，作为中央事件总线。

   ```js
   // event-bus.js
   import Vue from 'vue';
   export const EventBus = new Vue();
   ```

   

2. 在需要通信的组件中，通过 `$emit` 方法触发事件，并将需要传递的数据作为参数传入。

   ```js
   // componentA.vue
   import { EventBus } from './event-bus.js';
   export default {
     methods: {
       handleClick() {
         EventBus.$emit('event-name', data);
       }
     }
   }
   ```

   

3. 在需要接收数据的组件中，通过 `$on` 方法监听事件，并在回调函数中获取传递的数据。

   ```js
   // componentB.vue
   import { EventBus } from './event-bus.js';
   export default {
     created() {
       EventBus.$on('event-name', data => {
         // 处理数据
       });
     }
   }
   ```

   

4. 当事件被触发时，中央事件总线会将事件和数据广播给所有监听该事件的组件。

需要注意的是，Event Bus 的使用需要谨慎，因为它会将所有事件广播给所有组件，可能会导致性能问题和代码复杂度增加。因此，应尽量避免过度使用 Event Bus，而是根据具体的业务需求选择合适的组件通信方式。

## 5. Vue2的响应式数据是怎么实现的，有什么缺陷？

Vue2 中的响应式系统是通过 `Object.defineProperty()` 方法实现的，该方法可以将一个对象的属性定义为“响应式”，当属性值发生变化时，会自动触发相关的更新操作。虽然 `Object.defineProperty()` 方法在实现响应式系统方面具有一定的优势，但也存在一些缺点，包括：

1. **对象新增或删除属性时无法监听**：`Object.defineProperty()` 方法只能监听已经存在的属性，无法监听对象新增或删除属性的操作。这意味着，如果你需要监听对象新增或删除属性的操作，就需要使用其他的方法（如 `Vue.set()` 和 `Vue.delete()`）。
2. **对象嵌套层级过深时性能较差**：`Object.defineProperty()` 方法只能监听对象的一层属性，如果对象嵌套层级过深，就需要递归遍历对象的每一层属性，这可能会导致性能问题。
3. **无法监听数组下标的变化**：`Object.defineProperty()` 方法无法监听数组下标的变化，因为数组的下标不是一个属性，而是一个索引。因此，如果你需要监听数组下标的变化，就需要使用其他的方法（如 `Vue.set()` 和 `Vue.delete()`）。
4. **兼容性问题**：`Object.defineProperty()` 方法在 IE8 及以下版本的浏览器中不支持，因此在开发过程中需要注意兼容性问题。

为了解决以上问题，Vue3 中采用了 Proxy 对象来实现响应式系统，Proxy 对象可以监听对象的新增、删除和修改操作，而且性能也比 `Object.defineProperty()` 方法更好。

> ​	[Vue2源码解读（4） - 响应式原理及简单实现 - 石志凯 - 博客园 (cnblogs.com)](https://www.cnblogs.com/shizk/p/15456247.html)

​	实现响应式的代码：

```js
function updateView () {
  console.log('视图更新')
}

// 重新定义数组原型
const oldArrayProperty = Array.prototype
// 创建新对象原型指向 Array.prototype，在扩展新的方法不会影响原型
const arrProto = Object.create(oldArrayProperty);
['push', 'pop', 'shift', 'unshift', 'splice','sort','reverse'].forEach(methodName => {
  arrProto[methodName] = function () {
    updateView()
    oldArrayProperty[methodName].call(this, ...arguments)
  } 
});

// 监听data传入的属性
function defineReactive(target, key, value) {
  // 深度监听 多层对象嵌套
  observer(value)
  // 核心api
  Object.defineProperty(target, key, {
    get() {
      return value
    },

    set(newVal) {
      // 设置新值也要监听 比如{age:27}
      observer(newVal)
      if (newVal !== value ) {
        value = newVal
        updateView()
      }
    }
  })
}
// 监听对象属性
function observer(target) {
  if (typeof target !== 'object' || target === null) {
    // 不是对象或数组
    return target
  }
  // 监听数组 把原数组的隐式原型赋值给我们定义好的数组对象
  if (Array.isArray(target)) {
    target.__proto__ = arrProto
  }
  // 重新定义各个属性，加getter、setter属性
  for(let key in target) {
    defineReactive(target, key, target[key])
  }
}

const data = {
  name: 'zk',
  age: 26,
  info: {
    address: 'city'  // 需深度监听
  },
  nums: [1, 2, 3]
}
observer(data)
// data.info.address = 'beijing' // 需要深度监听
// data.info = {address:'beijing'} // 需要深度监听
// data.x = 666                  // 新增属性，监听不到  需要vue.set方法 
// delete data.name              // 删除属性，监听不到  需要vue.delete方法 
data.nums.push(21)

```

## 6. 为什么在Vue2中使用数组API时可以检测到变化

​	因为Vue2里对7个数组API(pop,push,shift,unshift,splice,sort,reverse)进行了一层封装，当使用这些数组方法时，会自动对里面的值进行监听。

## 7. Vue2中对数组封装达到响应式的这种方法在设计模式上叫什么？

​	从源码来看，应该是观察者模式。

## 8. 你知道的设计模式有哪些？

- **单例模式** : 确保一个类只有一个实例，并提供全局访问点。

  > [JS设计模式一：单例模式 - 走看看 (zoukankan.com)](http://t.zoukankan.com/douglasvegas-p-5853579.html)

  单例模式之所以这么叫，是因为它限制一个类只能有一个实例化对象。

  **好处：**

  1. 保证了全局只有一个实例，避免了重复创建对象的开销和资源浪费。
  2. 提供了全局访问点，方便了对象的访问和管理。
  3. 避免了多个实例之间的状态不一致问题，保证了数据的一致性。
  4. 可以控制对象的生成和销毁时机，从而更好地管理系统资源。
  
- **工厂模式**：通过一个工厂方法来创建对象，而不是通过直接调用构造函数来创建对象。

- **观察者模式**：定义了一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都会得到通知并自动更新。

- **装饰者模式**：动态地给一个对象添加一些额外的职责，而不需要修改这个对象的代码。

- **MVC 模式**：将应用程序分为三个部分：模型（Model）、视图（View）和控制器（Controller），从而实现了数据、视图和用户交互之间的分离。

- **发布订阅模式** : 用于解决对象之间的通信问题

## 9. Vue2的数据双向绑定是怎么实现的？

### 高级版

Vue2 的数据双向绑定是通过数据劫持和发布订阅模式实现的。

具体来说，Vue2 在初始化时会对**数据对象进行递归遍历**，将每个属性都**转换为 getter 和 setter**，并且在数据对象上**定义一个 `Dep` 对象**，用来收集依赖和通知更新。**当数据对象的属性被访问时**，会触发 getter 方法，此时会将当前的 `Watcher` 对象添加到 `Dep` 对象的依赖列表中。当数据对象的属性被修改时，会触发 setter 方法，此时会通知 `Dep` 对象的所有依赖进行更新。

在模板编译时，Vue2 会将模板中的指令和表达式解析成对应的 `Watcher` 对象，并将其添加到 `Dep` 对象的依赖列表中。当数据对象的属性被修改时，会触发 `Dep` 对象的更新方法，此时会通知所有依赖进行更新，从而实现了数据的双向绑定。

> #### `Watcher` 对象是什么？
>
> `Watcher` 对象是 Vue 中实现数据响应式的核心对象之一，用于监听数据的变化并触发对应的回调函数。
>
> 在 Vue 中，每个组件都会有一个 `Watcher` 对象，用于监听组件内部数据的变化。当组件内部的数据发生变化时，`Watcher` 对象会自动触发回调函数，从而更新组件的视图。
>
> 除了组件内部的数据变化，`Watcher` 对象还可以监听其他数据源的变化，例如 Vuex 中的状态变化、路由参数的变化等。通过监听这些数据源的变化，`Watcher` 对象可以及时更新组件的视图，保证视图与数据的同步。
>
> 需要注意的是，Vue3 中的 `Watcher` 对象已经被废弃，取而代之的是 `ReactiveEffect` 对象。`ReactiveEffect` 对象与 `Watcher` 对象类似，也用于监听数据的变化并触发回调函数。但是，与 `Watcher` 对象不同的是，`ReactiveEffect` 对象可以支持多个回调函数，从而提高了代码的灵活性和可维护性。

### 普通版

- 使用v-model实现，v-model是`v-bind:value`和`v-on:input`的语法糖

  - `v-bind:value`实现了data=>UI的单向绑定
  - `v-on:input`实现了UI=>data的单向绑定
  - 加起来就是双向绑定了

- ### 这两个单向绑定是如何实现的？

  - 前者通过Object.defineProperty API给data创建getter和setter，用于监听data的改变，data一变就会触发视图更新

  - 后者通过template compiler给DOM添加事件监听，DOM input的值变了就会去修改data

  - 代码：

    ```html
    <div>内容：<span id="content"></span></div>
    <input id="iptName" />
    ```

    ```js
    const iptName = document.getElementById('iptName')
    const content = document.getElementById('content')
    let obj = {
      name: ''
    }
    let newObj = JSON.parse(JSON.stringify(obj))
    Object.defineProperty(obj, 'name', {
      get() {
        return newObj.name
      },
    
      set(val) {
        if (val === newObj.name) return
        newObj.name = val
        observer()
      }
    })
    function observer () {
      iptName.innerText = obj.name
      content.innerText = obj.name
    }
    iptName.oninput = function () {
      obj.name = this.value
    }
    
    ```

## 10. JS的数据类型检测有哪些？

> ​	建议直接回答`Object.prototype.toString.call()`，最完美的方法。

1. **typeof 操作符**：可以检测基本数据类型（number、string、boolean、undefined）和函数类型，但无法检测 null 和对象类型。
2. **instanceof 操作符**：可以检测对象的具体类型，但无法检测基本数据类型和 null。
3. **Object.prototype.toString.call() 方法**：可以检测所有数据类型，包括基本数据类型、null 和对象类型。
4. **Array.isArray() 方法**：可以检测数组类型。

需要注意的是，typeof 操作符和 instanceof 操作符都存在一些局限性，不能完全准确地检测数据类型。因此，在实际开发中，应该根据具体的需求和场景选择合适的数据类型检测方式。

- ### 数组类型的检测方法有哪些？

  - Array.isArray()
  - arr1 instanceof Array
  - Object.prototype.toString.call()

## 11. Vue的生命周期

- Vue2: beforeCreate, created, beforeMount , mounted, beforeUpdata, updated, beforeDestory, destoryed;
  还有三个不常用的：activated, deactivated,errorCaptured
- vue3: setup(Compostion API)，beforeCreate,created, beforeMount , mounted, beforeUpdate, updated, beforeUnmount, unmounted,activated, deactivated, errorCaptured

## 12. 请求接口放在哪个生命周期？

在 Vue 中，通常将请求接口放在 `mounted` 生命周期中。`mounted` 生命周期是组件挂载后调用的钩子函数，此时组件已经渲染到页面上，可以访问 DOM 元素和组件实例。在 `mounted` 生命周期中发起请求，可以保证组件已经准备好了数据和 DOM，避免出现数据渲染不完整或者 DOM 元素未加载的问题。

- ### 为什么不放在created里面？

  因为跟SSR有关，如果放在created里面，后端会执行一次，前端也会执行一次，不符合要求，使用mounted就合适，只会在前端执行一次。

## 13. 为什么v-if和v-for不能同时使用？

​	**vue2中**：当它们都处于同一节点时，**v-for 的优先级高于 v-if**。这意味着，v-if 会在循环的每个元素上进行判断一次，会造成大量的性能消耗。

​    **vue3中**：当它们同时存在于一个节点上时，**`v-if` 比 `v-for` 的优先级更高**。这意味着 `v-if` 的条件将无法访问到 `v-for` 作用域内定义的变量别名：

```html
<!--
 这会抛出一个错误，因为属性 todo 此时
 没有在该实例上定义
-->
<li v-for="todo in todos" v-if="!todo.isComplete">
  {{ todo.name }}
</li>
```



## 14. v-if和v-show的区别

`v-show` 本质是 **操作css样式display属性**来控制元素 **显示和隐藏**

`v-if` 本质是 **控制页面上DOM节点**添加和删除

## 15. Vue3为什么使用Proxy?

 1. 弥补 Object.defineProperty 的两个不足 

    a. 动态创建的 data 属性需要用 Vue.set 来赋值，Vue 3 用了 Proxy 就不需要了 

    b. 基于性能考虑， [Vue 2 篡改了数组的 7 个 API](https://cn.vuejs.org/v2/guide/list.html#%E5%8F%98%E6%9B%B4%E6%96%B9%E6%B3%95)，Vue 3 用了 Proxy 就不需要了 

2. defineProperty 需要提前递归地遍历 data 做到响应式，而 Proxy 可以在真正用到 深层数据的时候再做响应式（惰性）

## 16. Vue3相比Vue2有了哪些改进？

- **更好的性能：响应式系统**

  vue2中采用 defineProperty来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加getter和setter，实现响应式。vue3采用proxy重写了响应式系统，因为proxy可以对整个对象进行监听，所以不需要深度遍历。相比 Vue2 中的 `Object.defineProperty()` 方法，Proxy 对象具有更好的性能和更广泛的兼容性

  - 可以监听动态属性的添加
  - 可以监听到数组的索引和数组length属性
  - 可以监听删除属性

- **更小的源码体积**：
  相比Vue2，Vue3整体体积变小了，除了移除一些不常用的API。

  Vue3 中采用了 Tree-shaking 技术，可以在打包时自动去除未使用的代码，从而减小项目的体积，如ref、reavtived、computed等，仅仅在用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小。

- **diff算法优化**

  vue2中的虚拟dom是全量的对比，

  vue3在diff算法中相比vue2增加了`patch flag`静态标记，其作用是在发生变化的地方添加一个flag标记，下次发生变化的时候直接找该地方进行比较。

- **更好的 TypeScript 支持**：Vue3 中对 TypeScript 的支持更加完善，包括更好的类型推断、更好的类型定义和更好的 IDE 支持。
- **更好的组合 API**：Vue3 中引入了 Composition API，可以更好地组织和复用组件逻辑，使代码更加清晰和易于维护。
- **更好的自定义指令**：Vue3 中对自定义指令的支持更加灵活，可以更方便地实现复杂的交互效果。
- **更好的性能调优工具**：Vue3 中引入了更多的性能调优工具，包括更好的 DevTools 和更好的性能分析工具，可以更方便地进行性能优化。

### vue3的diff算法对比vue2做了哪些优化

1. **静态节点提升**：Vue3 通过静态节点提升的方式，将静态节点和动态节点分离，从而减少了对动态节点的比对次数，提高了渲染性能。
2. **针对动态节点的优化**：Vue3 在比对动态节点时，采用了类似 React Fiber 的双缓存技术，将比对过程分为了两个阶段，从而减少了比对的时间和复杂度。
3. **缓存组件构造函数**：Vue3 在创建组件实例时，会缓存组件的构造函数，从而避免了重复的构造函数调用，提高了组件的创建性能。
4. **静态属性提升**：Vue3 通过静态属性提升的方式，将静态属性和动态属性分离，从而减少了对动态属性的比对次数，提高了渲染性能。
5. **模板编译优化**：Vue3 在模板编译时，采用了更加高效的编译器，从而生成更加高效的渲染函数，提高了渲染性能。

## 17. Vue 3 对比 Vue 2 做了哪些改动？

 官方文档 写了[（ 中文在这 ）](https://v3.cn.vuejs.org/guide/migration/introduction.html#%E9%9D%9E%E5%85%BC%E5%AE%B9%E7%9A%84%E5%8F%98%E6%9B%B4)，这里列出几个容易被考的： 

1. createApp() 代替了 new Vue() 
2. v-model 代替了以前的 v-model 和 .sync 
3. 根元素可以有不止一个元素了 
4. 新增 Teleport 传送门 
5. destroyed 被改名为 unmounted 了（before 当然也改了） 
6. ref 属性支持函数了 

其他建议自己看看写写。

## 18.display:inline-block幽灵节点问题

如果两个span或者img标签一起写，会有中间的缝隙

- 解决办法：改成display:block

## 19.Vue的路由模式

Vue 提供了两种路由模式：`hash` 模式和 `history` 模式。

在 `hash` 模式下，路由的路径会被格式化为 `/#/path/to/page` 的形式，其中 `#` 符号表示 URL 的锚点，后面的路径表示路由的路径。这种模式下，路由的变化不会触发浏览器的刷新，而是通过监听 `hashchange` 事件来实现路由的切换。

在 `history` 模式下，路由的路径会被格式化为 `/path/to/page` 的形式，这种模式下，路由的变化会触发浏览器的刷新，因此需要服务器端的支持。在使用 `history` 模式时，需要在服务器端配置一个 `fallback` 页面，用于处理路由的请求，从而避免出现 404 错误。

- nginx配置

  [不同的历史模式 | Vue Router (vuejs.org)](https://router.vuejs.org/zh/guide/essentials/history-mode.html#nginx)

  ```nginx
  location / {
    try_files $uri $uri/ /index.html;
  }
  ```

  

需要注意的是，无论是 `hash` 模式还是 `history` 模式，都需要在 Vue 的路由配置中进行相应的设置。在 Vue2 中，可以通过 `VueRouter` 的 `mode` 属性来设置路由模式，例如：

```js
const router = new VueRouter({
  mode: 'history',
  routes: [...]
})
```

在 Vue3 中，可以通过 `createRouter` 函数的 `history` 属性来设置路由模式，例如

```js
const router = createRouter({
  history: createWebHistory(),
  routes: [...]
})
```

需要注意的是，在使用 `history` 模式时，需要在服务器端进行相应的配置，以确保路由的正常访问。

这有一个注意事项。你的服务器将不再报告 404 错误，因为现在所有未找到的路径都会显示你的 `index.html` 文件。为了解决这个问题，你应该在你的 Vue 应用程序中实现一个万能的路由来显示 404 页面。

```js
const router = createRouter({
  history: createWebHistory(),
  routes: [{ path: '/:pathMatch(.*)', component: NotFoundComponent }],
})
```

## 20.Vue路由跳转的API

- route.push()
- route.replace()
- route.go() // -1可以回退
- route.back()

## 21.线上项目遇到问题处理

- 后端自动回滚上一个版本

## 22.Vue渐进式的理解

Vue 是一种渐进式 JavaScript 框架，渐进式意味着 Vue 可以根据项目的需求进行逐步引入和使用，而不需要一次性引入所有功能和特性。

Vue 的核心库只关注视图层，提供了一些基本的功能，如模板语法、组件系统、响应式数据绑定等。同时，Vue 还提供了一些插件和工具，如 Vue Router、Vuex、Vue CLI 等，用于处理路由、状态管理、构建工具等方面的问题。

Vue 的渐进式设计使得开发者可以根据项目的需求选择使用不同的功能和工具，而不需要承担额外的负担。

## 23.git冲突怎么处理

- 冲突后怎么处理
  - 打开冲突文件，查看冲突的部分，找到冲突的原因。
  - 手动修改冲突的部分，保留需要的代码，删除不需要的代码，或者根据需要进行合并。
  - 保存修改后的文件，然后使用 `git add` 命令将修改后的文件添加到暂存区。
  - 使用 `git commit` 命令提交修改，添加一条有意义的提交信息。

- 怎么避免冲突
  - 避免同时修改同一个文件的同一部分，可以在团队协作时分工明确，或者使用分支进行开发，避免多人同时修改同一个文件。
  - 在修改代码之前，先拉取最新的代码，避免修改过时的代码，导致冲突。
  - 在提交代码之前，先使用 `git diff` 命令查看修改的内容，确保没有修改不需要修改的部分。
  - 在提交代码之前，先使用 `git pull` 命令拉取最新的代码，避免其他人已经修改了相同的文件。


## css3新增属性有哪些？

1. `box-shadow`：用于添加元素的阴影效果。
2. `text-shadow`：用于添加文本的阴影效果。
3. `border-radius`：用于设置元素的圆角。
4. `background-size`：用于设置背景图片的大小。
5. `background-clip`：用于设置背景图片的裁剪方式。
6. `background-origin`：用于设置背景图片的起始位置。
7. `background-image`：用于设置元素的背景图片。
8. `transition`：用于设置元素的过渡效果。
9. `transform`：用于设置元素的变换效果，如旋转、缩放、平移等。
10. `animation`：用于设置元素的动画效果。

## 24.CSS3动画的属性

1. `animation-name`：指定动画的名称。
2. `animation-duration`：指定动画的持续时间。
3. `animation-timing-function`：指定动画的时间函数，用于控制动画的速度变化。
4. `animation-delay`：指定动画的延迟时间。
5. `animation-iteration-count`：指定动画的循环次数。
6. `animation-direction`：指定动画的播放方向。
7. `animation-fill-mode`：指定动画结束后元素的样式。
8. `animation-play-state`：指定动画的播放状态，用于控制动画的暂停和继续。



## 25. 手写深拷贝

```js
function deepCopy(obj, hash = new WeakMap()) {
  if (Object(obj) !== obj) return obj; // 基本类型直接返回
  if (hash.has(obj)) return hash.get(obj); // 避免循环引用
  let result;
  if (obj instanceof RegExp) {
    result = new RegExp(obj);
  } else if (obj instanceof Date) {
    result = new Date(obj);
  } else if (obj instanceof Function) {
    result = function () {
      return obj.apply(this, arguments);
    };
  } else if (obj instanceof Object) {
    result = new obj.constructor();//根据constructor创建一个新对象
    hash.set(obj, result);
    for (let key in obj) {
      if (obj.hasOwnProperty(key)) {
        result[key] = deepCopy(obj[key], hash);
      }
    }
  }
  return result;
}
```

## 手写浅拷贝

当我们需要对一个对象进行拷贝时，可以使用浅拷贝来复制对象的属性。浅拷贝只会复制对象的第一层属性，而不会递归地复制对象的子属性。

```Js
function shallowCopy(obj) {
  //如果传入的不是对象或者是null，直接返回
  if (typeof obj !== 'object' || obj === null) {
    return obj;
  }
  //根据对象类型创建新的对象
  const result = Array.isArray(obj) ? [] : {};
  //遍历原对象的属性并将其复制到新对象中。
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      result[key] = obj[key];//只会复制对象的第一层属性
    }
  }
  return result;
}
```

在上面的代码中，我们首先判断传入的参数是否为对象，如果不是对象则直接返回。然后根据对象的类型创建一个新的对象，遍历原对象的属性并将其复制到新对象中，最后返回新对象。

需要注意的是，浅拷贝只会复制对象的第一层属性，如果对象的属性值是一个对象或数组，则只会复制其引用，而不会复制其内容。如果需要递归地复制对象的子属性，可以使用深拷贝函数。

## 简单介绍下发布订阅模式

> 发布订阅模式是一种常用的设计模式，用于解决对象之间的通信问题。在发布订阅模式中，发布者对象和订阅者对象之间通过一个消息队列进行通信。发布者对象将消息发布到消息队列中，订阅者对象从消息队列中订阅消息。
>
> 发布订阅模式中，发布者对象和订阅者对象之间是一对多的关系，一个发布者对象可以有多个订阅者对象，而且订阅者对象之间也可以相互订阅。当发布者对象发布消息时，所有订阅者对象都会收到这个消息，并进行相应的处理。
>
> 发布订阅模式的优点是，可以实现对象之间的松耦合，从而提高系统的可扩展性和可维护性。同时，发布订阅模式也可以实现异步通信，从而提高系统的性能和响应速度。
>
> 需要注意的是，发布订阅模式也有一些缺点，如可能会导致代码的复杂度增加，因为需要考虑消息队列的管理和维护等问题。同时，发布订阅模式也可能会导致系统的可靠性降低，因为消息可能会丢失或重复发送。因此，在使用发布订阅模式时，需要根据具体的业务需求和场景进行权衡和选择。

### 前端的发布订阅模式用在哪？

> 前端的发布订阅模式可以用在以下场景：
>
> 1. **事件系统**：浏览器中的事件系统就是一种发布订阅模式，当事件触发时，所有订阅该事件的回调函数都会被执行。
> 2. **组件通信**：在组件化开发中，可以使用发布订阅模式来实现组件之间的通信，当一个组件的状态发生变化时，可以发布一个事件，其他组件可以订阅该事件并进行相应的处理。
> 3. **模块化开发**：在模块化开发中，可以使用发布订阅模式来实现模块之间的通信，当一个模块的状态发生变化时，可以发布一个事件，其他模块可以订阅该事件并进行相应的处理。
> 4. **异步编程**：在异步编程中，可以使用发布订阅模式来实现异步任务的回调函数管理，当异步任务完成时，可以发布一个事件，所有订阅该事件的回调函数都会被执行。

### 手写发布订阅模式

```js
class EventEmitter {
  constructor() {
    this.events = {};
  }

  on(eventName, listener) {
    if (!this.events[eventName]) {
      this.events[eventName] = [];
    }
    this.events[eventName].push(listener);
  }

  emit(eventName, ...args) {
    if (this.events[eventName]) {
      this.events[eventName].forEach(listener => {
        listener.apply(this, args);
      });
    }
  }

  off(eventName, listener) {
    if (this.events[eventName]) {
      this.events[eventName] = this.events[eventName].filter(l => l !== listener);
    }
  }
}

// 使用示例
const eventEmitter = new EventEmitter();

// 订阅事件
eventEmitter.on('click', () => {
  console.log('click event triggered');
});

// 发布事件
eventEmitter.emit('click');

// 取消订阅事件
const listener = () => {
  console.log('custom listener');
};
eventEmitter.on('custom', listener);
eventEmitter.off('custom', listener);
```

## 说说你对“高内聚，低耦合"的理解

“高内聚，低耦合”是一种软件设计原则，它的核心思想是将系统分解成多个独立的模块，每个模块都应该具有高内聚性和低耦合性。

高内聚性指的是模块内部的各个元素之间紧密相关，共同完成一个特定的功能。一个具有高内聚性的模块应该尽可能地将相关的元素放在一起，以便于维护和修改。例如，在一个负责处理用户登录的模块中，应该只包含与用户登录相关的代码，而不应该包含其他无关的代码。

低耦合性指的是模块之间的依赖关系尽可能地少，每个模块都应该尽可能地独立。一个具有低耦合性的模块应该只依赖于必要的其他模块，而不应该依赖于不必要的模块。例如，在一个负责处理用户登录的模块中，应该只依赖于与用户登录相关的模块，而不应该依赖于其他无关的模块。

**高内聚和低耦合是相辅相成的，它们可以互相促进**。如果一个模块具有高内聚性，那么它的各个元素之间紧密相关，共同完成一个特定的功能，这样可以减少模块之间的依赖关系，从而实现低耦合性。如果一个模块具有低耦合性，那么它的依赖关系尽可能地少，每个模块都应该尽可能地独立，这样可以使模块更加易于理解、修改和维护，从而实现高内聚性。

在软件设计和开发过程中，遵循“高内聚，低耦合”原则可以提高软件系统的可维护性、可扩展性和可重用性。同时，也可以使系统更加灵活、可靠和易于维护。

### 在vue组件的设计上，怎么应用高内聚和低耦合的理念？

在 Vue 组件的设计中，可以通过以下方式应用高内聚和低耦合的理念：使用插槽可以使组件更加灵活和可配置

属性和数据传递：通过属性的方式进行、功能设计：尽量只实现一个功能、避免在组件内部调用其他组件的方法，而是通过事件的方式通信；组件拆分：复杂组件拆分成多个子组件，每个子组件实现一个功能。插槽和作用域插槽

1. **属性和数据传递**：组件之间的数据传递应该尽量通过属性的方式进行，而不是直接访问其他组件的数据。同时，应该尽量避免使用全局变量和单例模式等方式共享数据，以降低组件之间的耦合度。
2. **功能设计**：组件应该尽量只实现一个功能，而不是将多个功能混合在一起。这样可以提高组件的内聚性，使其更加独立和可重用。同时，应该尽量避免在组件内部直接调用其他组件的方法，而是通过事件的方式进行通信。
3. **组件拆分**：对于复杂的组件，可以将其拆分成多个子组件，每个子组件只实现一个功能。这样可以提高组件的内聚性和可重用性，同时也可以降低组件之间的耦合度。
4. **插槽和作用域插槽**：使用插槽和作用域插槽可以使组件更加灵活和可配置，同时也可以降低组件之间的耦合度。通过插槽和作用域插槽，可以将组件的样式和行为与具体的数据分离开来，使其更加独立和可重用。

总之，在 Vue 组件的设计中，应该尽量追求高内聚和低耦合的平衡，既要保证组件内部的紧密联系，又要保证组件之间的松散耦合。这样可以提高组件的可维护性、可扩展性和可重用性。

## vue3面试题

1. Vue3 与 Vue2 有哪些不同之处？
2. Vue3 中的 Composition API 是什么？它有什么优点？
3. Vue3 中的数据双向绑定是如何实现的？
4. Vue3 中的响应式系统是如何工作的？
5. Vue3 中的 Teleport 组件是什么？它有什么作用？
6. Vue3 中的 Suspense 组件是什么？它有什么作用？
7. Vue3 中的 Fragments 是什么？它有什么作用？
8. Vue3 中的 v-model 指令与 Vue2 有何不同？
9. Vue3 中的 setup 函数是什么？它有什么作用？
10. Vue3 中的 provide 和 inject API 是什么？它们有什么作用？

1. 什么是闭包？它有什么作用？
2. 什么是原型链？它有什么作用？
3. 什么是事件冒泡和事件捕获？它们有什么区别？
4. 什么是跨域？如何解决跨域问题？
5. 什么是异步编程？如何实现异步编程？
6. 什么是 Promise？它有什么作用？
7. 什么是 async/await？它们有什么作用？
8. 什么是 MVC、MVP 和 MVVM？它们有什么区别？
9. 什么是单向数据流？它有什么作用？
10. 什么是 Virtual DOM？它有什么作用？

## 面试自我介绍

大家好，我是 [你的名字]，很高兴来参加这次面试。我是一名前端工程师，有 [你的工作经验] 年的前端开发经验。我熟练掌握 HTML、CSS 和 JavaScript，并且熟悉常用的前端框架和库，如 Vue、React、jQuery 等。

在我的工作中，我主要负责 [你的工作职责]，并且积累了一定的项目经验。我喜欢学习新技术和解决问题，对前端开发有着浓厚的兴趣。我也喜欢和团队成员合作，共同完成项目并取得成功。

除了技术方面，我还注重自己的软实力，如沟通能力、团队协作能力和学习能力等。我相信这些能力对于一个前端工程师来说同样重要。

感谢您的时间，我期待能够加入贵公司并为其做出贡献。谢谢！

## 你上一家的薪资是多少？

关于上一家公司的薪资，我认为这并不是一个很好的参考，因为每个公司的薪资结构和福利待遇都不同。我更希望能够根据我的技能和经验来确定薪资水平。

## 你的期望薪资是多少？

关于期望薪资，我希望能够得到一个公平合理的薪资待遇，同时也考虑到公司的薪资结构和市场行情。我相信在我们进一步了解彼此之后，我们可以达成一个满意的协议。

> 需要注意的是，面试中的薪资问题可能比较敏感，你可以尽量避免直接回答具体的数字，而是强调你更关注于公平合理的薪资待遇，并且愿意在双方了解清楚情况后进行商讨。

## 说说你的优点和缺点

关于我的**优点**，我认为我有以下几个方面的优势：

1. [优点1]：例如，我有很强的学习能力和自我驱动力，能够快速适应新的技术和工作环境。
2. [优点2]：例如，我注重细节和质量，能够保证工作的准确性和高效性。
3. [优点3]：例如，我善于沟通和协作，能够与团队成员和客户保持良好的关系。

关于我的**缺点**，我也意识到自己有一些需要改进的地方：

1. [缺点1]：例如，我有时候会过于追求完美，导致工作进度有些缓慢。
2. [缺点2]：例如，我有时候会过于紧张和焦虑，需要更好地控制情绪。
3. [缺点3]：例如，我有时候会过于独立思考，需要更好地倾听他人的意见和建议。

需要注意的是，回答这个问题时，要注意**突出自己的优点**，同时也要坦诚地承认自己的缺点，并且表现出改进的意愿。同时，也要注意不要说出过于严重或者与工作无关的缺点，以免给 HR 留下不好的印象。

## 开放性问题

1. **你在前端项目中遇到最大的难题是什么，你是怎么解决的？**

   1. 后台页面中很多涉及到表单提交和表单展示，涉及到常用的一些表单控件，比如input输入框、下拉选择、日期选择等，页面做起来需要写的标签很多都是重复的，而且表单内容一旦多了，标签代码写起来就很多且很容易乱，这些重复的代码严重降低了开发效率，所以我针对这个情况封装了**配置式表单组件**，就是在JS中定义需要渲染的表单组件列表，每个组件用一个对象进行描述，比如组件的类型`type:'input'`，`label`,`name`,`rules`，等属性，组件内部自动会生成校验规则，数据双向绑定等。

      最后组件做完后，还遇到一个代码提示的问题，想要的效果是参照antd Vue组件，在鼠标放到组件属性上会显示可选值，在输入属性后也会有可选的代码提示。本来以为这个功能只要用ts定义了属性接口就能自动会有提示，但是实际发现并不行。为了实现这个代码提示功能，我去翻了好几遍的antd Vue的组件源码，终于发现了一些蛛丝马迹：原来vue提供了一个定义组件的ts泛型：**`DefineComponent`**，如果要实现属性的代码提示，就要在第11个参数写入组件的props定义。

   2. 项目最初是使用Vite2.6版本，这个Vite在开发环境的项目启动是很快，但是在开发环境下页面切换时需要几秒钟甚至10秒的时间，原因是因为使用了import动态导入组件，当页面切换时浏览器会请求这个组件，等待组件加载完后才会页面切换成功。这个等待的过程过长导致开发体验很不好，针对这个问题，我编写了一个**页面预加载的Vite插件**，这个插件的主要功能是解析在使用import 引入组件时加了`proload`关键字的组件，会添加到预加载队列，在项目首次启动时，会提前把这些组件加载，等用户切换页面时如果这个组件加载过，浏览器就会使用缓存加载，只需要十几毫秒，页面加载的速度也就实现秒加载了。
   3. **实现多账号管理功能**。需求是这样的：需要在客户端中同时登录和管理某个平台的多个账号，正常的浏览器登录一个网站后，再打开多个页面，都是同一个登录的用户。但是这个需求要求可以同时登录多个账号，刚开始听着这个需求挺难实现的，后面我就到处搜相关的文档和文章，也有在知乎、掘金上咨询过别人，最终总结出有两种方法可以实现，第一种是使用electron的新建BrowserView，但是这个方法会有层级问题，而且比较笨重，最终选了第二种，使用`webview`标签，每个标签加载一个网页，同时我翻阅了官方文档，找到了可以对webview进行环境隔离的方法，结合之前调研的平台都是使用cookies保存登录用户信息的，最终实现了webview之间cookies独立管理，这样每个页面相当于一个独立的浏览器，自然可以登录不同账户，实现多账号管理的功能了。

2. **你在前端开发中遵循哪些最佳实践和规范？你是如何确保代码的质量和可维护性的？**

   1. 使用模块化的开发方式，将代码分解为小的、可重用的模块，方便维护和测试。
   2. 遵循单一职责原则，确保每个组件和函数只负责一项功能，避免代码耦合和混乱。
   3. 使用代码格式化工具和代码风格规范，确保代码的一致性和可读性。
   4. 使用版本控制工具，如 Git，管理代码的版本和变更历史，方便团队协作和代码回滚。
   5. 使用代码分析工具，如 ESLint 或 TSLint，检查代码的质量和规范性，避免常见的错误和漏洞。

3. **你在前端开发中遇到过哪些性能问题？你是如何优化的？**

   在前端开发中，我遇到过的一个性能问题是页面加载速度过慢。当页面中包含大量的图片、视频或者其他资源时，会导致页面加载时间过长，影响用户的体验。

   为了解决这个问题，我采取了以下优化措施：

   1. 压缩和优化图片、视频等资源，减小文件大小，提高加载速度。
   2. 使用懒加载技术，将页面中的图片、视频等资源延迟加载，减少页面的初始加载时间。
   3. 使用 CDN 加速服务，将静态资源缓存到 CDN 中，提高资源的访问速度。
   4. 使用浏览器缓存，将静态资源缓存到浏览器中，减少重复加载的次数。

## 移动端适配问题你是怎么处理的?

在移动端适配方面，我采用了以下方法：

1. 使用flex弹性盒子布局。
2. 使用 rem 或者 vw/vh 等单位，避免使用固定的像素值。

3. 使用响应式布局，根据不同的屏幕尺寸和设备类型，自适应调整页面的布局和样式。
4. 使用 viewport 和媒体查询等技术，适配不同的屏幕尺寸和设备像素密度，确保页面在不同设备上的显示效果一致。

## rem + vh适配方案

> 参考资料：https://blog.csdn.net/zshake/article/details/111385716
>
> [大厂是怎么做移动端适配的](https://mp.weixin.qq.com/s/Pzm1ZM6jgJEcGwWVVRYuIg)
>
> [为什么说移动端该放弃rem适配方案了？](https://www.toutiao.com/article/7251157789862052408/?app=news_article&timestamp=1688384209&use_new_style=1&req_id=202307031936482B508CC45213B2271A33&group_id=7251157789862052408&wxshare_count=1&tt_from=weixin&utm_source=weixin&utm_medium=toutiao_android&utm_campaign=client_share&share_token=9f34c445-065b-432e-8759-b7fc3bb5e0b2&source=m_redirect&wid=1688440029944)
>
> [移动端适配(转载) - 掘金 (juejin.cn)](https://juejin.cn/post/7248249730479456313)

第一步：元素大小单位选用rem。

第二步：根据设计稿的屏幕宽度设置html的font-size大小，且单位用vw。

第三步：通过media query设置html根font-size的最大最小px值。

**例**：假设设计稿是1200px的屏幕，第一二步的效果将是：

1200px宽度的屏幕，html的font-size设为1vw，p标签设为1rem，则为***12px\***实际大小；

1800px宽度的屏幕，html的font-size设为1vw，p标签设为1rem，则为***18px***实际大小；

如果IPhone6屏幕宽度是**375px**(独立像素)，p标签1rem的话，实际大小就只有3.75px了。虽然谷歌浏览器做了最小字号限制（12px)

下面开始根据设计稿进行代码适配：

1. **px与vw换算**:  因为设计稿是**750px**，IPhone6是2DPR，独立像素只有一半：**375px**，把html的font-size设为1vw，得到1rem = 3.75px，把浏览器最小字号12px进行比较得出: **12 / 3.75 = 3.2vw**，也就是说在最小字号情况下:**12px = 3.2vw**

2. **与设计稿的字号进行放大换算vw** : 查看设计稿中普通文字字号是多少，比如设计稿上大部分文字都是用20px，那么就以20px为基准。用20px和最小字号12px对比，看放大的倍数是多少：20/12 = 1.66666667

3. 用放大的倍数 1.666667 * 3.2 = 5.3333333vw

> 以上就是我分析京东移动端得出的分析计算过程

```css
html {
    font-size: 20px;
    font-size: 5.33333vw
}

@media screen and (max-width: 320px) {
    html {
        font-size:17.06667px
    }
}

@media screen and (min-width: 540px) {
    html {
        font-size:28.8px
    }
}

 @media screen and (min-width: 1080px) {
    html {
        font-size:57.6px
    }
}
```



## 手写防抖函数

```js
const Debounce = (fn, delay = 300) => {
  let timer = null // 存储唯一setTimeout状态
  return args => {
    const self = this // 事件源this
    clearTimeout(timer) 
      timer = setTimeout(() => {
        fn.apply(self, [args])
      }, delay)
  }
}

export default Debounce
```

使用方法：

```js
function handleInput() {
  console.log('输入事件被触发');
}

const debouncedInput = debounce(handleInput, 300);

document.getElementById('inputField').addEventListener('input', debouncedInput);
```

## 手写节流函数

```js
let timer, flag;
/**
 * 节流原理：在一定时间内，只能触发一次
 * 
 * @param {Function} func 要执行的回调函数 
 * @param {Number} delay 延时的时间
 * @return function
 */
function throttle(func, delay) {
  let isThrottled = false;
  
  return function() {
    const context = this;
    const args = arguments;
    
    if (!isThrottled) {
      func.apply(context, args);
      isThrottled = true;
      
      setTimeout(function() {
        isThrottled = false;
      }, delay);
    }
  }
}

```

使用示例：

```js
function handleScroll() {
  console.log('滚动事件被触发');
}

const throttledScroll = throttle(handleScroll, 300);

window.addEventListener('scroll', throttledScroll);

```

## 谈谈你对闭包的理解

![image-20230627020236671](https://s2.loli.net/2023/06/27/zswl1UkPbxNEfD5.png)

闭包是指函数内部的一个函数可以访问到外部函数的变量和参数，即使外部函数已经执行完毕。闭包形成了一个包含函数和其引用环境的闭包（closure）。

闭包的特点和作用如下：

1. 保护变量：闭包可以创建私有变量，在外部无法访问。这样可以避免全局变量污染和命名冲突。
2. 延长变量的生命周期：当外部函数执行完毕后，其内部函数仍然可以访问外部函数的变量。这样可以实现在外部函数执行完毕后，仍然可以操作外部函数的变量。
3. 实现模块化：闭包可以创建私有方法和属性，模拟类和对象的概念，实现封装和继承等面向对象的特性。
4. 在异步编程中的应用：通过闭包可以保存异步操作过程中的上下文信息，避免回调函数丢失上下文。
5. 优化性能：闭包可以避免重复创建函数，提高代码的执行效率。

需要注意的是，闭包会占用内存，如果闭包过多或者闭包中包含大量的变量和对象，则可能会导致内存泄漏。因此，在使用闭包时，需要注意及时释放不再使用的闭包，避免造成性能问题。

> 答案二：
> 		闭包是指一个函数可以访问并操作其外部函数作用域中的变量，即使外部函数已经返回并且其作用域已经销毁。闭包可以用于创建私有变量和方法，以及实现模块化的代码结构。在JavaScript中，每个函数都是一个闭包，因为它们都可以访问其外部作用域中的变量。闭包的使用需要注意内存泄漏的问题，因为闭包会一直持有其外部作用域中的变量，导致这些变量无法被垃圾回收。

> 答案三：
>
> 闭包是指在一个函数内部定义的函数，可以访问该函数的局部变量和参数，即使该函数已经返回，闭包仍然可以访问这些变量和参数。闭包可以用来实现数据的私有化、函数的柯里化、模块化等功能。
>
> 在 JavaScript 中，每个函数都是一个闭包，因为它们都可以访问自己的局部变量和参数。当一个函数返回时，它的局部变量和参数通常会被销毁，但是如果该函数返回了一个内部函数，那么这个内部函数就可以访问该函数的局部变量和参数，形成了一个闭包。
>
> 闭包的作用域链是由内向外查找的，即先在自己的作用域中查找变量，如果没有找到，就会向上一级作用域中查找，直到找到为止。因此，闭包可以访问外部函数的变量和参数，但是外部函数不能访问内部函数的变量和参数。
>
> 需要注意的是，闭包会占用内存，因为它会保留外部函数的作用域链，如果闭包过多或者不合理使用，会导致内存泄漏和性能问题。因此，在使用闭包时，需要注意内存管理和性能优化。

## 闭包的应用-函数柯里化

> 函数柯里化是指将一个接受多个参数的函数转化为一系列只接受单个参数的函数的过程。柯里化可以使函数更加灵活和可复用，可以用来实现函数的复合、延迟执行等功能。
>
> 在 JavaScript 中，函数柯里化通常使用闭包来实现。具体来说，柯里化函数会返回一个新的函数，这个新函数会接受第一个参数，并返回一个新的函数，这个新函数会接受第二个参数，以此类推，直到所有参数都被接受完毕，最后返回最终的结果。

### 参数复用

下面是一个简单的柯里化示例，实现了一个加法函数的柯里化：

```js
function add(x) {
  return function(y) { 
    return x + y;
  };
}

// 使用柯里化的加法函数
const add5 = add(5);
console.log(add5(3)); // 输出 8
console.log(add5(7)); // 输出 12
```

在上面的示例中，我们定义了一个 `add` 函数，它接受一个参数 `x`，返回一个函数，这个函数接受一个参数 `y`，返回 `x + y` 的结果。然后，我们使用 `add(5)` 得到一个新的函数 `add5`，它只需要一个参数 `y`，返回 `5 + y` 的结果。这样，我们就可以通过 `add5` 来实现多次加 5 的操作。

需要注意的是，柯里化可以使函数更加灵活和可复用，但是也会增加代码的复杂度和理解难度。因此，在使用柯里化时，需要根据实际情况来决定是否使用，避免过度使用导致代码难以维护。

### 防抖

```js
function debounce(fn, delay) {
  let timer = null;
  return function(...args) {
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}

function handleClick() {
  console.log('click');
}

const debounceClick = debounce(handleClick, 1000);
document.addEventListener('click', debounceClick);
```

### 函数复合

```js
function compose(...fns) {
  return function(x) {
    return fns.reduceRight((acc, fn) => {
      return fn(acc);
    }, x);
  };
}

function add1(x) {
  return x + 1;
}

function double(x) {
  return x * 2;
}

const add1AndDouble = compose(double, add1);
console.log(add1AndDouble(5)); // 输出 12
```

在上面的示例中，我们定义了一个 `compose` 函数，它接受多个函数，返回一个新的函数，这个新函数会将多个函数组合起来，形成一个函数管道。然后，我们定义了两个函数 `add1` 和 `double`，分别实现加 1 和乘 2 的功能。最后，我们使用 `compose` 函数将 `add1` 和 `double` 函数组合成一个新的函数 `add1AndDouble`，它会先将输入加 1，再将结果乘 2，最终返回结果。

## TypeScript面试题

1. TypeScript是什么？它和JavaScript有什么区别？

   > TypeScript是一种开源的编程语言，它是JavaScript的超集，通过添加静态类型检查等功能来增强JavaScript。与JavaScript相比，TypeScript具有更严格的类型系统、更好的IDE支持和更多的工具。

2. 在TypeScript中，什么是类型注解？

   > 类型注解是在变量、函数参数、函数返回值等位置给出类型信息的一种方式。通过类型注解，可以明确指定变量的类型，从而提高代码的可读性和安全性。

3. TypeScript中的接口（interface）和抽象类（abstract class）有什么区别？

   > 接口是一种约束对象结构的方式，它定义了对象应该包含的属性和方法。抽象类是一种抽象的类，它可以包含抽象方法和具体方法。一个类可以实现多个接口，但只能继承一个抽象类。

4. 什么是泛型（Generics）？它在TypeScript中的作用是什么？

   > 泛型是一种在定义函数、类或接口时使用类型变量的方式。它可以增加代码的可重用性和灵活性，使代码可以处理多种类型的数据。

5. 请解释TypeScript中的模块（module）和命名空间（namespace）的概念。

   > 模块是一种组织和封装代码的方式，它可以将相关的代码和类型定义放在一起。命名空间是一种防止全局命名冲突的方式，它将相关的代码封装在一个独立的命名空间中。

6. TypeScript中的装饰器（decorators）是什么？它有什么作用？

   > 装饰器是一种特殊类型的声明，它可以附加到类声明、方法、属性或参数上，用于修改它们的行为。装饰器可以用于实现元编程和实现一些横切关注点，例如日志记录和性能监控。

7. 请解释TypeScript中的声明文件（declaration files）是什么，如何使用它们？

   > 声明文件是一种描述JavaScript库或模块的类型信息的文件，它用于在TypeScript中使用这些库或模块时进行类型检查和代码提示。声明文件的文件名通常以".d.ts"为后缀，可以手动编写或通过工具自动生成。

8. 什么是类型推断（type inference）？在什么情况下可以使用类型推断？

   > 类型推断是TypeScript编译器根据上下文推断出变量或表达式的类型的过程。在没有明确指定类型的情况下，编译器会根据赋值的表达式或函数返回值的类型推断出变量的类型。

9. TypeScript中的可选属性（optional property）和只读属性（readonly property）有什么区别？

   > 可选属性是指在接口或类型中定义的属性，可以有或没有。只读属性是指只能在对象初始化或构造函数中设置值的属性，之后不能修改。

10. 如何在TypeScript中定义一个枚举（enum）类型？

    > 枚举是一种有限集合的值的数据类型。在TypeScript中，可以使用关键字"enum"来定义枚举类型，并通过枚举成员来表示具体的值。

11. TypeScript中的命名空间（namespace）如何使用和组织代码？

    > 命名空间是一种将相关的代码组织在一起的方式，它可以避免全局命名冲突。可以使用"namespace"关键字定义命名空间，在命名空间中可以定义类、函数、变量等。

12. 请解释TypeScript中的交叉类型（intersection types）和联合类型（union types）。

    > 交叉类型表示同时具备多种类型的值，可以使用"&"运算符进行类型合并。联合类型表示一个值可以是多种类型之一，可以使用"|"运算符进行类型合并。

13. 什么是类型保护（type guards）？在什么情况下可以使用类型保护？

    > 类型保护是一种在特定条件下判断变量的类型的方式，以便在代码中使用该类型的特定功能。可以使用"typeof"、"instanceof"、"in"等方式进行类型保护。

14. TypeScript中的异步编程如何处理？请解释async/await的使用。

    > TypeScript中的异步编程可以使用Promise、async/await等方式处理。async/await是一种基于Promise的语法糖，可以使异步代码的编写和理解更加简洁。

15. 请解释TypeScript中的声明合并（declaration merging）是什么，如何使用它？

    > 声明合并是指当声明多个相同名字的接口、函数或类时，它们会合并为一个声明。这种合并可以用于扩展现有的类型定义，或者将多个声明组合成一个更完整的声明。

# 公司1笔试题

## x.y.z版本新旧对比

有一个函数`compareVersion(newV,oldV)`，传入新旧两个版本号进行对比，返回新的版本号，版本号格式固定为：x.y.z。

```js
function compareVersion(newV, oldV) {
  const newVersion = newV.split('.').map(Number);
  const oldVersion = oldV.split('.').map(Number);
  for (let i = 0; i < 3; i++) {
    if (newVersion[i] > oldVersion[i]) {
      return newV;
    } else if (newVersion[i] < oldVersion[i]) {
      return oldV;
    }
  }
  return newV;
}
compareVersion('1.2.3', '1.2.4')
```

> 由于 `map()` 方法会对数组中的每个元素都执行一次回调函数，因此我们可以直接将 `Number` 函数作为回调函数传入 `map()` 方法中，这样可以更加简洁和方便。因此，我们可以使用 `map(Number)` 来将字符串类型的版本号数组转化为数字类型的版本号数组。
>
> - 只判断大于或小于的情况，相等时不作判断，默认返回newV

## this指向相关问题

建议把下面每一道题都运行看一遍

```js
var myname = 'lili'
const obj = {
  myname: 'Alice',
  sayName() {
    myname = 'Bob';
    console.log(this.myname);
  }
};
const sayName = obj.sayName;
console.log(myname);//lili
sayName(); // Bob
```

```js
var myname = 'lili'
const obj = {
  myname: 'Alice',
  sayName() {
    console.log(this.myname);
  }
};
const sayName = obj.sayName;
sayName(); // lili
obj.sayName(); // Alice
```

```js
var myname = 'lili'
const obj = {
  name: 'Alice',
  sayName() {
    console.log(this.name);
  }
};
const sayName = obj.sayName;
console.log(window.myname); // lili
sayName(); // undefined 空
```

```js
const obj = {
  name: 'Alice',
  sayName() {
    console.log(this.name);
  }
};
const sayName = obj.sayName.bind(obj);
sayName(); // Alice
```

```js
const obj1 = {
  name: 'Alice',
  sayName() {
    console.log(this.name);
  }
};
const obj2 = {
  name: 'Bob'
};
obj1.sayName.call(obj2);// Bob
```

难度升级：

```js
const obj = {
  name: 'Alice',
  friends: ['Bob', 'Charlie'],
  sayName() {
    console.log(this.name);
  },
  sayFriends() {
    this.friends.forEach(function(friend) {
      console.log(this.name + ' knows ' + friend);
    });
  }
};
obj.sayFriends();// undefined knows Bob undefined knows Charlie
```

> 输出的结果是 `undefined knows Bob` 和 `undefined knows Charlie`。这是因为在 `sayFriends()` 方法中，我们使用了一个匿名函数作为 `forEach()` 方法的回调函数，而这个匿名函数中的 `this` 指向了全局对象（在浏览器中是 `window` 对象，在 Node.js 中是 `global` 对象），因此在输出字符串时，`this.name` 的值为 `undefined`。为了解决这个问题，我们可以使用箭头函数来替代匿名函数，因为箭头函数中的 `this` 指向的是定义时所在的对象，而不是运行时所在的对象。因此，我们可以将 `sayFriends()` 方法中的匿名函数改写为箭头函数，这样在输出字符串时，`this.name` 的值就会指向 `obj` 对象的 `name` 属性，输出的结果就是我们期望的结果。

变形题：

```js
const obj = {
  name: 'Alice',
  friends: ['Bob', 'Charlie'],
  sayName() {
    console.log(this.name);
  },
  sayFriends() {
    this.friends.forEach(function(friend) {
      console.log(this.name + ' knows ' + friend);
    }.bind(this));
  }
};
obj.sayFriends(); // Alice knows Bob Alice knows Charlie
```

难度继续升级：

```js
var myname = 'lili'
function Person(name) {
  this.myname = name;
  this.sayName = function() {
    console.log(this.myname);
  };
}
const person1 = new Person('Alice');
const person2 = Person('Bob');
console.log(myname);// Bob
person1.sayName();// Alice
```

> 在创建 `person1` 对象时，我们使用了 `new` 关键字，这样 `Person` 构造函数中的 `this` 指向了新创建的对象，因此在调用 `sayName()` 方法时，函数内部的 `this` 指向了 `person1` 对象，输出了 `Alice`。
>
> 而在运行`Person('Bob')`时，Person内部的this指向全局，也就是window，同时函数外部一开始就定义了`var myname = 'lili'`，这个属性会挂载在window上，所以`this.myname= name`会把window上的`myname`覆盖，得出`console.log(myname) -> Bob`。

# 关于数据结构的问题

1. 什么是数组？

数组是一种数据结构，用于存储一组有序的数据。数组中的每个元素都有一个唯一的索引，可以通过索引来访问数组中的元素。数组可以存储任何类型的数据，包括数字、字符串、对象等。

2. 什么是栈？

栈是一种数据结构，它具有后进先出（LIFO）的特点。栈可以用数组或链表来实现，它支持两个基本操作：压入（push）和弹出（pop）。压入操作将一个元素添加到栈的顶部，弹出操作将栈顶的元素移除并返回。

3. 什么是队列？

队列是一种数据结构，它具有先进先出（FIFO）的特点。队列可以用数组或链表来实现，它支持两个基本操作：入队（enqueue）和出队（dequeue）。入队操作将一个元素添加到队列的尾部，出队操作将队列头部的元素移除并返回。

4. 什么是链表？

链表是一种数据结构，它由一系列节点组成，每个节点包含一个数据元素和一个指向下一个节点的指针。链表可以用来实现栈和队列等数据结构，它支持插入和删除操作的时间复杂度为 O(1)。

5. 什么是哈希表？

哈希表是一种数据结构，它通过哈希函数将键映射到值。哈希表可以用数组来实现，它支持常数时间的插入、删除和查找操作。哈希表的性能取决于哈希函数的质量和数组的大小，通常需要进行调整以避免哈希冲突。
