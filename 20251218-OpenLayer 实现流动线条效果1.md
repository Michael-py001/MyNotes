# 20251218-OpenLayer 实现流动线条效果1



## 动态版

- 效果图

  ![2](https://s2.loli.net/2025/12/18/jIAeXxuFnqaK5sP.gif)

- 源码

```ts
// 流动线动画管理器
import { Feature } from 'ol';
import { LineString } from 'ol/geom';
import VectorLayer from 'ol/layer/Vector';
import { Style, Stroke } from 'ol/style';
import { getVectorContext } from 'ol/render';
import type { Coordinate } from 'ol/coordinate';
import type { Map as OLMap } from 'ol';

interface FlowLineDef {
  coordinates: Coordinate[];
  width?: number;
  speed?: number; // 0-1 递增步长
  tail?: number; // 0-1 尾迹长度
  colors?: [string, string]; // [前景色, 透明色]
}

interface FlowRuntime {
  feature: Feature<LineString>;
  width: number;
  speed: number;
  tail: number;
  frontColor: string;
  fadeColor: string;
  progress: number;
  disposed: boolean;
}

export class FlowLineAnimator {
  private map: OLMap;
  private layer: VectorLayer;
  private lines: FlowRuntime[] = [];
  private listening = false;
  private running = false;
  private rafId: number | null = null;
  private minZoomLevel = 13;
  private linesVisible = false; // 新增: 线是否可见

  constructor(map: OLMap, layer: VectorLayer) {
    this.map = map;
    this.layer = layer;
    this.map.getView().on('change:resolution', () => this.handleZoomChange());
  }

  addLine(def: FlowLineDef): Feature<LineString> {
    const {
      coordinates,
      width = 4,
      speed = 0.01,
      tail = 0.15,
      colors = ['#00ffff', 'rgba(0,255,255,0)'],
    } = def;
    const feature = new Feature<LineString>({
      geometry: new LineString(coordinates),
    });
    (this.layer.getSource() as any).addFeature(feature);
    this.lines.push({
      feature,
      width,
      speed,
      tail,
      frontColor: colors[0],
      fadeColor: colors[1],
      progress: 0,
      disposed: false,
    });
    this.ensureListening();
    this.handleZoomChange();
    return feature;
  }

  removeLine(feature: Feature<LineString>) {
    const idx = this.lines.findIndex((l) => l.feature === feature);
    if (idx >= 0) {
      this.lines[idx].disposed = true;
      (this.layer.getSource() as any).removeFeature(feature);
      this.lines.splice(idx, 1);
    }
    if (this.lines.length === 0) this.stop();
  }

  clear() {
    this.lines.forEach((l) => {
      if (!l.disposed) {
        (this.layer.getSource() as any).removeFeature(l.feature);
        l.disposed = true;
      }
    });
    this.lines = [];
    this.stop();
  }

  private handleZoomChange() {
    const currentZoom = Math.floor(this.map.getView().getZoom() || 0);
    if (currentZoom >= this.minZoomLevel) {
      this.showLines(true);
      this.start();
    } else {
      this.showLines(false);
      this.stop();
    }
  }

  // 修改: 仅更新可见状态并请求重绘
  private showLines(visible: boolean) {
    if (this.linesVisible === visible) return;
    this.linesVisible = visible;
    this.layer.setVisible(visible);
    this.map.render(); // 触发一次 redraw 以立即反映可见性
  }

  private ensureListening() {
    if (this.listening) return;
    this.layer.on('postrender', (evt: any) => {
      const currentZoom = Math.floor(this.map.getView().getZoom() || 0);
      if (
        !this.running ||
        !this.linesVisible ||
        this.lines.length === 0 ||
        currentZoom < this.minZoomLevel
      )
        return;

      const vectorCtx = getVectorContext(evt);
      const frameState = evt.frameState;
      const transform = frameState.coordinateToPixelTransform;
      const ctx: CanvasRenderingContext2D = evt.context;

      const coordToPixel = (c: Coordinate) => [
        transform[0] * c[0] + transform[2] * c[1] + transform[4],
        transform[1] * c[0] + transform[3] * c[1] + transform[5],
      ];

      for (const line of this.lines) {
        if (line.disposed) continue;
        const geom = line.feature.getGeometry();
        if (!geom) continue;
        const coords = geom.getCoordinates();
        if (coords.length < 2) continue;

        const pStart = coordToPixel(coords[0]);
        const pEnd = coordToPixel(coords[coords.length - 1]);
        const grad = ctx.createLinearGradient(
          pStart[0],
          pStart[1],
          pEnd[0],
          pEnd[1],
        );

        const head = line.progress;
        const tailStart = Math.max(0, head - line.tail);
        if (tailStart > 0) grad.addColorStop(0, line.fadeColor);
        grad.addColorStop(tailStart, line.fadeColor);
        grad.addColorStop(head, line.frontColor);
        grad.addColorStop(Math.min(1, head + 0.0001), line.fadeColor);
        grad.addColorStop(1, line.fadeColor);

        vectorCtx.setStyle(
          new Style({
            stroke: new Stroke({
              color: grad,
              width: line.width,
              lineCap: 'round',
              lineJoin: 'round',
            }),
          }),
        );
        vectorCtx.drawGeometry(geom);

        line.progress += line.speed;
        if (line.progress > 1) line.progress -= 1;
      }
    });
    this.listening = true;
  }

  private start() {
    const currentZoom = Math.floor(this.map.getView().getZoom() || 0);
    if (this.running || currentZoom < this.minZoomLevel) return;
    this.running = true;
    const loop = () => {
      console.log('loop');
      if (!this.running) return;
      this.map.render();
      // this.rafId = window.requestAnimationFrame(loop);
    };
    loop();
  }

  private stop() {
    this.running = false;
    if (this.rafId !== null) {
      cancelAnimationFrame(this.rafId);
      this.rafId = null;
    }
  }
}

```

## 静态版

效果图：

![image-20251218151428048](https://s2.loli.net/2025/12/18/ipEv3rFfs2BJIxd.png)

- 源码

  ```ts
  function drawFlowLine(windFarmInfo: WindFarmGisItem[]) {
    const lineArr = windFarmInfo.filter((gisInfo) => gisInfo.gisType === 2);
    if (!lineArr.length) return;
    const lineFeatures = [];
    const lineObj = [];
    lineArr.forEach((gisInfo) => {
      const { minScaling, points, style } = gisInfo;
      let lineStyle = {} as LineStyle;
      try {
        lineStyle = JSON.parse(style!);
      } catch (e) {
        lineStyle = {
          lineWidth: 3,
          lineStyle: 'solid',
          imageUrl: '#ff1e02',
        };
      }
      const linePoints = points.map((item) => [item.longitude, item.latitude]);
      const lineFeature = mapManager?.createLine(linePoints, {
        id: gisInfo.entityId,
        style: () => {
          const zoom = mapManager?.getMap()?.getView().getZoom()!;
          if (zoom >= 13) {
            return new Style({
              stroke: new Stroke({
                color: lineStyle.imageUrl,
                width: lineStyle.lineWidth,
                lineCap: lineStyle.lineStyle,
              }),
            });
          }
          return null;
        },
        properties: {
          info: {
            ...gisInfo,
          },
          gisType: GISTYPE.SHIP_TRAIL_POINT,
        },
      });
      lineFeatures.push(lineFeature);
    });
    const source = mapManager?.getVectorSource('windFarmLayer');
    if (!source) return null;
    source.addFeatures(lineFeatures);
  }
  ```

## 代码位置

![image-20251218152904735](https://s2.loli.net/2025/12/18/odZT9wm7DiGxIF3.png)

![image-20251218152942303](https://s2.loli.net/2025/12/18/7IK4VQ9vnUHy8lP.png)



# flowLineAnimator.ts 功能详解与使用指南

本文档详细分析 `src/views/HomePage/components/map/flowLineAnimator.ts` 的作用、工作原理、公共 API、生命周期管理、性能注意事项与扩展建议，便于在 OpenLayers 地图中实现“流动线（光流/扫光）”动画效果的集成与维护。

## 一、文件概览

- 目标：在 OpenLayers 的 Vector 图层上，为折线要素绘制一个沿线“流动”的高亮扫光效果（可配置速度、尾迹长度、线宽与颜色）。
- 核心思路：
  - 将线要素添加到指定的 VectorLayer 的 source 中；
  - 通过 layer 的 `postrender` 事件，使用 `getVectorContext(evt)` 在 Canvas 层面进行自定义绘制；
  - 利用 2D Canvas 的线性渐变作为笔触颜色，结合 `progress`（头部位置）与 `tail`（尾迹长度）动态更新颜色停靠点，实现流动效果；
  - 用 `requestAnimationFrame` 驱动持续重绘；
  - 与地图缩放联动：仅在达到设定的最小缩放级别后才显示并动画。

## 二、依赖与环境

- 使用 OpenLayers 模块：
  - `Feature`, `LineString`, `VectorLayer`
  - `Style`, `Stroke`
  - `getVectorContext`（来自 `ol/render`，用于在渲染周期内进行自定义绘制）
  - `Coordinate`, `Map as OLMap`
- Canvas 2D API：
  - `CanvasRenderingContext2D.createLinearGradient(...)` 用于生成沿线方向的颜色渐变。

## 三、核心数据结构

- FlowLineDef：外部使用者添加一条流动线时的配置
  - `coordinates: Coordinate[]` 折线坐标序列
  - `width?: number` 线宽，默认 4
  - `speed?: number` 每帧进度增量（0-1 范围内的步长），默认 0.01
  - `tail?: number` 尾迹长度（0-1，表示占整条线的比例），默认 0.15
  - `colors?: [string, string]` 渐变的[前景色，高透明色]，默认 `['#00ffff','rgba(0,255,255,0)']`

- FlowRuntime：内部运行时状态
  - `feature: Feature<LineString>` 线要素
  - `width, speed, tail, frontColor, fadeColor` 对应外部配置
  - `progress: number` 头部位置（0-1）
  - `disposed: boolean` 回收标记

## 四、类 FlowLineAnimator API

### 1) 构造函数

```ts
constructor(map: OLMap, layer: VectorLayer)
```

- 绑定地图与目标图层，并监听 `view.change:resolution`（缩放变化）以控制显示与动画开关。
- 内置阈值 `minZoomLevel = 13`，小于该层级时停止动画并隐藏效果。

### 2) 公共方法

- `addLine(def: FlowLineDef): Feature<LineString>`
  - 创建并添加一条流动线。将 feature 加入 `layer.getSource()`，注册到内部运行时列表，确保已监听渲染事件，并立即根据当前缩放处理可见性/动画。
  - 返回创建的 `Feature`，以便后续移除或外部管理。

- `removeLine(feature: Feature<LineString>): void`
  - 从内部列表与图层 source 中移除指定线。如果不存在其它线，则自动停止动画循环。

- `clear(): void`
  - 清空所有流动线（从 source 移除，并标记为已回收），并停止动画。

### 3) 私有方法（关键逻辑）

- `handleZoomChange(): void`
  - 读取当前 `view.getZoom()`（取整），当 `>= minZoomLevel`：显示并启动动画；否则：隐藏并停止。
- `showLines(visible: boolean): void`
  - 仅更新内部 `linesVisible` 状态，并主动触发 `map.render()` 以立刻反映可见性变化（不直接更改图层可视性）。

- `ensureListening(): void`
  - 仅注册一次 `postrender`。
  - 在 `postrender` 回调中：
    - 若非运行中、不可见、无数据或未达缩放级别则直接返回；
    - 获取渲染上下文 `vectorCtx`、画布上下文 `ctx` 与坐标到像素的仿射变换矩阵；
    - 按每条线：
      - 取几何坐标，少于两点时跳过；
      - 将首尾坐标转换为像素点 `(pStart, pEnd)`，基于这两点创建线性渐变；
      - 按 `tail` 和 `progress` 计算颜色停靠点（详见下一节），构造 `Style(Stroke)` 并 `vectorCtx.drawGeometry(geom)`；
      - 更新 `progress += speed`，超过 1 回绕至 0。

- `start(): void`
  - 若已在运行或未达缩放阈值则返回；
  - 进入帧循环：每帧调用 `map.render()` 触发 `postrender`，用 `requestAnimationFrame` 驱动。

- `stop(): void`
  - 标记停止并取消 `requestAnimationFrame`。

### 4) 内部成员状态

- `lines: FlowRuntime[]` 所有流动线的运行时数据。
- `listening: boolean` 是否已注册过 `postrender`。
- `running: boolean` 是否正在动画帧循环中。
- `rafId: number | null` 帧循环的 RAF 句柄。
- `minZoomLevel = 13` 缩放阈值（固定常量，当前未暴露 setter）。
- `linesVisible: boolean` 逻辑可见状态（并非图层的 `visible` 开关）。

## 五、渲染与动画原理

### 1) postrender 中的绘制流程

- `postrender` 发生在图层自身样式绘制之后，通过 `getVectorContext` 可以继续在同一 Canvas 上绘制自定义内容。
- 代码通过 `vectorCtx.setStyle(...)` 设置描边样式（包含渐变笔触与线宽、端点/连接圆角），随后 `drawGeometry(geom)` 以当前样式绘制整条线。

注意：该实现将 feature 加入了图层的 source，但未在此类中设置图层默认样式。如果图层本身已有样式，可能出现“图层默认样式 + 自定义渐变样式”被绘制两次的情况。建议在使用时将该图层的样式设为透明或禁用，确保仅显示动画效果。

### 2) 渐变色计算（progress/tail/colors）

- `progress` 表示“光头”在整条线（归一化到 0-1）的当前位置；
- `tail` 表示尾迹长度（0-1），从 `tailStart = max(0, progress - tail)` 开始向前渐隐；
- 颜色停靠点设置：
  - 若 `tailStart > 0`，在 0 与 `tailStart` 都是淡色（`fadeColor`）；
  - `tailStart` 到 `progress` 为前景色（`frontColor`）；
  - `progress` 到 `progress + ε`（极小量）回到淡色，形成锐利的头部边界；
  - 1 的位置为淡色。
- 渐变的方向由线的首尾像素点 `(pStart, pEnd)` 决定。这意味着对“弯曲的折线”，渐变方向是直线近似（首尾连线方向），并非沿每一段折线局部切线方向。

### 3) 帧循环与 map.render

- `start()` 使用 `requestAnimationFrame` 启动循环，每帧调用一次 `map.render()`；
- 这会触发目标图层的 `postrender` 执行，继而推进 `progress` 并重绘渐变；
- 当 `stop()` 被调用或缩放低于阈值时，暂停循环并取消 RAF。

提示：`speed` 为“每帧步长”，非与时间解耦。高刷新率设备上动画会更快。可考虑改为基于时间差的速度更新（见“扩展建议”）。

### 4) 缩放联动

- 通过监听 `view.change:resolution`，在缩放变化时检查 `getZoom()`：
  - Zoom >= 13：显示并启动动画；
  - Zoom < 13：隐藏并停止动画；
- `showLines` 仅改变内部可见标记并 `map.render()`，不更改图层 `visible`，避免影响其它逻辑。

## 六、生命周期与内存管理

- 事件监听：`ensureListening()` 仅注册一次 `postrender`。类生命周期内持续有效，不重复绑定，避免泄漏。
- 资源回收：
  - `removeLine` 会从图层 source 与内部列表中移除，并在无剩余线时停止动画；
  - `clear` 批量移除并停止；
- RAF 管理：`stop()` 取消 RAF，防止后台空转。

## 七、使用示例

```ts
// 假设已创建 map 与一个专用于动画的 vectorLayer（建议无样式或透明样式）
import VectorSource from 'ol/source/Vector';
import VectorLayer from 'ol/layer/Vector';
import { FlowLineAnimator } from './flowLineAnimator';

const source = new VectorSource();
const layer = new VectorLayer({ source });
// 可考虑：layer.setStyle(() => null); // 避免双重绘制

const animator = new FlowLineAnimator(map, layer);

// 添加到地图
map.addLayer(layer);

// 添加一条流动线
animator.addLine({
  coordinates: [
    [120.1, 30.2],
    [120.2, 30.25],
    [120.35, 30.3],
  ],
  width: 5,
  speed: 0.02, // 每帧 0.02 的进度
  tail: 0.2, // 20% 的尾迹
  colors: ['#00E5FF', 'rgba(0,229,255,0)'],
});

// 移除/清空
// animator.removeLine(feature);
// animator.clear();
```

使用要点：

- 建议为该动画单独准备一个 VectorLayer，并将其默认样式设为 null/透明，避免与动画重复绘制。
- `speed` 与设备刷新率相关，可根据实际观感调整。
- 动画仅在缩放级别 >= 13 时生效，如需其它阈值请修改类内常量或扩展 setter。

## 八、性能与注意事项

- 多线渲染：每帧对每条线计算渐变并绘制，线数量大时可能影响性能。可以：
  - 合理控制 `lines` 数量；
  - 降低 `width` 或缩短 `tail`；
  - 在缩放较低时自动停用（已内置）。
- 双重绘制风险：若图层已有样式，同一要素既被默认样式画一次，又被自定义动画再画一次。建议将图层样式设为 null 或专门使用“动画层”。
- 渐变方向：使用首尾像素点创建线性渐变，对强弯曲折线效果可能不如“沿线参数化渐变”自然（见局限与扩展）。
- 帧率依赖：`speed` 为每帧增量，在高刷新率屏幕上动画更快。可改造为基于时间差更新。
- 坐标到像素变换：使用 `frameState.coordinateToPixelTransform`（包含缩放/旋转/平移），在地图旋转时仍能正确计算像素位置。

## 九、可扩展性建议

- 可配置缩放阈值
  - 增加 `setMinZoomLevel(z: number)` 或构造参数注入。
- 基于时间的速度更新
  - 在 `postrender` 或 RAF 循环中使用上一帧时间戳，`progress += speed * deltaTime`，使动画与帧率解耦。
- 更贴合曲线的“沿线渐变”
  - 现实现按首尾直线方向创建渐变。若需沿折线逐段推进，可：
    - 将线按段分片，基于累计长度计算每段上的色彩；或
    - 自定义着色器（WebGLLayer/ShaderLayer）实现沿路径的流动贴图。
- 可暂停/恢复 API
  - 增加 `pause()/resume()`，在不移除线的情况下控制动画。
- 事件回调
  - 如 `onStart/onStop/onVisibleChange` 便于外部状态联动。
- 内部样式缓存
  - 当 `width/frontColor/fadeColor` 不变时，复用 `Style` 实例以减少对象创建。

## 十、已知局限

- 渐变方向为首尾直线方向，强弯折路径的流动视觉不完全沿线。
- 动画速度与帧率相关，默认实现未做时间解耦。
- `minZoomLevel` 为固定常量，需要修改源码或扩展方法才能配置。
- 需要开发者避免图层默认样式造成的重复绘制。

---

## 十一、结合代码逐步解读：流动效果是如何生成的？

下面以源码关键片段为线索，说明“流动”到底发生在何处、如何计算，并给出直观心智模型。

### 1) 帧循环驱动一切：`start()` + `requestAnimationFrame`

```ts
private start() {
  const currentZoom = Math.floor(this.map.getView().getZoom() || 0);
  if (this.running || currentZoom < this.minZoomLevel) return;
  this.running = true;
  const loop = () => {
    if (!this.running) return;
    this.map.render();   // 关键：手动触发地图重绘 -> 触发图层 postrender
    this.rafId = window.requestAnimationFrame(loop);
  };
  loop();
}
```

- 每一帧都会调用 `map.render()`，从而触发 VectorLayer 的 `postrender` 事件。真正的“流动绘制”就在 `postrender` 的回调里完成。

### 2) 在 `postrender` 中拿到 Canvas 与坐标变换

```ts
this.layer.on('postrender', (evt: any) => {
  const vectorCtx = getVectorContext(evt);
  const frameState = evt.frameState;
  const transform = frameState.coordinateToPixelTransform; // 地理坐标 -> 像素坐标
  const ctx: CanvasRenderingContext2D = evt.context; // 原生 2D 渲染上下文

  const coordToPixel = (c: Coordinate) => [
    transform[0] * c[0] + transform[2] * c[1] + transform[4],
    transform[1] * c[0] + transform[3] * c[1] + transform[5],
  ];
  // ...
});
```

- 通过 `coordinateToPixelTransform` 将地理坐标转换为当前视图下的 Canvas 像素坐标，后续的渐变是基于像素空间创建的。

### 3) 用首尾像素点定义线性渐变轴向

```ts
const geom = line.feature.getGeometry();
const coords = geom!.getCoordinates();
const pStart = coordToPixel(coords[0]);
const pEnd = coordToPixel(coords[coords.length - 1]);
const grad = ctx.createLinearGradient(pStart[0], pStart[1], pEnd[0], pEnd[1]);
```

- 渐变轴向是一条“直线”（首尾连线）而不是沿折线拐弯。这点决定了效果更像是“沿着首尾方向扫过”的亮带。

### 4) 通过 `progress` 和 `tail` 定义“亮带”窗口

```ts
const head = line.progress; // 亮带“头部”（0~1）
const tailStart = Math.max(0, head - line.tail); // 亮带“尾部”的起点

if (tailStart > 0) grad.addColorStop(0, line.fadeColor);
grad.addColorStop(tailStart, line.fadeColor); // 尾迹开始前都是淡色

grad.addColorStop(head, line.frontColor); // 亮带中心（头部）为前景色

// 在 head 之后立刻回到淡色，形成“锐利边界”，保证亮带长度≈tail
grad.addColorStop(Math.min(1, head + 0.0001), line.fadeColor);

// 渐变末尾兜底
grad.addColorStop(1, line.fadeColor);
```

- 可以把整个 0~1 区间想象成“归一化的线长度”。每一帧：
  - [0, tailStart) 与 (head, 1] 用 `fadeColor`（透明）
  - [tailStart, head] 用 `frontColor`（亮色）
- 于是“亮色窗口”就被限制在 `[tailStart, head]`，当 `head` 逐帧右移时，这个窗口也随之移动，视觉上形成“流动”。

直觉图（抽象尺度 0~1）：

```
0                                   1
|-------淡色------|====亮色====|--淡色--|
                  ^head
        ^tailStart
```

### 5) 用渐变作为描边颜色来画整条线

```ts
vectorCtx.setStyle(
  new Style({
    stroke: new Stroke({
      color: grad, // 使用上面构造的线性渐变
      width: line.width,
      lineCap: 'round',
      lineJoin: 'round',
    }),
  }),
);
vectorCtx.drawGeometry(geom!);
```

- 这里并不是“只画一小段线”，而是“画整条线，但笔触颜色是带亮带窗口的渐变”。因此只有窗口对应的那一段看起来是亮的，其余部分都是透明/淡色。

### 6) 推进进度并回绕

```ts
line.progress += line.speed; // 每帧向前推进
if (line.progress > 1) line.progress -= 1; // 超过 1 从头开始
```

- `speed` 是“每帧”推进的份额（与显示器刷新率相关）。回绕保证亮带在 0~1 区间循环滚动。

### 7) 缩放门控：足够近才启动动画

```ts
private handleZoomChange() {
  const currentZoom = Math.floor(this.map.getView().getZoom() || 0);
  if (currentZoom >= this.minZoomLevel) {
    this.showLines(true);
    this.start();
  } else {
    this.showLines(false);
    this.stop();
  }
}
```

- 防止在远距离缩放时进行不必要的重绘，以节省性能。

### 小结：一句话心智模型

- 每帧触发重绘；在 `postrender` 中为整条线设置“只有一个亮色窗口”的线性渐变；移动窗口的位置（`progress`）= 移动亮段 = 看到“流动”。

---

## 十二、动手快速验证（建议数值）

- 超慢移动：`speed = 0.002`，`tail = 0.15`，观察亮带缓慢前进。
- 很长尾迹：`tail = 0.6`，亮带会变长，更像“能量波动”。
- 瞬间跳跃（不推荐）：`speed = 0.1`，窗口移动很快，可能视觉不连贯。
- 反向移动：将 `progress` 每帧减去 `speed`（需改源码），亮带反向流动。

## 十三、进阶：用时间解耦速度（可选实现思路）

当前 `speed` 是“每帧步长”。可以改为“每秒速度”，体验更一致：

```ts
// 思路示例（文档演示用，非现有源码）：
private lastTs = 0;
private start() {
  if (this.running) return;
  this.running = true;
  const loop = (ts: number) => {
    if (!this.running) return;
    const dt = this.lastTs ? (ts - this.lastTs) : 16; // ms
    this.lastTs = ts;
    // 基于时间推进进度，假设 speed 表示每秒走完的比例（0~1/秒）
    for (const line of this.lines) {
      if (line.disposed) continue;
      line.progress = (line.progress + line.speed * dt / 1000) % 1;
    }
    this.map.render();
    this.rafId = requestAnimationFrame(loop);
  };
  requestAnimationFrame(loop);
}
```

这样 `speed = 0.5` 就表示“2 秒走完全程”，与设备刷新率无关。

---

## 十四、术语释义 / FAQ（基于前面提问的解释）

### 1) postrender 是什么事件？

- 定义：OpenLayers 的渲染周期事件之一，在“本图层完成其常规样式绘制之后”触发。
- 触发时机：地图需要重绘该图层时（平移/缩放/旋转、数据或样式变化、或手动 `map.render()`）。
- 监听位置：`layer.on('postrender', handler)`；也可以在 `map` 上监听图层级别的渲染事件。
- 事件对象类型：`RenderEvent`，常用字段：
  - `evt.context`：`CanvasRenderingContext2D`（仅 Canvas 渲染器路径可用）。
  - `evt.frameState`：当前帧视图状态（分辨率/旋转/矩阵等）。
- 搭配 `getVectorContext(evt)`：只可在渲染回调中调用，返回“即时矢量绘制上下文”，用于本帧叠加自定义几何与样式。
- 与 `prerender` 的区别：`prerender` 在绘制之前触发，适合做裁剪/清屏/全局滤镜；`postrender` 在绘制之后触发，适合叠加高亮、动画等后处理。
- 注意：`postrender` 每帧都会执行，回调内应减少对象创建、避免重度计算。

### 2) coordToPixel 是什么功能？

- 功能：把“地理坐标（Coordinate，投影坐标）”转换为“当前帧 Canvas 的像素坐标”。
- 依据：使用 `evt.frameState.coordinateToPixelTransform` 仿射矩阵 `[a,b,c,d,e,f]` 完成映射：
  - `x' = a*x + c*y + e`
  - `y' = b*x + d*y + f`
- 为什么需要：Canvas API（如 `ctx.createLinearGradient`）工作在像素坐标系中，定义渐变、描边、文字等都需要像素位置。
- 注意：
  - 输入坐标要与地图当前投影一致（如 EPSG:3857）；若是经纬度需先投影。
  - 像素坐标原点在画布左上，y 轴向下。
  - 该变换仅对“当前帧/当前视图状态”有效，视图变化时矩阵也会变。

### 3) `getVectorContext(evt)` 与 `evt` 分别是什么？

- `evt`：渲染事件对象 `RenderEvent`，由 `postrender/prerender` 回调接收，携带本帧所需的上下文（`context`、`frameState` 等）。
- `getVectorContext(evt)`：来自 `ol/render` 的工具函数，只能在渲染回调里调用，返回“即时矢量绘制上下文（CanvasImmediateRenderer）”。
  - 作用：允许你使用 OpenLayers 的样式系统（`Style/Stroke/Fill/Icon` 等）在“本帧”立即绘制几何：
    - `vectorCtx.setStyle(new Style({...}))`
    - `vectorCtx.drawGeometry(geom)` 或 `drawFeature(feature, style)`
  - 生命周期：仅在本次回调期间有效；下次帧需要在新的回调中再次获取。
- 与直接使用 `evt.context` 的差异：
  - 直接 `ctx` 需要手写 Canvas 绘制指令；
  - `vectorCtx` 则沿用 OL 的样式与几何 API，便于与已有要素/样式系统一致化。

### 4) change:resolution 是什么事件？

- 监听目标：`view.on('change:resolution', handler)`。
- 含义：当视图的分辨率（resolution，即“地图单位/像素”）发生改变时触发；缩放动作会连续改变分辨率，因此缩放动画期间会多次触发。
- 与 zoom 的关系：`getZoom()` 是基于 resolution 推导的便捷值；OL 的渲染内部以 resolution 为核心驱动。
- 本项目用途：每次缩放变化时触发 `handleZoomChange()`，决定是否显示动画、开启/停止帧循环。

---

## 十五、FlowRuntime 运行时属性详解（含 tail 重点）

下列属性对应 `addLine()` 时 push 入内部数组的运行时结构（见源码 57-66 行片段）。

- feature: Feature<LineString>
  - 对应这一条流动线的矢量要素（折线几何）。绘制时从要素的坐标获取整条线的路径。

- width: number
  - 线宽（像素单位）。值越大，亮带越粗。

- speed: number
  - 每帧推进的“进度步长”（0~1），在 postrender 中执行 `line.progress += speed`；超过 1 回绕到 0。
  - 数值越大，亮带移动越快。当前实现与刷新率耦合。

- tail: number 〈重点〉
  - 亮带“尾迹长度”的归一化比例（0~1），定义渐变轴上亮色窗口的宽度：
    - 令 `head = progress`，`tailStart = max(0, head - tail)`；
    - 渐变在 [tailStart, head] 区间为前景色，其余为淡色/透明；
    - 随着 `head` 每帧前移，亮色窗口也随之移动，形成“流动”。
  - 渐变轴的方向由首尾像素点 `(pStart, pEnd)` 决定，因此 tail 实际对应“首尾像素连线长度的百分比”，而非沿折线真实长度。
  - 近似：亮段像素长度 ≈ `tail × |pEnd - pStart|`。
  - 建议取值：0.1~0.3 更自然；过小像光点，过大接近整线全亮。
  - 边界：避免 `tail ≤ 0` 或 `tail > 1`，前者会导致停靠点顺序异常，后者窗口超过范围、呈现近乎全亮。

- frontColor: string
  - 窗口区间 [tailStart, head] 的亮色（默认 `#00ffff`）。

- fadeColor: string
  - 窗口之外区域的淡色或透明（默认 `rgba(0,255,255,0)`）。可设为半透明获得更柔和过渡。

- progress: number
  - 亮带头部位置（0~1）。每帧推进并在 >1 时回绕，配合 tail 决定亮带窗口位置与长度。

- disposed: boolean
  - 资源回收标记。`removeLine/clear` 时置为 true，并从图层 source 移除，渲染循环将跳过处理。

小技巧（根据线长/观感调整 tail）

- 线很长：可适当增大 tail（0.2~0.4），避免亮带过短不明显。
- 线很短：减小 tail（0.08~0.15），并可配合减小 width，避免近乎全亮。
- “能量波”效果：tail 提高到 0.4~0.6，会像大片能量在推进。
- “脉冲点”效果：tail 降低到 0.05~0.1，亮段更接近光点。

---

## 十六、进阶图示：progress/tail 渐变窗口

下图演示 head=0.6、tail=0.2 的情况：亮色窗口区间为 [0.4, 0.6]，其余为淡色/透明。

![image-20251218142934006](https://s2.loli.net/2025/12/18/dhNUvM5Ae9cmJfw.png)

---

## 十七、postrender 在缩小时仍触发的原因与优化

现象：把地图缩到小于阈值后，动画看不到，但 `layer.on('postrender', ...)` 仍在触发，日志持续输出。

原因：postrender 跟随“图层是否被渲染”而触发，只要地图有重绘且图层可见，该事件就会触发；与回调里是否实际绘图无关。

优化方案（从轻到重）：

1. 将日志放在守卫之后，避免无效刷屏

```ts
this.layer.on('postrender', (evt) => {
  const currentZoom = Math.floor(this.map.getView().getZoom() || 0);
  if (
    !this.running ||
    !this.linesVisible ||
    this.lines.length === 0 ||
    currentZoom < this.minZoomLevel
  ) {
    return; // 注意：不要在 return 之前 console.log
  }
  // console.log('drawing flow line frame...');
  // 真正的绘图逻辑...
});
```

2. 阈值以下直接隐藏图层，彻底阻断本层渲染（推荐，前提是该层只用于动画）

```ts
// 可选：将 showLines 改为切换图层可见性
private showLines(visible: boolean) {
  if (this.linesVisible === visible) return;
  this.linesVisible = visible;
  this.layer.setVisible(visible); // 关键：隐藏后本层不再渲染，postrender 也不会触发
  this.map.render();
}
```

注意：仅当这个 VectorLayer 专用于动画时使用此方案；若该层还有其他要素，请谨慎使用。

3. 在无数据时解绑 postrender 监听，避免空跑

```ts
import { unByKey } from 'ol/Observable'; // 或 'ol/events'，视 OL 版本而定

private postrenderKey?: any;

private ensureListening() {
  if (this.listening) return;
  this.postrenderKey = this.layer.on('postrender', this.onPostrender);
  this.listening = true;
}

private stopListening() {
  if (this.postrenderKey) {
    unByKey(this.postrenderKey);
    this.postrenderKey = undefined;
    this.listening = false;
  }
}

clear() {
  // ...移除所有线...
  this.lines = [];
  this.stop();
  this.stopListening(); // 无线条时解绑
}
```

4. 排查外部循环渲染

- 确认项目其他地方是否存在循环调用 `map.render()`（例如其他动画层或定时器）。它会让所有可见图层的 postrender 都频繁触发。

---