## 项目的入口

项目启动时，会注册store、router、以及自定义的模块（setup里面）

![image-20221213172647335](https://f.pz.al/pzal/2022/12/13/9c32e7361548a.png)

setup包含的模块：

### 1. route.js：

路由守卫，检查是否登录状态，以及路由的白名单

### 2. request.js ：

对HttpRequest实例的进一步封装，比如添加请求错误提示

```js
//request.js
import HttpRequest from '@packages/utils/http/request';
export const request = new HttpRequest();
```

- `@packages/utils/http/request`下的request.js是一个基于axios封装的基础类，里面设置了很多拓展方法：比如设置请求、响应拦截方法，设置baseUrl等。

![image-20221213173808849](https://f.pz.al/pzal/2022/12/13/20c7e39068899.png)

​		`instance`是通过`axios.create()`创建出来的实例：

```js
createRequest(config) {
    this.instance = axios.create({ ...config });
    return this.instance;
  }
```

- `setup/request.js`是一个基于`@packages/utils/http/request`创建的实例。在里面使用了实例上的拓展方法，定义了具体的请求拦截规则、响应拦截规则、设置BaseUrl，以及挂在到app全局的方法：`$fetch`

  ```js
  app.config.globalProperties.$fetch = request.instance
  ```

### 3. api.js

使用`apiRegister`上的定义请求实例方法`setRequest`，把在`setup/request.js`创建的axios实例传进去，实现`apiRegister.apis`里面每个请求函数都通过这个axios实例发起请求。

> 此文件需要注册在request.js之后

```js
import apiRegister from '../../packages/api';

export default function (app) {
  apiRegister.setRequest(app.config.globalProperties.$fetch);
}
```

### 4. error.js

加载异常提示

### 5. index.js

把所有的模块导入，对外暴露一个install函数，把传进来的app传到各模块，按照顺序执行。

```js
import requestSetup from './request';
import apiSetup from './api';
import routeSetup from './route';
import errorSetup from './error';

const setup = {
  install(app) {
    requestSetup(app);
    apiSetup(app);
    routeSetup();
    errorSetup();
  },
};

export default setup;
```

# 项目的公共组件

## SearchForm 动态筛选组件

![image-20221214172757178](https://f.pz.al/pzal/2022/12/14/237a211d6b069.png)

通过props传入options，动态渲染

![image-20221214172845225](https://f.pz.al/pzal/2022/12/14/3f94b9ffa5772.png)

动态渲染：

![image-20221214173532574](https://f.pz.al/pzal/2022/12/14/a12293fc9b78c.png)

外部父组件定义数据：

![image-20221214173438978](https://f.pz.al/pzal/2022/12/14/7a69d846fed01.png)

# 路由跳转

使用的是原生的router方法，没有封装。

```js
router.push({
        name: _name,
        query: {
          id: assetId || 'new',
          type: assetType,
        },
      });
```



```js
setup() {
    const router = useRouter();
    // 资产类型信息（路由名+描述） 资产类型 01=资源资产 02=固定资产 03=投资资产 04=无形资产 99=其它资产
    const descType = {
      '01': { name: 'assetResource' },
      '02': { name: 'assetFixed' },
      '04': { name: 'assetIntangible' },
      '03': { name: 'assetInvest' },
      '99': { name: 'assetOther' },
    };
    // 跳转新增or编辑
    const toOption = async ({ assetType, assetId }) => {
      // 闲时资产(true)正常编辑；忙时资产/临时资产(false)停留当前页
      const isToGo = await judgeType({
        assetId,
      });
      if (!isToGo) return;
      //从字典中取出名字
      const _name = descType[assetType]?.name || null;
      if(!_name){
        AMessage.error(!assetType ? '资产类型不存在！' : '资产管理出错了，请联系管理人员！');
        return;
      }
      router.push({
        name: _name,
        query: {
          id: assetId || 'new',
          type: assetType,
        },
      });
    };
  }
```

# 字典管理

一般需要接口动态获取的搜索字段，统一在Vuex中的`dict.js`文件中存储，使用`VuexPersister`插件持久化存储数据，这样每个页面切换时不用重复获取下拉数据。

![image-20221214192302295](https://f.pz.al/pzal/2022/12/14/f975952c8d52b.png)

一般都在页面初始化的`mounted`阶段获取字段

![image-20221214191858324](https://f.pz.al/pzal/2022/12/14/e783ecebbda9e.png)

通过hook的方法更新

![image-20221214192714148](https://f.pz.al/pzal/2022/12/14/bcc6e1e120af5.png)

最终都是调用Vuex派发action

![image-20221214192644669](https://f.pz.al/pzal/2022/12/14/09e8cfe101ac3.png)

![image-20221214191738041](https://f.pz.al/pzal/2022/12/14/7fd9ad51e3b7d.png)

## 存放获取字段的地方

不同的开发者，写的字典存放的地方不一样，需要注意

![image-20221214192921441](https://f.pz.al/pzal/2022/12/14/2863c7709e7e1.png)

![image-20221214192937598](https://f.pz.al/pzal/2022/12/14/6ea187c0c1ec6.png)

![image-20221214192957829](https://f.pz.al/pzal/2022/12/14/3e6a9e3ceb753.png)