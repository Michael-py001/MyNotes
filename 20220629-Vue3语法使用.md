# 20220629-Vue3语法使用

## ref和模板上ref同名，获取组件dom

> [模板 ref | Vue.js (vuejs.org)](https://staging-cn.vuejs.org/guide/essentials/template-refs.html#accessing-the-refs)

为了通过组合式 API 获得该模板 ref，我们需要声明一个同名的 ref：

```html
<li-ChooseTimePopup ref="ChooseTimePopup" v-model="showTimePopup" @confirm="updateTime"></li-ChooseTimePopup>
```

```js
  let ChooseTimePopup = ref(null)
```

可以获取这个组件向外暴露的方法和dom

![image-20220629184317276](https://s2.loli.net/2022/06/29/feQETN4OR8z7ucr.png)

## setup语法 使用emit 

> [单文件组件  | Vue.js (vuejs.org)](https://staging-cn.vuejs.org/api/sfc-script-setup.html#defineprops-defineemits)

script setup语法里面，不能直接获取`this.$emit()`，需要使用`defineEmits`先声明，再使用

```js
const emit = defineEmits(['update:modelValue','confirm'])
emit('update:modelValue',bool)
emit('confirm',selectTimes)
```

## setup语法 defineExpose组件向外暴露内容

> [单文件组件  | Vue.js (vuejs.org)](https://staging-cn.vuejs.org/api/sfc-script-setup.html#defineexpose)

### 供ref使用

```js
//子组件 
function close() {
    show.value = false
  } 
  function open() {
    show.value = true
  } 
defineExpose({
    close,
    open
  })
```

```html
//父组件
<view ref="componentsRef"></view>
let componentsRef = ref('')
componentsRef.value.open()
```

### 可以在其他option中使用

```js
methods:{
	test() {
	  this.close()
	}
}
```



## option api的setup语法

`setup`里面包含两个参数，第一个`props`，第二个`ctx`，包含emit等

```js
export default {
  props: {
    msg: { type: String, required: true },
    count: { type: Number, default: 1 },
    foo: String
  },
  setup(props,ctx) {
    watchEffect(() => {
      console.log(props.msg, props.count, props.foo)
    })
  }
    
}
```

## 获取Vue全局挂载的方法

全局挂载

```js
Vue.config.globalProperties.$ShowToast = ShowToast
Vue.config.globalProperties.$Tool = ChooseImage
```



```js
import {getCurrentInstance} from 'vue'
const {proxy:vueCtx} = getCurrentInstance()

//选择图片
function chooseImg() {
   proxy.$Tool.ChooseImage().then(res=>{
     console.log(res)
     let {tempFilePaths} = res
     imgList.push(...tempFilePaths)
     console.log("imgList：",imgList)
   })
 }
```

## 响应性语法糖

> [响应性语法糖 | Vue.js (vuejs.org)](https://staging-cn.vuejs.org/guide/extras/reactivity-transform.html#refs-vs-reactive-variables)
>
> [响应式基础 | Vue.js (vuejs.org)](https://staging-cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#reactivity-transform)

每一个会返回 ref 的响应性 API 都有一个相对应的、以 `$` 为前缀的宏函数。包括以下这些 API：

- [`ref`](https://staging-cn.vuejs.org/api/reactivity-core.html#ref) -> `$ref`
- [`computed`](https://staging-cn.vuejs.org/api/reactivity-core.html#computed) -> `$computed`
- [`shallowRef`](https://staging-cn.vuejs.org/api/reactivity-advanced.html#shallowref) -> `$shallowRef`
- [`customRef`](https://staging-cn.vuejs.org/api/reactivity-advanced.html#customref) -> `$customRef`
- [`toRef`](https://staging-cn.vuejs.org/api/reactivity-utilities.html#toref) -> `$toRef`

当启用响应性语法糖时，这些宏函数都是全局可用的、无需手动导入。但如果你想让它更明显，你也可以选择从 `vue/macros` 中引入它们：

```js
import { $ref } from 'vue/macros'

let count = $ref(0)
```

```html
<script setup>
let count = $ref(0)

console.log(count)

function increment() {
  count++
}
</script>

<template>
  <button @click="increment">{{ count }}</button>
</template>
```

## Vue3 watch 侦听 props 的变化

`watch()` 默认是懒侦听的，即仅在侦听源发生变化时才执行回调函数。

第一个参数是侦听器的**源**。这个来源可以是以下几种：

- 一个函数，返回一个值
- 一个 ref
- 一个响应式对象
- ...或是由以上类型的值组成的数组

第二个参数是在发生变化时要调用的回调函数。这个回调函数接受三个参数：新值、旧值，以及一个用于注册副作用清理的回调函数。

第三个可选的参数是一个对象，支持以下这些选项：

- **`immediate`**：在侦听器创建时立即触发回调。第一次调用时旧值是 `undefined`。
- **`deep`**：如果源是对象，强制深度遍历，以便在深层级变更时启动回调。参考[深层侦听器](https://staging-cn.vuejs.org/guide/essentials/watchers.html#deep-watchers)一节。
- **`flush`**：调整回调函数的刷新时机。参考[回调的刷新时机](https://staging-cn.vuejs.org/guide/essentials/watchers.html#callback-flush-timing)一节。
- **`onTrack / onTrigger`**：调试侦听器的依赖。参考[调试侦听器](https://staging-cn.vuejs.org/guide/extras/reactivity-in-depth.html#watcher-debugging)一节。

与 [`watchEffect()`](https://staging-cn.vuejs.org/api/reactivity-core.html#watcheffect) 相比，`watch()` 使我们可以：

- 懒执行副作用；
- 更加明确是应该由哪个状态触发侦听器重新执行；
- 可以访问所侦听状态的前一个值和当前值。

**示例**

### 侦听一个 getter 函数：

```js
const state = reactive({ count: 0 })
watch(
  () => state.count,
  (count, prevCount) => {
    /* ... */
  }
)
```

### 侦听一个 ref：

```js
const count = ref(0)
watch(count, (count, prevCount) => {
  /* ... */
})
```

### 侦听 `props` 上的属性变化

如果我们想侦听 `props` 上的属性变化，需要采用**第一种**写法

```javascript
// 假设 props 上有个 name 属性
// 下面的写法会生效
watch(
  () => props.name,
  (count, prevCount) => {
    /* ... */
  }
)

// 下面的写法不会被触发
watch(props.name, (count, prevCount) => {
  /* ... */
})
```

### 解构props

```js
let isPlaying = ref(false)
let props= defineProps({
    modelValue:Boolean
  })
const { modelValue } = toRefs(props)
watch(modelValue,(value)=>{
    isPlaying.value = value
})
```

当直接侦听一个响应式对象时，侦听器自动处于深层级模式：

```js
const state = reactive({ count: 0 })
watch(state, () => {
  /* 深层级变更状态所触发的回调 */
})
```

## 选项式使用setup()

> [组合式 API：setup() | Vue.js (vuejs.org)](https://staging-cn.vuejs.org/api/composition-api-setup.html#basic-usage)

`setup` 函数的第一个参数是组件的 `props`。和标准的组件一致，一个 `setup` 函数的 `props` 是响应式的，并且会在传入新的 prop 时同步更新。

```js
export default {
  props: {
    title: String
  },
  setup(props) {
    console.log(props.title)
  }
}
```

请注意如果你解构了 `props` 对象，解构出的变量将会丢失响应性。因此我们推荐通过 `props.xxx` 的形式来使用其中的 prop。

如果你确实需要解构 `props` 对象，或者需要将某个 prop 传到一个外部函数中并保持响应性，那么你可以使用 [toRefs()](https://staging-cn.vuejs.org/api/reactivity-utilities.html#torefs) 和 [toRef()](https://staging-cn.vuejs.org/api/reactivity-utilities.html#toref) 这两个工具 API：

```js
import { toRefs, toRef } from 'vue'

export default {
  setup(props) {
    // 将 `props` 转为一个其中全是 ref 的对象，然后解构
    const { title } = toRefs(props)
    // `title` 是一个追踪着 `props.title` 的 ref
    console.log(title.value)

    // 或者，将 `props` 的单个 property 转为一个 ref
    const title = toRef(props, 'title')
  }
}
```

### Setup 的上下文[#](https://staging-cn.vuejs.org/api/composition-api-setup.html#setup-context)

传入 `setup` 函数的第二个参数是一个 **Setup 上下文**对象。上下文对象暴露了其他一些在 `setup` 中可能会用到的值：

```js
export default {
  setup(props, context) {
    // Attribute（非响应式的对象，等价于 $attrs）
    console.log(context.attrs)

    // 插槽（非响应式的对象，等价于 $slots）
    console.log(context.slots)

    // 触发事件（函数，等价于 $emit）
    console.log(context.emit)

    // 暴露公共 property（函数）
    console.log(context.expose)
  }
}
```

该上下文对象是非响应式的，可以安全地解构：

```js
export default {
  setup(props, { attrs, slots, emit, expose }) {
    ...
  }
}
```

### setup return对外暴露变量和方法

在setup里return出去的函数或者变量，可以在模板，computed等选项中使用

```js
import { useCounterStore } from '../stores/counterStore'

export default {
  setup() {
    const counterStore = useCounterStore()

    return { counterStore }
  },
  computed: {
    tripleCounter() {
      return counterStore.counter * 3
    },
  },
}
```

