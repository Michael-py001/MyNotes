# 使用antv + mapbox-gl 实现地图渲染&曲线&区域

效果图：

![image-20251230113432002](https://s2.loli.net/2025/12/30/AsuSMkTzdeCQmO2.png)

## 一、核心库简介

1. mapbox-gl-js

   - Mapbox 官方 WebGL 地图渲染引擎；负责底图渲染、缩放、旋转、投影计算等。

   - 需提供 Mapbox Token；若用自建地图瓦片可改写 style:url。

2. @antv/l7

   - AntV 数据可视化家族的 WebGL 地理可视化引擎，内核同样基于 mapbox-gl，专注在图层（Layer）与数据可视化表达。

   - 对点、线、面、热力、栅格、3D 柱状、渲染动画等封装良好，链式 API 友好。

3. @antv/l7-maps

   - L7 对不同底图供应商（Mapbox、Gaode、Google…）的适配层。

   - 通常 import { Mapbox } from '@antv/l7-maps'，再注入到 L7 Scene。

> 版本建议：
>
> "mapbox-gl": "^2.15.0",
>
> "@antv/l7": "^2.10.0",
>
> "@antv/l7-maps": "^2.10.0"

## 二、环境准备

```bash
# 1. 安装依赖
pnpm add mapbox-gl @antv/l7 @antv/l7-maps  # 或 yarn / npm

# 2. Mapbox Token(可选)
# https://account.mapbox.com/access-tokens 创建 Public token
# .env
VITE_MAPBOX_TOKEN=你的token字符串
```

vite.config.ts 可按需配置 define 或直接在代码读取 import.meta.env.VITE_MAPBOX_TOKEN。

## 三、Vue3 组合式封装 —— useMap.ts

```vue
// index.vue
<template>
/<div ref="mapRef" class="map" />	
</template>

<script setup lang="ts">
    const { initMap, mapRef, showHoverRow, toggleLayerVisibility } = useMap();

    onMounted(async () => {
        initMap();
    });
</script>
```



```ts
// useMap.ts
import { LineLayer, PolygonLayer, Popup, Scene, GaodeMap } from '@antv/l7';
import { drawCurve } from './draw/drawCurve';
import { drawIcons as drawIconsHelper } from './draw/drawIcons';
import { Mapbox } from '@antv/l7-maps';
import { Choropleth } from '@antv/l7plot';
import mapboxgl from 'mapbox-gl';
import 'mapbox-gl/dist/mapbox-gl.css';
import { polygenArr } from './polygenArr';
import areaList from './area-list.json';
import { ref } from 'vue';
import { theme } from './context';
import * as topojson from 'topojson-client';
import iconUrl from '../images/icon1.svg'; // 引入图标

type levelType = 'country' | 'province' | 'city' | 'district' | 'world';

export default function useMap() {
  const map = ref<any>(null);
  const mapRef = ref<any>(null);
  const isDestory = ref<boolean>(false);
  const showHoverRow = ref<any[]>([
    {
      'key': '容量',
      'val': 500
    },
    {
      'key': '业主',
      'val': '其他'
    }
  ]);
  const polygenList = ref<any[]>([]);
  const popCardInfoTitle = ref<any>('');
  const popCardRef = ref<any>(null);
  const layers = ref<any[]>([]);

  const cities = [
    { name: '肇庆市', coordinates: [112.46, 23.45] },
    { name: '韶关市', coordinates: [113.89, 25.1] }
  ];

  // 将 mapConfig 移动到 useMap 内部
  const mapConfig = () => {
    const assetsMap = {
      'dark': {
        parentColor: '#122954',
        childColor: '#202629',
        nationalColor: '#2b3a7c',
        strokeColor: '#7babcb',
        parentGradient: ['#122954', '#0a1a3a'] // 深色渐变
      },
      'light': {
        parentColor: '#D4E7FD',
        childColor: '#F0F8FF',
        nationalColor: '#c3dffc',
        strokeColor: '#fff',
        parentGradient: ['#a0cbf9', '#c3dffc'] // 浅色渐变：从上到下
      }
    };
    const list = areaList
      .filter(({ level, parent }) => level === 'city' && parent === 440000)
      .map((item) => Object.assign({}, item, { value: Math.random() * 5000 }));
    return {
      geoArea: {
        url: '/geo-data/',
        type: 'topojson' as const
      },
      source: {
        data: areaList,
        joinBy: {
          sourceField: 'adcode',
          geoField: 'adcode'
        }
      },
      viewLevel: {
        level: 'province' as levelType,
        adcode: 440000
      },
      color: '#a4cefa',
      // color: {
      //   field: ['parent', 'lat'],
      //   value: ({ parent, lat }) => {
      //     if (parent === 440000) {
      //       // 优先使用数据中的 lat 字段
      //       const latitude = lat || 23;
      //       const minLat = 20;
      //       const maxLat = 26;
      //       // 计算渐变比例（从0到1）
      //       const ratio = Math.max(0, Math.min(1, (latitude - minLat) / (maxLat - minLat)));
      //       const colors = assetsMap[theme].parentGradient;
      //       const color = interpolateColor(colors[1], colors[0], ratio);

      //       return color;
      //     }
      //     return assetsMap[theme].childColor;
      //   }
      // },
      style: {
        opacity: 1,
        stroke: assetsMap[theme].strokeColor,
        lineWidth: 0.6,
        lineOpacity: 1
      },
      chinaBorder: {
        national: { color: assetsMap[theme].nationalColor, width: 1, opacity: 1 },
        dispute: {
          color: '#ffc057',
          width: 1,
          opacity: 0.8,
          dashArray: [2, 2]
        },
        coast: { color: 'transparent', width: 0.7, opacity: 0.8 },
        hkm: { color: '#999', width: 0.7, opacity: 0.8 }
      },
      label: {
        visible: true,
        field: 'name',
        style: {
          fill: '#000',
          opacity: 0.8,
          fontSize: 12,
          stroke: '#fff',
          strokeWidth: 1.5,
          textAllowOverlap: false,
          padding: [5, 5]
        }
      }
    };
  };

  function initData() {
    drawPolygen();
  }
  // 绘制面
  function drawPolygen() {
    if (isDestory.value) return;
    polygenArr.forEach((area, aIndex) => {
      polygenList.value[aIndex] = {
        isShow: true,
        arr: []
      };
      const colorList = {
        dark: ['#36FCFF', '#4CFF73', '#FFD256', '#3A54DE'],
        light: ['#275FA1', '#30BA4E', '#E3811F', '#3A54DE']
      };

      if (area.length > 0) {
        const coordData = {
          features: [],
          type: 'FeatureCollection'
        };
        area.forEach((item, index) => {
          const end = JSON.parse(JSON.stringify(item.pointsArr)).sort((a, b) => a[1] - b[1]);
          coordData.features.push({
            geometry: {
              coordinates: [item.pointsArr],
              type: 'Polygon'
            },
            properties: {
              description: (item.description ? item.description : item.entityDesc) || '',
              capacity: item.capacity ? item.capacity : '',
              owner: item.ower ? item.ower : '',
              markerLatLng: end.length ? end[0] : [],
              managementUnit: item.managementUnit,
              projectStatus: item.project_status,
              city: item.city,
              companyType: item.type,
              companyName: item.companyName
            },
            id: index,
            type: 'Feature'
          });
        });
        if (coordData.features.length > 0) {
          const layer = new PolygonLayer({
            zIndex: 95
          })
            .source(coordData)
            .color(colorList[theme][aIndex])
            .shape('fill')
            .active(true)
            .style({
              opacity: 0.3
            });
          const layer2 = new LineLayer({
            zIndex: 96
          })
            .source(coordData)
            .color(colorList[theme][aIndex])
            .size(0.5)
            .style({
              opacity: 1
            });
          const popup = null;
          const titleArr = [
            '建设阶段',
            '地市',
            '业主',
            '水深',
            '风机厂家',
            '容量',
            '设计总包单位',
            '粤东场址',
            '所属海域',
            '主导开发业主',
            '项目情况'
          ];

          // layer.on('mousemove', (e) => {
          //   showHoverRow.value = [];
          //   const {
          //     description,
          //     capacity,
          //     owner,
          //     companyType,
          //     companyName,
          //     managementUnit,
          //     projectStatus,
          //     leadDevelopment
          //   } = e.feature.properties;
          //   showHoverRow.value.push({
          //     key: titleArr[5],
          //     val: capacity
          //   });
          //   if (managementUnit) {
          //     showHoverRow.value.push(
          //       {
          //         key: titleArr[8],
          //         val: `${managementUnit}海域`
          //       },
          //       {
          //         key: titleArr[9],
          //         val: leadDevelopment
          //       },
          //       {
          //         key: titleArr[10],
          //         val: projectStatus,
          //         className: 'prj-details'
          //       }
          //     );
          //   } else {
          //     showHoverRow.value.push({
          //       key: titleArr[2],
          //       val: `${owner}`
          //     });
          //     if (companyType !== '其他' && companyType !== 'Others' && companyType) {
          //       showHoverRow.value.push({
          //         key: companyType,
          //         val: companyName
          //       });
          //     }
          //   }

          //   popCardInfoTitle.value = description;
          //   popup = new Popup({
          //     offsets: [0, 0],
          //     closeButton: false
          //   })
          //     .setLnglat(e.feature.properties.markerLatLng)
          //     .setHTML(popCardRef.value);
          //   map.value.addPopup(popup);
          // });
          // layer.on('mouseout', () => {
          //   if (popup) {
          //     popup.close();
          //   }
          // });
          map.value.addLayer(layer);
          map.value.addLayer(layer2);
          polygenList.value[aIndex].arr.push(layer);
          polygenList.value[aIndex].arr.push(layer2);
          layers.value.push(layer, layer2);
        }
      }
    });
  }

  // 绘制曲线
  function drawCurveLayer() {
    if (isDestory.value) return;
    drawCurve({
      scene: map.value,
      layers: layers.value,
      start: cities[0].coordinates,
      end: cities[1].coordinates
    });
  }

  // 绘制图标
  function drawIconLayer() {
    if (isDestory.value) return;

    if (!map.value.hasImage('customIcon')) {
      map.value.addImage('customIcon', iconUrl);
    }

    drawIconsHelper({
      scene: map.value,
      layers: layers.value,
      iconKey: 'customIcon',
      iconSize: 20,
      cities
    });
  }

  // 切换图层可见性
  function toggleLayerVisibility(index: number) {
    const layerGroup = polygenList.value[index];
    if (layerGroup && layerGroup.arr) {
      layerGroup.isShow = !layerGroup.isShow;
      layerGroup.arr.forEach((layer: any) => {
        if (layerGroup.isShow) {
          layer.show();
        } else {
          layer.hide();
        }
      });
    }
  }

  // 初始化地图
  async function initMap({ needDrawPolygen = true }: { needDrawPolygen?: boolean } = { needDrawPolygen: true }) {
    const center = [114, 22.6];
    const zoom = 0;
    const mapInstance = new mapboxgl.Map({
      container: mapRef.value,
      style: 'blank',
      minZoom: 6.23,
      zoom: zoom,
      center: [center[0], center[1]],
      dragPan: false, // 禁止拖拽
      scrollZoom: false, // 禁止滚轮缩放
      doubleClickZoom: false, // 禁止双击缩放
      boxZoom: false, // 禁止框选缩放
      keyboard: false, // 禁止键盘缩放
      touchZoomRotate: false // 禁止触摸缩放和旋转
    });

    map.value = new Scene({
      id: mapRef.value,
      logoVisible: false,
      map: new Mapbox({
        mapInstance: mapInstance
      })
    });

    map.value.on('loaded', () => {
      new Choropleth(mapConfig() as any).addToScene(map.value);
      if (needDrawPolygen) {
        initData();
      }
      drawCurveLayer();
      drawIconLayer();
    });
  }
  return {
    initMap,
    mapRef,
    map,
    showHoverRow,
    popCardRef,
    popCardInfoTitle,
    toggleLayerVisibility
  };
}

```

```ts
// drawCurve.ts 曲线绘制

import { LineLayer } from '@antv/l7';
import type { Scene } from '@antv/l7';
import { generateCurveCoordinates } from '../utils/mapHelpers';

interface DrawCurveOptions {
  scene: Scene;
  layers: any[]; // 原组件里是 ref<any[]>
  start: number[]; // [lng, lat]
  end: number[]; // [lng, lat]
  mainColor?: string;
  shadowColor?: string;
  mainWidth?: number;
  shadowWidth?: number;
}

/**
 * 绘制带阴影的曲线
 */
export function drawCurve({
  scene,
  layers,
  start,
  end,
  mainColor = '#00FFA4',
  shadowColor = 'rgba(0,149,255,0.35)',
  mainWidth = 2,
  shadowWidth = 6
}: DrawCurveOptions) {
  const curveData = {
    type: 'FeatureCollection',
    features: [
      {
        type: 'Feature',
        properties: {},
        geometry: {
          type: 'LineString',
          coordinates: generateCurveCoordinates(start, end)
        }
      }
    ]
  };

  // 主线层
  const mainLayer = new LineLayer({ zIndex: 99 })
    .source(curveData, { parser: { type: 'geojson' } })
    .size(mainWidth)
    .shape('line')
    .color(mainColor);

  scene.addLayer(mainLayer);

  layers.push(mainLayer);
}
```

```ts
// drawIcons.ts 绘制icon

import { PointLayer } from '@antv/l7';
import type { Scene } from '@antv/l7';

interface City {
  name: string;
  coordinates: number[]; // [lng, lat]
}

interface DrawIconsOptions {
  scene: Scene;
  layers: any[];
  iconKey: string; // 已通过 scene.addImage 添加的 key
  iconSize?: number;
  cities: City[];
}

export function drawIcons({ scene, layers, iconKey, iconSize = 20, cities }: DrawIconsOptions) {
  const iconData = {
    type: 'FeatureCollection',
    features: cities.map((city) => ({
      type: 'Feature',
      properties: { name: city.name },
      geometry: { type: 'Point', coordinates: city.coordinates }
    }))
  };

  const iconLayer = new PointLayer({ zIndex: 100 })
    .source(iconData)
    .shape(iconKey)
    .size(iconSize)
    .style({ opacity: 1 });

  scene.addLayer(iconLayer);
  layers.push(iconLayer);
}

```

```ts
// mapHelpers.ts
// 通用地图相关工具函数

/**
 * 生成渐变色 在两个 hex 颜色之间插值，ratio 取值 0~1
 */
export function interpolateColor(color1: string, color2: string, ratio: number): string {
  const hex2rgb = (hex: string) => {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result
      ? {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16)
        }
      : { r: 0, g: 0, b: 0 };
  };

  const c1 = hex2rgb(color1);
  const c2 = hex2rgb(color2);

  const r = Math.round(c1.r + (c2.r - c1.r) * ratio);
  const g = Math.round(c1.g + (c2.g - c1.g) * ratio);
  const b = Math.round(c1.b + (c2.b - c1.b) * ratio);

  return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
}

/**
 * 生成贝塞尔曲线坐标
 * @param start 起点经纬度
 * @param end   终点经纬度
 * @param segments 线段数，越大越平滑
 */
export function generateCurveCoordinates(start: number[], end: number[], segments = 50): number[][] {
  const coordinates: number[][] = [];
  const midX = (start[0] + end[0]) / 2;
  const midY = (start[1] + end[1]) / 2;
  const offsetY = Math.abs(end[0] - start[0]) * 0.3; // 根据水平距离调整弧度
  const controlPoint = [midX, midY + offsetY];

  for (let i = 0; i <= segments; i++) {
    const t = i / segments;
    const x = Math.pow(1 - t, 2) * start[0] + 2 * (1 - t) * t * controlPoint[0] + Math.pow(t, 2) * end[0];
    const y = Math.pow(1 - t, 2) * start[1] + 2 * (1 - t) * t * controlPoint[1] + Math.pow(t, 2) * end[1];
    coordinates.push([x, y]);
  }

  return coordinates;
}
```

## 案例

### 组合式封装，核心思想

- 把「创建 Scene、添加图层、事件绑定」封装到一个组合式函数；

- 暴露 scene、layers 及常用方法（addLayer、removeLayer、flyTo、destroy）；

- 组件只负责挂载与业务交互，逻辑与 UI 分离。

```ts
// src/utils/useMap.ts
import { ref, onMounted, onUnmounted, shallowRef } from 'vue'
import { Scene } from '@antv/l7'
import { Mapbox } from '@antv/l7-maps'
import type { ILayer } from '@antv/l7'

interface UseMapOptions {
  id: string                            // 容器 DOM id
  style?: string                        // 底图样式 URL
  center?: [number, number]
  zoom?: number
}

export function useMap (options: UseMapOptions) {
  const scene = shallowRef<Scene>()     // L7 Scene
  const layerList = ref<ILayer[]>([])   // 已添加图层

  onMounted(() => {
    scene.value = new Scene({
      id: options.id,
      logoVisible: false,
      map: new Mapbox({
        style: options.style ?? 'mapbox://styles/mapbox/dark-v11',
        center: options.center ?? [121.5, 31.3],
        zoom: options.zoom ?? 5,
        pitch: 0,
        token: import.meta.env.VITE_MAPBOX_TOKEN
      })
    })

    // scene 加载完成后可在回调里添加首批图层
    scene.value.on('loaded', () => {
      console.log('Scene loaded')
    })
  })

  function addLayer (layer: ILayer) {
    if (!scene.value) return
    scene.value.addLayer(layer)
    layerList.value.push(layer)
  }

  function removeLayer (layer: ILayer) {
    if (!scene.value) return
    scene.value.removeLayer(layer)
    layerList.value = layerList.value.filter(l => l !== layer)
  }

  function flyTo (lnglat: [number, number], zoom = 8) {
    scene.value?.getMapService()?.flyTo({ center: lnglat, zoom })
  }

  onUnmounted(() => {
    scene.value?.destroy()
  })

  return {
    scene,
    layerList,
    addLayer,
    removeLayer,
    flyTo
  }
}
```

示例功能：

1. 底图初始化；

1. 渲染三个示例图层：

- 点：海上风机位置（散点 + 图标）

- 线：海缆路径（LineLayer）

- 面：风场多边形范围（PolygonLayer）

1. 右上角控制面板可动态开关图层。

```vue
// 页面组件
<template>
  <div class="map-page">
    <!-- 地图 DOM -->
    <div id="offshore-map" class="map-container"></div>

    <!-- 简易控制面板 -->
    <div class="panel">
      <el-checkbox v-model="showTurbine" @change="toggleTurbine">风机点</el-checkbox>
      <el-checkbox v-model="showCable"   @change="toggleCable"  >海缆线</el-checkbox>
      <el-checkbox v-model="showZone"    @change="toggleZone"   >风场面</el-checkbox>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue'
import { PointLayer, LineLayer, PolygonLayer } from '@antv/l7'
import { useMap } from '@/utils/useMap'

/* 1. 初始化地图 */
const { scene, addLayer, removeLayer } = useMap({
  id: 'offshore-map',
  center: [122.2, 30.5],
  zoom: 7,
  style: 'mapbox://styles/mapbox/light-v11'
})

/* 2. 数据源（真实项目通常后端接口获取） */
const pointData = [
  { lng: 122.15, lat: 30.7, name: 'Turbine-01' },
  { lng: 122.05, lat: 30.8, name: 'Turbine-02' },
  { lng: 121.95, lat: 30.9, name: 'Turbine-03' }
]

const lineData = {
  type: 'FeatureCollection',
  features: [{
    type: 'Feature',
    properties: {},
    geometry: {
      type: 'LineString',
      coordinates: [
        [121.9, 30.6],
        [122.3, 30.6],
        [122.5, 30.8]
      ]
    }
  }]
}

const polygonData = {
  type: 'FeatureCollection',
  features: [{
    type: 'Feature',
    properties: {},
    geometry: {
      type: 'Polygon',
      coordinates: [[
        [121.8, 30.4],
        [122.4, 30.4],
        [122.4, 30.9],
        [121.8, 30.9],
        [121.8, 30.4]
      ]]
    }
  }]
}

/* 3. 创建图层实例 */
let turbineLayer: PointLayer | null = null
let cableLayer: LineLayer | null = null
let zoneLayer: PolygonLayer | null = null

function buildLayers () {
  // 点
  turbineLayer = new PointLayer({})
    .source(pointData, { parser: { type: 'json', x: 'lng', y: 'lat' } })
    .shape('circle')
    .size(10)
    .color('#34d399')
    .style({ opacity: 0.9 })
    .active(true) // 鼠标 hover 高亮
    .label('name', { // 点标签
      fontSize: 14,
      textAnchor: 'top',
      spacing: 2,
      autoFit: true,
      stroke: '#000',
      strokeWidth: 0.5
    })

  // 线
  cableLayer = new LineLayer({})
    .source(lineData)
    .size(3)
    .color('#60a5fa')
    .style({ lineType: 'dash', dashArray: [2, 2] })
    .animate({ interval: 1, trailLength: 2, duration: 2 }) // 流动效果

  // 面
  zoneLayer = new PolygonLayer({})
    .source(polygonData)
    .color('#f87171')
    .shape('fill')
    .style({ opacity: 0.3 })
    .active(true)
}

/* 4. scene.loaded 后挂载 */
scene.value?.on('loaded', () => {
  buildLayers()
  addLayer(turbineLayer!)
  addLayer(cableLayer!)
  addLayer(zoneLayer!)
})

/* 5. 动态开关图层 */
const showTurbine = ref(true)
const showCable   = ref(true)
const showZone    = ref(true)

function toggleTurbine (val:boolean) {
  if (val) addLayer(turbineLayer!) ; else removeLayer(turbineLayer!)
}
function toggleCable (val:boolean)   {
  if (val) addLayer(cableLayer!)   ; else removeLayer(cableLayer!)
}
function toggleZone (val:boolean)    {
  if (val) addLayer(zoneLayer!)    ; else removeLayer(zoneLayer!)
}
</script>

<style scoped>
.map-page{ position:relative; width:100%; height:100%;}
.map-container{ width:100%; height:100%;}
.panel{
  position:absolute;top:12px;right:16px;
  background:#ffffffbb;padding:8px 12px;border-radius:6px;
  display:flex;flex-direction:column;gap:4px;font-size:14px;
}
</style>
```

要点说明：

- L7 的 Point/Line/PolygonLayer 均继承自 Layer，具备统一 API：source → shape/size/color → style → animate；

- animate 仅在 WebGL2 环境才生效；若出现黑屏检查浏览器硬件加速与同源策略；

- 复杂面（多 Rings）使用 coordinates: [ outerRing, hole1, hole2 ]；

- 标签 layer.label 字段可直接从数据中读取。

### 数据源格式梳理

当你调用 L7 的 layer.source(data, parser) 时，data 可以是什么样的“原料”，而 parser 又如何告诉 L7 去解析这些原料。只要理解了这两件事，就能把任何后端/文件里的坐标数据正确地“喂”进 L7。

#### 一、为什么要 parser？

- L7 并不知道你的数据长什么样：是一行行 CSV？还是一个 GeoJSON？

- parser 就像“翻译官”，把各种格式统一翻译成 L7 内部可识别的经纬度集合＋属性表。

- 不同 parser 对应不同字段映射方式：x:、y:、coordinates:、type: ……

#### 二、三种最常见的数据源 & parser 写法

##### 简单数组 / 普通 JSON

​	适合后端接口直接返回 [ { lng:121.1, lat:30.2, name:'A' }, … ] 这种扁平列表。

```ts
const data = [
  { lng: 122.15, lat: 30.7, name: 'Turbine-01' },
  { lng: 122.05, lat: 30.8, name: 'Turbine-02' }
]

new PointLayer()
  .source(
     data,
     { parser: { type: 'json', x: 'lng', y: 'lat' } }  // 告诉 L7: x 字段是 lng, y 字段是 lat
  )
```

要点：

- parser.type 填 json。

- x: y: 指明“经度字段名”和“纬度字段名”。

- 只要字段名对得上，数据键可以叫什么都行（比如 xField / yField）。

##### 标准 GeoJSON （FeatureCollection）

适用于线、面或点数据已经符合 GeoJSON 规范时；无需再指定 x/y。

```ts
const geojson = {
  type: 'FeatureCollection',
  features: [{
    type:'Feature',
    properties:{ id:1 },
    geometry:{
      type: 'LineString',
      coordinates: [
        [121.9, 30.6],
        [122.3, 30.6],
        [122.5, 30.8]
      ]
    }
  }]
}

new LineLayer()
  .source(geojson)  // 不写 parser，L7 自动识别 GeoJSON
```

要点：

- geometry.type 可以是 Point / LineString / Polygon / MultiPolygon …

- coordinates 一定是 [lng, lat] 顺序（经度在前）

- properties 内的所有键都会变成要素字段，可用于 .color('field')、label('field')

##### CSV / TSV / 纯字符串表格

比如 csv 文件第一行是表头 lng,lat,value。

```ts
const csvStr = `lng,lat,value
121.1,30.2,10
121.3,30.4,15`

new PointLayer()
  .source(
     csvStr,
     { parser:{ type:'csv', x:'lng', y:'lat' } }
  )
```

要点：

- parser.type 填 csv 或 tsv；

- x、y 指列名；

- 如果 csv 存放在服务器，可用 await fetch('/path/data.csv').then(r=>r.text()) 拿到字符串再传入。

#### 属性字段的使用

不管哪种格式，只要最终被 L7 解析成“要素属性”，就可以在后续这样使用：

```ts
.shape('hexagon')                    // geometry 外观
.size('value', v => v / 2)           // 按属性 value 调整大小
.color('category', ['red','blue'])   // 根据字段分组着色
.label('name', { fontSize: 12 })     // 读取 pointData 中的 name
```

#### 进阶补充

1) TopoJSON

如果后端返回的是 topojson，需要先 topo2geo（d3-geo 的 topojson-client）或 parser.type = 'topojson'。

2) 二进制格式（PBF 矢量瓦片）

L7 也支持直接传入 url，如 .source('http://xxx/{z}/{x}/{y}.pbf', { parser:{ type:'mvt' } })。适合大地图按需加载。

3) Parser 其它可选项

- coordinates: 'coord' 用于 JSON 数组里字段存放整个 [lng,lat] 的情况。

- featureId:'id' 设置要素唯一 id 供高亮/过滤。

#### 小结

- 想清楚：我的数据当前长什么样 → 找对 parser.type → 配置好字段映射即可。

- 点→可用简单 JSON；线/面→用 GeoJSON 最方便；表格→CSV parser；大规模在线加载→MVT(pbf)。

- 只要源数据正确、parser 告诉 L7 如何找到「经纬度」和「其它属性」，图层渲染就能一次成功。

## GeoJSON 的 properties要素属性

1. 如何在 GeoJSON 的 properties 中放置要素属性；

2. 在 L7 图层中如何读取并利用这些属性做：颜色映射、大小映射、标签、点击弹窗。

你只需要把下面代码粘进一个新的 Vue3 页面（或在 CodeSandbox / Vite 项目里跑）即可看到效果。

### 示例数据（points.geojson）

```json
{
  "type": "FeatureCollection",
  "features": [
    {
      "type": "Feature",
      "properties": {
        "name": "机位-A1",
        "capacity": 6,        // MW
        "status": "running"   // running / standby / fault
      },
      "geometry": {
        "type": "Point",
        "coordinates": [122.15, 30.7]
      }
    },
    {
      "type": "Feature",
      "properties": {
        "name": "机位-A2",
        "capacity": 8,
        "status": "standby"
      },
      "geometry": {
        "type": "Point",
        "coordinates": [122.05, 30.8]
      }
    },
    {
      "type": "Feature",
      "properties": {
        "name": "机位-A3",
        "capacity": 4,
        "status": "fault"
      },
      "geometry": {
        "type": "Point",
        "coordinates": [121.95, 30.9]
      }
    }
  ]
}
```

要点：

- 每个 Feature 的 properties 就是「要素属性表」。

- 这里只有 name / capacity / status 三列，你可以随意添加更多字段。

### Vue 页面代码

```vue
<template>
  <div class="map-wrapper">
    <div id="map-dom" class="map-box"></div>
  </div>
</template>

<script setup lang="ts">
import { onMounted } from 'vue'
import { Scene, PointLayer } from '@antv/l7'
import { Mapbox } from '@antv/l7-maps'
import geojsonData from './points.geojson?raw'   // vite 可使用 ?raw 直接读文本

onMounted(() => {
  const scene = new Scene({
    id: 'map-dom',
    logoVisible: false,
    map: new Mapbox({
      style: 'mapbox://styles/mapbox/light-v11',
      center: [122, 30.8],
      zoom: 7,
      token: import.meta.env.VITE_MAPBOX_TOKEN
    })
  })

  scene.on('loaded', () => {
    /* 1. 把 string 解析成对象 */
    const data = JSON.parse(geojsonData)

    /* 2. 创建点图层并利用属性做映射 */
    const pointLayer = new PointLayer({ zIndex: 2 })
      .source(data)                        // GeoJSON 自动识别，不用 parser
      .shape('circle')
      // ========== 利用 properties.status 做颜色映射 ==========
      .color('status', (s: string) => {
        if (s === 'running') return '#34d399'  // 绿
        if (s === 'standby') return '#fbbf24'  // 黄
        return '#ef4444'                       // 红
      })
      // ========== 利用 properties.capacity 做大小映射 ==========
      .size('capacity', (c: number) => c * 1.5) // MW × 1.5 做像素半径
      .style({ opacity: 0.9 })
      // ========== 利用 properties.name 做标签 ==========
      .label('name', {
        fontSize: 12,
        textAnchor: 'top',
        stroke: '#000',
        strokeWidth: 0.4
      })

    scene.addLayer(pointLayer)

    // ========== 点击事件：访问 e.feature.properties ==========
    pointLayer.on('click', (e) => {
      const { name, capacity, status } = e.feature.properties
      alert(`${name}\n容量：${capacity}MW\n状态：${status}`)
    })
  })
})
</script>

<style scoped>
.map-wrapper { width: 100%; height: 100vh; }
.map-box     { width: 100%; height: 100%; }
</style>
```

### 关键行逐句解释

**① .source(data)**

这里 data 是标准 GeoJSON，L7 自动解析。所有属性字段（name、capacity、status …）都会进入 L7 的「字段字典」。

**② .color('status', mapperFn)**

第一个参数给出字段名（字符串）；第二个是映射函数，拿到当前要素的 status 值，返回一个颜色值。

→ 如果你给第二个参数传一个颜色数组 ['red','green','blue']，L7 会自动按类别映射。

**③ .size('capacity', v => v * 1.5)**

同理，字段名是 capacity，第二个函数将 capacity 数值转化为像素半径大小。

你也可以直接 .size(10) 写死，或 .size('capacity', [4,10]) 让 L7 做区间映射。

**④ .label('name', options)**

直接把 name 字段渲染成文本标签。

**⑤ pointLayer.on('click', e => e.feature.properties.xxx)**

事件对象 e.feature 就是原 GeoJSON Feature，里面自然包含 properties；可随意取值做弹窗、侧栏等交互。

### 在其它数据格式中的等价做法

1) 如果你的数据源是普通数组：

```ts
const list = [
  { lon:121.1, lat:30.2, value:66, type:'A' },
  { lon:121.2, lat:30.3, value:88, type:'B' }
]

new PointLayer()
  .source(list, { parser:{ type:'json', x:'lon', y:'lat' } })
  .color('type', ['#4ade80','#f97316'])
  .size('value', v => v / 10)
```

此时「要素属性」指的就是每行对象本身；无需 properties 包裹。

2) CSV 与 MVT 亦然——只要你在 parser 把字段映射进来，后续 .color/.size/.label 用的就是这些字段。

### 小结回顾

- 在 GeoJSON 情况下，properties 是专门存放业务字段的地方；

- L7 会把这些字段带到可视化管线中，支持颜色、大小、过滤、标签、交互事件；

- 绑定字段的 API 规律：

color(字段, 映射) size(字段, 映射) shape(字段, 映射) label(字段, options) filter(字段, fn)；

- 记住：字段名永远是字符串，映射可以是函数、区间数组或固定值。
